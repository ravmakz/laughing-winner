\documentclass[letterpaper]{article}
%\VignetteIndexEntry{Data import and manipulation}
%\VignetteEngine{knitr::knitr}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            urlcolor = blue,
            citecolor = blue,
            linkcolor = blue]{hyperref}
\usepackage{array}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\usepackage{fullpage}
\usepackage{mathtools}
\usepackage{makeidx}
\usepackage{longtable}

% for bold symbols in mathmode
\usepackage{bm}
\newcommand{\R}{\mathbb{R}}
\newcommand{\m}[1]{\mathbf{#1}}
\newcommand{\tab}{\hspace*{1em}}
\newcolumntype{H}{>{\setbox0=\hbox\bgroup} c<{\egroup}@{}}
\newcommand{\cmdlink}[2]{%
  \texttt{\hyperref[#1]{#2}}%
}
\newcommand{\seclink}[2]{%
  \textsc{\hyperref[#1]{#2}}%
}

\newcommand{\poppr}{\textit{poppr}}
\newcommand{\Poppr}{\textit{Poppr}}
\newcommand{\adegenet}{\textit{adegenet}}
\newcommand{\Adegenet}{\textit{Adegenet}}
\newcommand{\tline}{
  \noindent
  \rule{\textwidth}{1pt}
  \par
}
\newcommand{\bline}{
  \noindent
  \rule{\textwidth}{1pt}
  \kern1pt
}

\newcommand{\jala}{
  \includegraphics[height = 5mm, keepaspectratio=true]{jalapeno-poppers}
}

\newcommand{\revjala}{
  \scalebox{-1}[1]{\jala{}}
}

\title{Data import and manipulation in poppr version 1.1.2.99-37}
\author{Zhian N. Kamvar$^{1}$\ and Niklaus J. Gr\"unwald$^{1,2}$\\\scriptsize{1)
Department of Botany and Plant Pathology, Oregon State University, Corvallis,
OR}\\\scriptsize{2) Horticultural Crops Research Laboratory, USDA-ARS,
Corvallis, OR}}

\begin{document}
% Set the width of figures.
\setkeys{Gin}{width=0.5\textwidth}

<<echo=FALSE, warning=FALSE>>=
knitr::opts_knit$set(out.format = "latex")
thm <- knitr::knit_theme$get("acid")
knitr::knit_theme$set(thm)
knitr::opts_chunk$set(concordance=TRUE)
knitr::opts_chunk$set(size = 'footnotesize', message = FALSE, warning = FALSE)
knitr::opts_chunk$set(out.width = '0.5\\linewidth', fig.align = "center", fig.show = 'asis')
@

<<poppr_funk, eval = TRUE, echo = FALSE>>=
print_command <- function(funk){
  fargs <- formals(funk)
  
  lapply(names(fargs), function(arg_name, fargs){
    arg <- fargs[[arg_name]]
    if (missing(arg)){
      fargs[[arg_name]] <<- as.symbol(arg_name)
      names(fargs)[names(fargs) == arg_name] <<- ""
    }
  }, fargs)
  fargs$call <- as.symbol(funk)
  fargs <- fargs[c(length(fargs), 1:(length(fargs) - 1))]
  return(as.call(fargs))
}
@

\definecolor{light-gray}{gray}{0.97}
\definecolor{salmon}{HTML}{F0AAAA}

\maketitle 
\begin{abstract} 
\Poppr{} provides open-source, cross-platform tools for quick analysis of
population genetic data enabling focus on data analysis and interpretation.
While there are a plethora of packages for population genetic analysis, few are
able to offer quick and easy analysis of populations with mixed reproductive
modes. \Poppr{}'s main advantage is the ease of use and integration with other
packages such as \adegenet{} and \textit{vegan}, including support for novel
methods such as clone correction, multilocus genotype analysis, calculation of
Bruvo's distance and the index of association.
\end{abstract} 
% Inserting the \Poppr{} logo here 

\begin{figure}[b]   
  \centering
  \label{logo}   
  \includegraphics{popprlogo} 
\end{figure} 

\newpage 
\begingroup
  \hypersetup{linkcolor=black} 
  \tableofcontents 
\endgroup 

%\linenumbers

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Introduction}
\label{intro}

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Purpose}
\label{intro:purpose}

\Poppr{} is an R package with convenient functions for analysis of
genetic data with mixed modes of reproduction including sexual and clonal
reproduction. While there are many R packages in CRAN and other repositories
with tools for population genetic analyses, few are appropriate for populations
with mixed modes of reproduction. There are several stand alone programs that
can handle these types of data sets, but they are often platform specific and
often only accept specific data types. Furthermore, a typical analysis often
involves switching between many programs, and converting data to each specific
format.

\Poppr{} is designed to make analysis of populations with mixed reproductive
modes more streamlined and user friendly so that the researcher using it can
focus on data analysis and interpretation. \Poppr{} allows analysis of haploid
and diploid dominant/co-dominant marker data including microsattelites, Single
Nucleotide Polymorphisms (SNP), and Amplified Fragment Length Polymorphisms
(AFLP). To avoid creating yet another file format that is specific to a program,
\poppr{} was created on the backbone of the popular R package \adegenet{} and
can take all the file formats that \adegenet{} can take (Genpop, Genetix, Fstat,
and Structure) and newly introduces compatibility with GenAlEx formatted files
(exported to CSV). This means that anything you can analyze in \adegenet{} can
be further analyzed with \poppr{}.

The real power of \poppr{} is in the data manipulation and analytic tools.
\Poppr{} has the ability to define multiple population hierarchies, clone-
censor, and subset data sets. With \poppr{} you can also quickly calculate
Bruvo's distance, the index of association, and easily determine which
multilocus genotypes are shared across populations.

\subsection{Resources}

This vignette will cover all of the material you need to know to efficiently
analyze data in \poppr{}. For information on methods of analysis (eg. index of
association, distance measures, AMOVA, ...), please read the manual pages
provided for each function.

As \poppr{} expanded from version 1.0, the vignette also expanded to be 80+ 
pages. As a result, it became clear that over 22,000 was less of a manual and 
more of a novella with a terrible plot. To remedy this, this vignette will focus
only on data manipulation and a separate vignette, ``algo", has been written
to give algorithmic details of analyses introduced with \poppr{}. 

As of spring 2014, Drs. Niklaus J. Gr\"unwald, Sydney E. Everhart, and I have 
co-authored a primer on using R for population genetic analysis. It is located
\href{http://grunwaldlab.cgrb.oregonstate.edu/popgen}{here} and the source code
can be found \href{https://github.com/grunwaldlab/Population_Genetics_in_R}{on
our github site}. 

\subsection{Getting Help}

If you have any questions or feedback, feel free to send a message to the \poppr{} forum at \url{http://groups.google.com/group/poppr}. You can submit bug reports
there or on our github site: \url{https://github.com/grunwaldlab/poppr}

\subsection{Acknowledgements}

Much thanks goes to Sydney E. Everhart for alpha testing, beta testing, feature
requests, proofreading, data contribution, and moral support throught the writing
of this package and manual. Thanks also to Brian Knaus, Ignazio Carbone, David Cooke,
Corine Schoebel, Jane Stewart, and Zaid Abdo for beta testing and feedback. 

The following data sets are included in \poppr{}: \texttt{Pinf} \cite{goss2014irish}, \texttt{monpop} (Sydney E. Everhart, unpublished),
\texttt{Aeut} \cite{Grunwald:2006}

\subsection{Citation}

The formal publication for \poppr{} was published in the journal PeerJ: \url{http://peerj.com/articles/281/}. To cite \poppr{}, please type in your R console:

<<popprcite, eval = FALSE, size="normalsize">>=
citation(package = "poppr")
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Installation}
\label{intro:install}


This manual assumes you have installed R. If you have not,
please refer to The CRAN home page at \url{http://cran.r-project.org/}. We also
recommend the Rstudio IDE (\url{http://www.rstudio.com/}), which allows the user
to view the R console, environment, scripts, and plots in a single window.

\subsubsection{From CRAN}
\tab\tab To install \poppr{} from CRAN, select ``Package
Installer" from the menu ``Packages \& Data" in the gui or type:

<<install, eval=FALSE>>=
install.packages("poppr", dependencies=TRUE)
@

All dependencies (\textit{adegenet, pegas, vegan, ggplot2, phangorn, ape,
reshape2} and \textit{igraph}) will also be installed. In the unfortunate case
this does not work, consult
\url{http://cran.r-project.org/doc/manuals/R-admin.html#Installing-packages}.

\subsubsection{From Source}
\tab\tab The tarball for \poppr{} can be downloaded from CRAN:
\url{http://cran.r-project.org/package=poppr}, under the \textsc{Resources} tab
in the Gr\"unwald Lab website:
\url{http://http://grunwaldlab.cgrb.oregonstate.edu/}, or via github at
\url{https://github.com/grunwaldlab/poppr}.

Since \poppr{} contains C code, it needs to be compiled, which means that you
need a working C compiler. If you are on Linux, you should have that, but if you
are on Windows or OSX, you might need to download some special tools:

\begin{description}
  \item[Windows] Download Rtools: \url{http://cran.r-project.org/bin/windows/Rtools/}
  \item[OSX] Download Xcode: \url{https://developer.apple.com/xcode/}
\end{description}

If you choose to install \poppr{} from a source file, you should first make sure
to install all of the dependencies with the following command:

<<install_depend, eval=FALSE>>=
install.packages(c("adegenet", "pegas", "vegan", "ggplot2", "phangorn", "ape", "igraph"))
@
\textbf{If you want to install from github, skip to the next section.}

After installing dependencies, download the package to your computer and then
install it with:
<<install_source, eval=FALSE>>=
install.packages("/path/to/poppr.tar.gz", type="source", repos=NULL)
@

\subsubsection{From github}
\tab\tab Github is a repository where you can find all stable and development
versions of \poppr{}. Installing from github requires a C compiler, so be sure
to read the section above for instructions on how to obtain that if you aren't
on a Linux system.

To install from github, you do not need to download the tarball since
there is a package called \textit{devtools} that will download and install the
package for you directly from github. After you have installed all dependencies
(see above section), you should download \textit{devtools}:
<<install_devtools, eval = FALSE>>=
install.packages("devtools")
@
Now you can execute the command \texttt{install\_github} with the user and 
repository name:
<<install_github, eval = FALSE>>=
library(devtools)
install_github(repo = "grunwaldlab/poppr")
@

If you are the adventurous type and are willing to test out unreleased versions 
of the package, you can also install the development version:
<<install_devel, eval = FALSE>>=
library(devtools)
install_github(repo = "grunwaldlab/poppr", ref = "devel")
@
Users who install this version do so at their own risk. Since it is a
development version, documentation may be incomplete or nonexistant for new
functions.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Quick start}
\label{intro:qstart}

\tab\tab The author assumes that if you have reached this point in the manual,
then you have successfully installed R and \poppr{}. Before proceeding, you
should be aware that R is case sensitive. This means that the words ``Case" and
``case" are different. You should also know where your R
package Library is located.
\begin{center}
   \fcolorbox{light-gray}{light-gray}{
        \begin{minipage}[t]{0.8\textwidth}
          {\large \textsc{What or where is my R package library?}}\\ 
          R is as powerful as it is through a community of people who submit
          extra code called ``Packages" to help it do specific things. These
          packages live in a certain place on your computer called an R library.
          You can find out where this library is by typing \texttt{.libPaths()}
        \end{minipage}
    }
\end{center}
Importing a file into R involves you knowing the path to your file and then
typing that into R's console. \texttt{getfile()} will help provide a point and
click interface for selecting a file. There are two steps:
<<echo=FALSE>>=
library(poppr)
x <- list(files="/path/to/R/poppr/files/rootrot.csv", path="/path/to/R/poppr/files")
@
Tell your computer to search R's library to find the \poppr{} and load the package:
<<getfilefunk, eval=FALSE>>=
library(poppr)
@
After that, you can use \texttt{getfile()}
<<getfilefunk2, eval=FALSE>>=
x <- getfile()
@
A pop up window will appear like this\footnote{This window
sometimes appears behind your current session of R, depending on the GUI and you
will have to toggle to this window}:
\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize A popup window as it appears in OSX (Mountain Lion).}
  \label{getfile window}
  \includegraphics{getfile}
\end{figure}
\newpage
\begin{center}
   \fcolorbox{light-gray}{light-gray}{
      \begin{minipage}[t]{0.8\textwidth}
        {\large \textsc{Hey! My window doesn't look like that!}}\\ 
        Now, this window will not match up to your window on your computer
        because you will probably not be in the right directory. Remember the
        first path in \texttt{.libPaths()}? Move to a folder called
        \textbf{poppr} in that path. In that folder, you will find another
        folder called \textbf{files}. Move there and your window will match the
        one displayed.
      \end{minipage}
    }
\end{center}


We can navigate throughout your entire computer through this window and tell R
where to go. The example I'm using goes to your R library directory where
\poppr{} is stored. If you don't know where that is, you can find it by typing
\texttt{find.package('poppr')} into the R command line. Once we select a file,
the file name and its path will be stored in the variable, x. We can confirm
that by typing \texttt{x} into R's command line.
<<getfilex>>=
x
@
Here we can see that \texttt{x} is a list with two entries: \texttt{\$files}
shows the files you selected and \texttt{\$path} shows the path to
those files.
\begin{center}
  \fcolorbox{light-gray}{light-gray}{
    \begin{minipage}[t]{0.8\textwidth}
      {\large \textsc{Not sure what I mean by path or working directory?}}\\
      For anyone who has never used a command line, this is a new concept. You
      can think of the path as an address. So instead of
      \texttt{"/path/to/R"}, you could have \texttt{"/USA/Oregon/Corvallis"}.
      Or on your computer, it could be 
      \texttt{"C:/users/poppr-user/R/win-library/3.1"} on Windows (where ``poppr-user"
       is your username) or 
      \texttt{"/Library/Frameworks/R.framework/Versions/3.1/Resources/library"} 
      on OSX. Each slash represents a folder that you would click on when
      you are using the mouse.

      A working directory is the folder that R is working in. It is where
      you can access and write files. When you tell R to read a file, it will
      only look for that file in your working directory. Note that you will not
      endanger your files by reading them into R. R works by making a copy of
      the file into memory. This means that you can manipulate the data in any
      way that you want without ever changing the original file.\\

      To find what your current working directory is set to, type
      \texttt{getwd()} into the R console. Usually, you will start off a session
      in your ``home" directory, which will look like this: \texttt{"$\sim$/"}.
      The command \texttt{setwd()} will change your working directory to any
      folder of your choice on your computer as indicated by the path that you
      provide. For more information, see Quick R at
      \url{http://www.statmethods.net}.
    \end{minipage}
  }
\end{center}

We will use \texttt{x\$files} to access the file. The \texttt{poppr()} function
provides a simple first analysis of your data directly from the file on the your
disk (For information on importing your data into R, see
section \seclink{intro:import}{Get out of my dreams and into my R.})
<<firstpoppr, eval=FALSE>>=
popdata <- poppr(x$files)
@
<<aflp, echo=FALSE>>=
options(width=90)
popprsoutput <- poppr(system.file("files/rootrot.csv", package="poppr"))
@
The output of \texttt{poppr()} was assigned to the variable \texttt{popdata}, so
let's look at the data.
<<firstpoppr2, eval=FALSE>>=
popdata
@
<<aflp2, echo=FALSE>>=
popprsoutput
@
The fields you see in the output include:
\begin{itemize}
  \item \texttt{Pop -} Population name (Note that ``Total" also means
  ``Pooled").
  \item \texttt{N -} Number of individuals observed.
  \item \texttt{MLG -} Number of multilocus genotypes (MLG) observed.
  \item \texttt{eMLG -} The number of expected MLG at the smallest sample size
  $\geq 10$ based on rarefaction. \cite{Hurlbert:1971}
  \item \texttt{SE -} Standard error based on \texttt{eMLG} \cite{Heck:1975}
  \item \texttt{H -} Shannon-Wiener Index of MLG diversity. \cite{Shannon:1948}
  \item \texttt{G -} Stoddart and Taylor's Index of MLG diversity.
  \cite{Stoddart:1988}
  \item \texttt{Hexp -} Nei's 1978 genotypic diversity (corrected for sample
  size), or  Expected Heterozygosity. \cite{Nei:1978}
  \item \texttt{E.5 -} Evenness, $E_5$.
  \cite{Pielou:1975}\cite{Ludwig:1988}\cite{Grunwald:2003}
  \item \texttt{Ia -} The index of association, $I_A$. \cite{Brown:1980}
  \cite{Smith:1993} \cite{Agapow:2001}
  \item \texttt{rbarD -} The standardized index of association, $\bar r_d$.
  \cite{Agapow:2001}
\end{itemize}

These fields are further described in the function \texttt{poppr}. You can
access the help page for \texttt{poppr} by typing \texttt{?poppr} in your R
console.

One thing to note about this output is the \texttt{NaN} in the column labeled
\texttt{SE}. In R, \texttt{NaN} means ``Not a number''. This is produced from
calculation of a standard error based on rarefaction analysis. Occasionally,
this calculation will encounter a situation in which it must attempt to take a
square root of a negative number. Since the root of any negative number is not
defined in the set of real numbers, it must therefore have an imaginary
component, $i$. Unfortunately, R will not represent the imaginary components of
numbers unless you specifically tell it to do so. By default, R represents these
as \texttt{NaN}.\\

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Importing data into poppr \{Get out of my dreams and into my R\}}
\label{intro:import}


There are several ways of reading data into R. One way is using the function
\texttt{getfile}.
\subsubsection{Function: getfile}
\label{intro:import:getfile}
\tab\tab \texttt{getfile} gives the user an easy way to point R to the directory
in which your data is stored. It is only meant for R GUIs such as Rstudio. Using
this on the command line has little advantage over setting the working
directory manually.\\
\tline{}
\begin{quote}
Default Command:
% \texttt{getfile(multi = FALSE, pattern = NULL, combine = TRUE)}
<<getfile_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "getfile"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{multi -} This is normally set to \texttt{FALSE}, meaning that it
  will only grab the file you selected. If it's \texttt{TRUE}, it will grab all
  files within the directory, constrained only by what you type into the
  \texttt{pattern} field.
  \item \texttt{pattern -} A pattern that you want to filter the files you get.
  This accepts regular expressions, so you must be careful with anything that is
  not an alphanumeric character.
  \item \texttt{combine -} This tells \texttt{getfile} to combine the path and
  all the files. This is set to \texttt{TRUE} by default so that you can access
  your files no matter what working directory you are in.
\end{itemize}
\bline{}

This method works for a single file, but let's say you had a lot of data sets
you wanted to import. Instead of doing these one-by-one, \texttt{getfile} has a
flag called \texttt{multi} telling the computer that you want to grab multiple
files in the folder:
<<multi_getfile, eval = FALSE>>=
x <- getfile(multi=TRUE)
@
A window would pop up again, and you should navigate to the same directory as
you had before, and select any of the files in that directory.
<<show_multi_getfile1,eval=FALSE>>=
x
@
<<show_multi_getfile,echo=FALSE>>=
x$files <- list.files(dirname(system.file("files/rootrot.csv", package="poppr")))
x$files <- paste(x$path, x$files, sep="/")
x
@
As you can see, now all of the files that existed in that directory are there!
Now you can look at all those files at once! We will use \texttt{poppr.all} to
produce a summary table for all of your files\footnote{These files do not need
to be similar in any way to do this analysis}. Let's set \texttt{digits = 2} to
only print 2 significant digits.
<<poppr.all, eval=FALSE>>=
all_files <- poppr.all(x$files)
print(all_files, digits = 2)
@
<<poppr.all_eval, echo=FALSE>>=
print(poppr.all(c(system.file("files/rootrot.csv", package="poppr"), 
                  system.file("files/rootrot2.csv", package="poppr"), 
                  system.file("files/simulated.dat", package="poppr"))), 
      digits = 2)
@

You've seen examples of how to use \texttt{getfile} to extract a single file and
all the files in a directory, but what if you wanted many files only of a
certain type or with a certain name? This is what you would use the
\texttt{pattern} argument for. For example, there are several data files with
different formats in the \adegenet{} folder in your R library. Let's take a look
at the names of these files.
\begin{center}
  \fcolorbox{light-gray}{salmon}{
    \begin{minipage}[t]{0.8\textwidth}
      \jala{} For the rest of this section, remember that every time you invoke
      \texttt{getfile()}, a window will pop up and you should select a file
      before hitting enter.
    \end{minipage}
  }
\end{center}
<<getfile_adegenet, eval=FALSE>>=
getfile(multi=TRUE)
@
Navigate to the \adegenet{} folder in your R library.
<<list_adegenet_files, echo=FALSE>>=
nancylist <- dir(dirname(system.file("files/nancycats.gtx",package="adegenet")))
list(
  files = paste("/path/to/R/adegenet/files", nancylist, sep="/"),
  path = "/path/to/R/adegenet/files"
)
@

We can see that we have a mix of files with different formats. If we tried to
run all of these files using poppr, we would have a problem because some of the
file formats have no direct import into a \texttt{genind} object (*.fasta, or
*.snp), or just simply are not supported (eg. *.rda files). To filter these
files, use the \texttt{pattern} argument. Let's say we only wanted the files
that have the word ``nancy'' in them.
<<getfile_nancy,eval=FALSE>>=
getfile(multi=TRUE, pattern="nancy")
@
<<show_getfile_nancy, echo=FALSE>>=
nancylist <- list.files(dirname(system.file("files/nancycats.gtx",package="adegenet")), pattern="nancy")
list(
  files = paste("/path/to/R/adegenet/files", nancylist, sep="/"),
  path = "/path/to/R/adegenet/files"
)
@
Now, let's exclude everything but genetix files (*.gtx).
<<getfile_gtx, eval=FALSE>>=
getfile(multi=TRUE, pattern="gtx")
@
<<show_getfile_gtx, echo=FALSE>>=
nancylist <- list.files(dirname(system.file("files/nancycats.gtx",package="adegenet")), pattern="gtx")
list(
  files = paste("/path/to/R/adegenet/files", nancylist, sep="/"),
  path = "/path/to/R/adegenet/files"
)
@
Now, let's only get FSTAT files (*.dat)
<<getfile_dat, eval=FALSE>>=
getfile(multi=TRUE, pattern="dat")
@
<<show_getfile_dat, echo=FALSE>>=
nancylist <- list.files(dirname(system.file("files/nancycats.gtx",package="adegenet")), pattern="dat")
list(
  files = paste("/path/to/R/adegenet/files", nancylist, sep="/"),
  path = "/path/to/R/adegenet/files"
)
@

Uh-oh. We've run into a problem. Three out of our four files are not FSTAT
files. Why did this happen? It happened because they happen to have
\texttt{"dat"} within their name. This problem can be solved, by using regular
expressions. If you are unfamiliar with regular expressions, you can think of
them as special characters that you can use to make your search pattern more
strict or more flexible. Since the topic of regular expressions can take up
several lectures, I will spare you the gory details. For this situation, the
only one you need to know is ``\texttt{\$}". The dollar sign indicates the end
of a word or string. If we want specific file extensions all we have to do is
add this to the end of the search term like so:
<<getfile_datend, eval=FALSE>>=
getfile(multi=TRUE, pattern="dat$")
@
<<show_getfile_datend, echo=FALSE>>=
nancylist <- list.files(dirname(system.file("files/nancycats.gtx",package="adegenet")), pattern="dat$")
list(
  files = paste("/path/to/R/adegenet/files", nancylist, sep="/"),
  path = "/path/to/R/adegenet/files"
)
@
Now we have our FSTAT file!
\subsubsection{Function: read.genalex}
\label{intro:import:read.genalex}

\tab\tab A very popular program for population genetics is GenAlEx
(\url{http://biology.anu.edu.au/GenAlEx/Welcome.html}) 
\cite{Peakall:2012, Peakall:2006}. GenAlEx runs within the Excel environment and
can be very powerful in its analyses. \Poppr{} has added the ability to read
*.CSV files\footnote{*.CSV files are comma separated files that are easily
machine readable.} produced in the GenAlEx format. It can handle data types
containing regions and geographic coordinates, but currently cannot import
allelic frequency data from GenAlEx. Using the \poppr{} function
\texttt{read.genalex} will import your data into \adegenet{}'s \texttt{genind}
object or \poppr{}'s \texttt{genclone} object (more information on that below).
For ways of formatting a GenAlEx file, see the manual here:
\url{http://biology.anu.edu.au/GenAlEx/Download_files/GenAlEx\%206.5\%20Guide.pdf}


Below is an example of the GenAlEx format. We will use the data set called
\texttt{microbov} from the \adegenet{} package to generate it. The data contains
three demographic factors: Country, Species and Breed contained within the
\texttt{@other} slot (detailed in \seclink{intro:genind:other}{The other slot}).
We will combine these and save the file to the desktop. Details of these
functions are presented elsewhere in this manual.

<<microsave, eval=FALSE>>=
library(poppr)
data(microbov)
microbov <- as.genclone(microbov)
sethierarchy(microbov) <- data.frame(other(microbov))
setpop(microbov) <- ~coun/breed/spe
genind2genalex(microbov, file="~/Desktop/microbov.csv")
@
<<microsave_message, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/microbov.csv ... Done.")
@

\setkeys{Gin}{width=\textwidth}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of
  the microbov data set. The first column contains the individual names, the
  second column contains the population names, and each subsequent column
  represents microsatellite genetic data. Highlighted in red is a list of
  populations and their relative sizes.}
  \label{microbov unmodified}
\includegraphics{unmod_dat}
\end{figure}

The GenAlEx format contains individuals in rows and loci in columns. Individual
data begins at row 4. Column A always contains individual names and column B
defines the population of each individual. Notice here that the three
demographic factors from the data have been concatenated with a ``\_''. This
allows us to import more than one population factor to use as hierarchical
levels in a \seclink{intro:genclone}{genclone object.}

\newpage

The First three rows contain information pretaining to the global data set. The
only important information for \poppr{} is the information contained in row 3
and the first three columns of row 1. 

\begin{table}[h!]
\centering
\begin{tabular}{|l|l|l|l|ll|}
  \hline
 & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \\ 
  \hline
 \textbf{1} & \# of Loci & \# of Individuals & \# of Populations & Pop1 Size & ...\\
 \hline
 \textbf{2} & - & - & - & Pop1 Name & ...\\
 \hline
 \textbf{3} & - & - & Locus 1 & ... & \\
  \hline
\end{tabular}
\end{table}

Highlighted in red in figure \ref{microbov unmodified} are definitions of the
number of populations and their respective sizes. As this is redundant
information, we can remove it. Below is an example of a valid data set that can
be imported into \poppr{}.

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of
  the microbov data set. This is the same figure as above, however the
  populations and counts have been removed from the header row and the third
  number in the header has been replaced by 1.}
  \label{microbov modified}
\includegraphics{mod_dat}
\end{figure}

\setkeys{Gin}{width=0.5\textwidth}

All GenAlEx formatted data can be imported with the command \texttt{read.genalex},
detailed below:
\newpage
\tline{}
\begin{quote}
Default Command:
<<read.genalex_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "read.genalex"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{genalex -} a *.CSV file exported from GenAlEx on your disk (For
  example: \texttt{"my\_genalex\_file.csv"}).
  \item \texttt{ploidy -} a number indicating the ploidy for the data set (eg 2
  for diploids, 1 for haploids).
  \item \texttt{geo -} GenAlEx allows you to have geographic data within your
  file. To do this for \poppr{}, you will need to follow the first format
  outlined in the GenAlEx manual and place the geographic data AFTER all genetic
  and demographic data with one blank column separating it (See the GenAlEx
  Manual for details). If you have geographic information in your file, set this
  flag to \texttt{TRUE} and it will be included within the resulting genind
  object in the \texttt{@other} slot. (If you don't know what that is, don't
  worry. It will be explained later in \seclink{intro:genind:other}{The other
  slot.})
  \item \texttt{region -} To format your GenAlEx file to include regions, you
  can choose to include a separate column for regional data, or, since regional
  data must be in contiguous blocks, you can simply format it in the same way
  you would any other data (see the GenAlEx manual for details). If you have
  your file organized in this manner, select this option and the regional
  information will be stored in the \texttt{@other} slot of the resulting
  genind object or be incorporated into the hierarchy of the genclone object.
  \item \texttt{genclone -} This flag will convert your data into a
  \texttt{genclone} object (see \seclink{intro:genclone}{Send in the clones} for
  more info).
  \item \texttt{sep -} The separator argument for columns in your data. It
  defaults to ``,".
\end{itemize}
\bline{}
\begin{center}
  \fcolorbox{light-gray}{light-gray}{
    \begin{minipage}[t]{0.8\textwidth}
      {\large \textsc{If you are unfamiliar with exporting data from Excel}}\\
      \begin{enumerate}
        \item Click the Microsoft Office Button in the top left corner of Excel.
        (Or go to the File menu if you have an older version)
        \item Click Save As...
        \item In the ``Save as type" drop down box, select CSV (comma delimited). 
      \end{enumerate}
    \end{minipage}
  }
\end{center}

Note that regional data and geographic data are not mutually exclusive. You can
have both in one file, just make sure that they are on the same sheet and that
the geographic data is always placed after all genetic and demographic data.

We have a short example of genalex formatted data with no geographic or regional
formatting. We will first see where the data is using the command
\texttt{system.file()}
<<system_file_genalex, eval=FALSE>>=
system.file("files/rootrot.csv", package="poppr")
@
<<system_file_echo, echo=FALSE>>=
paste("/path/to/R/library/poppr/files/rootrot.csv")
@
Now import the data into \poppr{} like so:
<<read.genalex_ex>>=
rootrot <- read.genalex(system.file("files/rootrot.csv", package="poppr"))
@
Executing rootrot shows that this file is now in genclone format and can be used
with any function in \poppr{} and \adegenet{}
<<read.genalex_ex2>>=
rootrot
@


\subsubsection{Other ways of importing data}
\label{intro:import:other}

\tab\tab \Adegenet{} already supports the import of FSTAT, Structure, Genpop,
and Genetix formatted files, so if you have data in those formats, you can
import them using the function \texttt{import2genind}. For sequence data, check
if you can use \texttt{read.dna} from the \textit{ape} package to import your
data. If you can, then you can use the \adegenet{} function
\texttt{DNAbin2genind}. If you don't have any of these formats handy, you can
still import your data using R's \texttt{read.table} along with
\texttt{df2genind} from \adegenet{}. For more information, see \adegenet{}'s
``Getting Started" vignette.

\subsubsection{Function: genind2genalex}
\label{intro:import:genind2genalex}

\tab\tab Of course, being able to export data is just as useful as being able to
import it, so we have this handy little function that will write a GenAlEx
formatted file to wherever you desire.\\ 
\textbf{WARNING: This will overwrite any file that exists with the same name.}

\tline{}
\begin{quote}
Default Command:
<<genind2genalex_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "genind2genalex"
print_command(funk)
@
% \texttt{genind2genalex(pop, filename = "genalex.csv", quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{filename -} This is where you specify the path to the new file
  you wish to create. If you specify only a filename with no path, it will place
  the file in your current working directory.
  \item \texttt{quiet -} If this is set to \texttt{FALSE}, a status message will
  be printed to the console as the extraction progresses.
  \item \texttt{geo -} Set to \texttt{TRUE}, if you have a data frame or matrix
  in the  \texttt{@other} slot of your genind object that contains geographic
  coordinates for all individuals or all populations. Setting this to
  \texttt{TRUE} means the resulting file will have two extra columns at the end
  of your file with geographic coordinates.
  \item \texttt{geodf -} The name of the data frame or matrix containing the
  geographic coordinates.
  \item \texttt{sep -} A separator to separate columns in the resulting file.
\end{itemize}
\bline{}

First, a simple example for the rootrot data we demonstrated in section 1.4.2:
<<genind2genalex, eval=FALSE>>=
genind2genalex(rootrot, "~/Desktop/rootrot.csv")
@
<<genind2genalex_cat, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/rootrot.csv ... Done.\n")
@

Here's an example of exporting the nancycats data set into GenAlEx format
with geographic information. If we look at the nancycats geographic information,
we can see it's coordinates for each population, but not each individual:
<<nancyxy>>=
data(nancycats)
nancycats@other$xy
@

To export it:
<<genind2genalex_nancy, eval=FALSE>>=
genind2genalex(nancycats, "~/Desktop/nancycats_pop_xy.csv", geo = TRUE)
@
<<genind2genalex_cat2, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/nancycats_pop_xy.csv ... Done.\n")
@
If we wanted to assign a geographic coordinate to each individual, we can use
this trick knowing that there are 17 populations in the data set:
<<nancy_grow_xy>>=
nan2 <- nancycats
nan2@other$xy <- nan2@other$xy[rep(1:17, table(pop(nan2))), ]
head(nan2@other$xy)
@
Now we can export it to a different file.
<<genind2genalex_nancy_grow, eval=FALSE>>=
genind2genalex(nan2, "~/Desktop/nancycats_inds_xy.csv", geo = TRUE)
@
<<genind2genalex_cat3, echo=FALSE>>=
cat("Extracting the table ... Writing the table to ~/Desktop/nancycats_inds_xy.csv ... Done.\n")
@
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Getting to know \adegenet{}'s genind object}
\label{intro:genind}

\tab\tab Since \poppr{} was built around \adegenet{}'s framework, it is
important to know how \adegenet{} stores data in the genind object, as that is
the object used by \poppr{}. To create a genind object, \adegenet{} takes a data
frame of genotypes (rows) across multiple loci (columns) and converts them into
a matrix of individual allelic frequencies at each locus \cite{Jombart:2008}.

For example, Let's say we had data with 3 diploid individuals each with 3 loci
that had 3, 4, and 5 allelic states respectively:

% latex table generated in R 3.1.0 by xtable 1.7-3 package
% Sat Apr 19 19:03:55 2014
\begin{table}[ht]
\centering
\begin{tabular}{rlll}
  \hline
 & locus1 & locus2 & locus3 \\ 
  \hline
1 & 101/101 & 201/201 & 301/302 \\ 
  2 & 102/103 & 202/203 & 301/303 \\ 
  3 & 102/102 & 203/204 & 304/305 \\ 
   \hline
\end{tabular}
\label{example_table}
\end{table}
\noindent
The resulting \texttt{genind} object would contain a matrix that has 3 rows and
12 columns. Below is a schematic of what that would look like. Each column
represents a separate allele, each row represents an individual and each color
represents a different locus. 

<<ex_data_picture, echo = FALSE>>=
library(adegenet)
df <- data.frame(list(locus1=c("101/101", "102/103", "102/102"), 
                      locus2=c("201/201", "202/203", "203/204"), 
                      locus3=c("301/302", "301/303", "304/305")))
dat <- df2genind(df, sep="/")$tab
tdat <- dat
tdat[] <- 1
barplot(tdat, axes = FALSE)
barplot(rep(3, 12), col = rep(rainbow(3, alpha = 0.5), 3:5), axes = FALSE, add = TRUE)
axis(2, at = 1:3 - 0.5, labels = 1:3, tick = FALSE)
axis(3, at = c(2, 6.125, 11.5), labels = names(df), tick = FALSE)
@
\noindent
When we look at the data derived from table \ref{example_table}, we see that we
have a matrix of individual allele frequencies at each locus. 
<<ex_genind, echo=FALSE>>=
dat
@
\noindent
At each locus, the allele frequencies for each individual sum to one.
Homozygotes are denoted as having an allele frequency of 1 at a particular
allele while heterozygotes have their allele frequencies represented as $1/p$
wher $p$ = ploidy. Along with this matrix, are elements that define the names of
the individuals, loci, alleles, and populations. If you wish to know more, see
the \adegenet{} ``Getting Started'' manual.

\subsubsection{The other slot}
\label{intro:genind:other}

The other slot is a place in the genind object that can be used to store useful
information about the data. We saw earlier that it could store demographic
information, now let's explore a different example. Bruvo's 
distance is based off of a stepwise mutation model for microsatellites. This 
requires us to know the length of the repeat of each locus. We could store the
repeat lengths in a separate variable in our R environment, but we are at risk
of losing that. One wa to prevent it from being lost would be to place it in the
``other'' slot. For the purpose of this example, we will use the ``nancycats''
data set from the \adegenet{} package and assume that it has dinucleotide repeats
at all of its loci.

<<other_replen>>=
data(nancycats) # Load the data
other(nancycats) # geographical coordinates
repeats <- rep(2, nLoc(nancycats)) #nLoc = number of loci
repeats
other(nancycats)$repeat_lengths <- repeats
other(nancycats) # two items named xy and repeat_lengths
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{The genclone object \{send in the clones\}}
\label{intro:genclone}

The \texttt{genclone} class was defined in order to make working with
hierarchies more intuitive. It is built off of the \texttt{genind} object and
has dedicated slots for the population hierarchy and defined multilocus
genotypes. The name genclone refers to the fact that it has the ability to
handle genotypes of clonal organisms (but it is also used for sexual
populations).

The main difference between the genclone and genind objects is how they handle
populations: With the \texttt{genind} object, the user must find the vector
defining the population and set it using that vector. The \texttt{genclone}
object already defines a data frame with different population factors or
hierarchical levels in the object. The user simply supplies a formula defining
the desired hierarchy with which to set the population. This formula driven
method is also used for clone correction, combining hierarchical levels and
conducting AMOVA. These will all be explained in later chapters. For examples
and details, type \texttt{help("genclone")} in your R console.

The function \texttt{as.genclone} allows the user to convert a \texttt{genind}
object to a \texttt{genclone} object. The following example will demonstrate
that the \texttt{genclone} object is an extention of the \texttt{genind} object
as well as the advantages of having populations pre-defined in your data set.

\subsubsection{Function: as.genclone}
\label{intro:genclone:as.genclone}

\tline{}
\begin{quote}
Default Command:
<<as.genclone_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "as.genclone"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \textbf{x -} a \texttt{genind} object to be converted.
  \item \textbf{hierarchy -} an optional data frame where each column represents
  a hierarchical level of the population hierarchy in the data set.
\end{itemize}
\bline{}

Let's show an example of a \texttt{genclone} object. First, we will take an
existing \texttt{genind} object and convert it using the function
\texttt{as.genclone} (We can also use the function
\cmdlink{intro:import:read.genalex}{read.genalex} to import as \texttt{genclone}
or \texttt{genind} objects). We will use the \texttt{Aeut} data set because it
is a clonal data set that has a simple population hierarchy
\cite{Grunwald:2006}. The data set is here:
\url{http://dx.doi.org/10.6084/m9.figshare.877104} and it is AFLP data of the
root rot pathogen \textit{Aphanomyces euteiches} collected from two different
fields in NW Oregon and W Washington, USA. These fields were divided up into
subplots from which samples were collected. The fields represent the population
and the subplots represent the subpopulation. Let's take a look at what the
\texttt{genind} object looks like:

<<show_genind>>=
library(poppr)
data(Aeut)
Aeut
@

This gives us a lot of information about the object, and is useful once you
become more comfortable with programming. Once we convert it to a
\texttt{genclone} object, the multilocus genotypes will be defined and the
population hierarchy (if a data frame is defined in the
\texttt{@other} slot called ``population\_hierarchy") will be set.

<<as_genclone>>=
agc <- as.genclone(Aeut)
agc

# We can also manually set the hierarchy.
as.genclone(Aeut, hierarchy = other(Aeut)$population_hierarchy[-1])
@

We can see here that it shows less information, but it gives us a very simple
overview of our data. Don't be fooled, however, because it contains the same
information as a \texttt{genind} object and the advantage of the
\texttt{genclone} object is that setting the population from the hierarchy
becomes \textbf{much} easier. 

<<genclone_compare>>=
c(is.genind(Aeut), is.genclone(Aeut), is.genind(agc), is.genclone(agc))

# Adegenet functions work the same, too
c(nInd(Aeut), nInd(agc))
@

<<setpop>>=
# We'll look at the population names
Aeut$pop.names

# genind way:
# Extract the combined hierarchical levels.
pophier <- other(Aeut)$population_hierarchy$Pop_Subpop
pop(Aeut) <- pophier
Aeut$pop.names

# genclone way:
agc
setpop(agc) <- ~Pop/Subpop
agc

# Notice that you only see the first and last three population names.
# Use the print function to display all population names.

print(agc)
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Accessing the population hierarchy}
\label{intro:genclone:access}

The hierarchy slot in the genclone object allows us to access and manipulate
different levels of a population hierarchy without the complication of creating
new data sets. We implemented the use of hierarchical nested formulae:

<<formuladef, eval = FALSE>>=
hier = ~Population/Subpopulation/Year
@
\noindent
\jala{} \textbf{NOTE:} The $\sim$ symbol is absolutely required for formulas, even if
you only are specifying one level.\\
The \texttt{"/"} symbolizes a hierarchical nesting. The above formula represents
years nested within subpopulations, nested within populations. This allows the
user to easily restructure the population hierarchy. Manipulation of the
hierarchy is necessary for \seclink{data.manip:cc}{clone correction} and AMOVA
analysis. See the section \seclink{data.manip:hier}{Can you take me
hier(archy)} for more details on manipulation of hierarchies.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{About polyploid data}
\label{intro:import:polyploid}

\begin{center}
  \fcolorbox{light-gray}{salmon}{
    \begin{minipage}[t]{0.8\textwidth}
      {\begin{center} \jala{}\jala{} \textbf{WARNING}\revjala{}\revjala{}\end{center}}
      Treat polyploid data with care. Please read this section carefully and
      consult the help pages for all functions mentioned here.
    \end{minipage}
  }
\end{center}

With diploid or haploid data, genotypes are unambiguous. It is often
clear when it is homozygous or heterozygous. With polyploid data, genotypes can
be ambiguous. For example, a tetraploid individual with the apparent genotype of
\textbf{A/B} could actually have one of three genotypes: \textbf{A/A/A/B},
\textbf{A/A/B/B}, or \textbf{A/B/B/B}. This ambiguity prevents a researcher from
accurately calling all alleles present. In \adegenet{}, it was previously
difficult to import polyploid data because of this ambiguity as data was
required to be unambiguous or missing.

A solution to this problem is to code missing alleles as ``0''. An example of
this is found within the \texttt{Pinf} data set in \poppr{}
\cite{goss2014irish}. We look at the last six samples over two loci, Pi63 (3
alleles, triploid) and Pi70 (3 alleles, diploid) to examine how the data is
represented.

<<pinf_show>>=
data(Pinf)
Pinf
tail(truenames(Pinf[loc = c("L09", "L10")])$tab)
@
\noindent
Each column in this data represents a different allele at a particular locus.
\texttt{Pi63.148} is the allele \texttt{148} at locus \texttt{Pi63}. Each row is
an individual. The numbers represent the fraction of a given allele that makes
up the individual genotype at a particular locus. What we can see here is that
the number of columns is 8 when we expect only 6 (2 loci $\times$ 3 alleles).
The first allele at each locus is \texttt{000}. Let's take a look at the data in
a human-readable format.
<<pinf_show_df>>=
Pinfdf <- genind2df(Pinf, sep = "/")
tail(Pinfdf[10:11])
@
\noindent
It's more clear now that we have a data set of tetraploid individuals where some
genotypes appear diploid (\texttt{\Sexpr{Pinfdf[85, 10]}}) and some appear
triploid (\texttt{\Sexpr{Pinfdf[86, 10]}}). The tetraploid genotype is padded
with zeroes to make up the difference in ploidy.

This method allows \textsc{Bruvo's Distance} \cite{Bruvo:2004} and the
\textsc{Index of Association} \cite{Brown:1980,Smith:1993,Agapow:2001} to work
with polyploids as they specifically recognize the zeroes as being missing data.
A side effect, unfortunately is that the extra zeroes appear as extra alleles.
As this affects all frequency-based statistics (except for the ones noted
above), the user should reformat their data set with the function
\texttt{recode\_polyploids}, which will remove the zeroes and recode the allele
frequencies to the observed frequencies.

<<pinf_recode>>=
Pinf_rc <- recode_polyploids(Pinf, newploidy = 2)
tail(truenames(Pinf_rc[loc = c("L09", "L10")])$tab)
@
\noindent
Notice that the triploid locus now has frequencies that are multiples of
$\frac{1}{3}$ and the diploid locus has multiples of $\frac{1}{2}$. Below, we
show the observed genotypes:
<<pinf_recode_df>>=
Pinfrcdf <- genind2df(Pinf_rc, sep = "/")
tail(Pinfrcdf[10:11])
@

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Data Manipulation}
\label{data.manip}

\tab\tab One tedious aspect of population genetic analysis is the need for
repeated data manipulation. \Adegenet{} has some functions for manipulating data
that are limited to replacing missing data and dividing data into populations,
loci, or by sample size \cite{Jombart:2008}. \Poppr{} includes novel functions
for clone-censoring your data sets or sub-setting a genind object by specific
populations.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Population hierarchy construction \{Can you take me hier(archy)?\}}
\label{data.manip:hier}

\tab\tab in \poppr{}, the \seclink{intro:genclone}{genclone} object contains a
slot called \texttt{hierarchy}. This slot contains a data frame used to define
hierarchical levels of population factors describing your data. The preferred
way of defining these hierarchical levels is to concatenate them using `\_' and
use them to define a single population in your data before you import it into
\poppr{}. Examples of this format can be found in figures \ref{microbov
unmodified}, \ref{microbov modified}, and at
\url{http://dx.doi.org/10.6084/m9.figshare.877104}.

In this section, we will show you how to \seclink{data.manip:hier:define}{define}
hierarchical levels, \seclink{data.manip:hier:view}{view} those levels to ensure
that they are correctly defined, \seclink{data.manip:hier:manip}{manipulate} your
hierarchical levels by adding and renaming them, and use these levels
to \seclink{data.manip:hier:setpop}{set the population} in
your \seclink{intro:genclone}{genclone} object using the following methods:

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sat Mar 22 20:24:23 2014
\begin{table}[ht]
\centering
\begin{tabular}{llll}
  \hline
 Method & Function & Input & Result\\ 
  \hline
 split & \cmdlink{data.manip:hier:define:split}{splithierarchy} & formula & defined hierarchical levels\\
 set & \cmdlink{data.manip:hier:define:set}{sethierarchy} & data frame & new hierarchical levels\\ 
 get & \cmdlink{data.manip:hier:view}{gethierarchy} & formula & data frame\\ 
 name & \cmdlink{data.manip:hier:manip:name}{namehierarchy} & formula & new hierarchical level names\\ 
 add & \cmdlink{data.manip:hier:manip:add}{addhierarchy} & vector or data frame & new hierarchical level\\
   \hline
\end{tabular}
\end{table}


\begin{center}
  \fcolorbox{light-gray}{light-gray}{
    \begin{minipage}[t]{0.8\textwidth}
      \jala{} {\large \textsc{A note about formulas}} \revjala{}\\
      The formulas used by genclone objects always start with a $\sim$ and 
      are hierarchical levels are always separated by a $/$. Some examples
      are: 

      $\sim$Country/City/District 

      $\sim$Field/Year

      Refer to \seclink{intro:genclone:access}{Accessing hierarchies} for more
      details on how to access hierarchies.
    \end{minipage}
    }
\end{center}
\noindent
In the next section, we'll explore two ways of defining hierarchical levels.

\subsubsection{Defining hierarchies}
\label{data.manip:hier:define}

\tab\tab As explained above, the best way to define hierarchical levels is to
concatenate them using `\_' and set that as your population factor. We will use
the example data set from \url{http://dx.doi.org/10.6084/m9.figshare.877104}. It
is an AFLP data set of the root rot pathogen \textit{Aphanomyces euteiches} from
two fields and multiple soil cores per field. First, we will follow the link and
copy the download link from figshare.
<<aphan_dummy_figshare, eval = FALSE>>=
aphan <- read.genalex("http://files.figshare.com/1314228/rootrot.csv")
aphan
@
<<aphan_figshare, echo = FALSE>>=
aphan <- namehierarchy(sethierarchy(agc, gethierarchy(agc, ~Pop_Subpop)), ~Pop)
aphan
@
\noindent
The supplemental information in the data defined two hierarchical leves, yet we
only see one here labeled `Pop'. This is how populations are automatically
defined when importing to a \seclink{intro:genclone}{genclone} object since it
does not know how many hierarchical levels you have defined. To define these
levels present in the data set, we will need to split them up using the function
\texttt{splithierarchy}:
\label{data.manip:hier:define:split}
<<aphan_split>>=
splithierarchy(aphan) <- ~field/sample
aphan
@
\noindent
Now we have sucessfully defined our hierarchies. If you have imported your data
in this manner, you may skip to the \seclink{data.manip:hier:setpop}{setting
population hierarchies}, \seclink{data.manip:hier:view}{viewing hierarchies}, or
\seclink{data.manip:hier:manip}{manipulating hierarchical levels.}

\bline{}

If you have imported your data with a single population and want to add
hierarchical levels separately, you can use the function \texttt{sethierarchy}
with a data frame containing your hierarchical levels. For this example, we will
use the data set \texttt{H3N2}, which contains SNP data from the H3N2 virus.
This data set holds a data frame in the the \seclink{intro:genind:other}{other
slot} that contains many variables including country, year, and month of
collection. We will first load the data and write that data frame to a file on
the desktop. 
\label{data:virus}
<<H3N2_data_show, eval = FALSE>>=
data(H3N2)
write.table(other(H3N2)$x, file = "~/Desktop/virus_info.csv", row.names = FALSE)
@
<<H3N2_data_noshow, echo = FALSE>>=
data(H3N2)
virus_info <- as.data.frame(other(H3N2)$x) # extracting the data frame
@
\noindent
Now we have our data and we have a separate table in a file on our desktop
defining our hierarchical levels. Let's import those levels into R with
\texttt{read.table} and see what they are:

<<H3N2_read_table, eval = FALSE>>=
virus_info <- read.table("~/Desktop/virus_info.csv", header = TRUE)
names(virus_info)
@
<<H3N2_read_table_eval, echo = FALSE>>=
names(virus_info)
@

From here we will convert our genind object to a genclone object and use
\texttt{sethierarchy} to define the hierarchical levels with the table we just
imported.

\label{data.manip:hier:define:set}
<<H3N2_sethierarchy>>=
virus <- as.genclone(H3N2) # Converting it to a genclone object.
sethierarchy(virus) <- virus_info # Setting the hierarchy
virus
@
\noindent
In this data, levels such as host and segment are unimportant levels because
they are all the same. Let's say that we are only interested in year and country.
To make things easier to view, we will set the hierarchical levels to these two
columns:
<<H3N2_sethierarchy_again>>=
sethierarchy(virus) <- virus_info[c("country", "year")]
virus
@

Notice that there are no populations defined. Now that we have the hierarchical
levels in place, we can use it to define the population hierarchy. We will use
the function \texttt{setpop} to define the population as year with respect to
country:
<<H3N2_set_country>>=
setpop(virus) <- ~year/country
virus
@

\subsubsection{Viewing hierarchies}
\label{data.manip:hier:view}

If you wanted to view your hierarchies to make sure that you made no spelling
errors in your population definitions, you can extract the data frame from your
genclone object by using the function \texttt{gethierarchy}:

\begin{quote}
Default Command:
<<gethierarchy_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "gethierarchy"
print_command(funk)
@
\end{quote}
\noindent
Where \textbf{x} is the genclone object, \textbf{formula} defines the hierarchical
levels, and \textbf{combine} indicates whether or not you want the lower levels 
of the hierarchy combined with the higher levels. For example, in the root rot
data above, the hierarchical levels are explicitly hierarchical and should be
combined. Note, if you don't supply a formula argument, the data frame as it
exists will be returned.

<<aphan_hier_get>>=
head(gethierarchy(aphan))
head(gethierarchy(aphan, ~field/sample))
@

If the hierarchical levels are not nested, or you simply want to use this
hierarchy for another data set, you might want to set the \textbf{combine} flag
to \texttt{FALSE}. Let's use the virus data as an example:

<<virus_get>>=
head(gethierarchy(virus, ~year/country))
head(gethierarchy(virus, ~year/country, combine = FALSE))
@

It will return only the levels you ask it to return:

<<virus_onepop>>=
head(gethierarchy(virus, ~country))
@

\subsubsection{Manipulating hierarchical levels}
\label{data.manip:hier:manip}

Once we have our hierarchies set in place, we want to be able to rename and add
to them. For this example, we will revisit the \seclink{data:virus}{virus
example} from above. We have set the population hierarchy to be based on year and
country, but we've noticed that we left out month. And let's say that we
accidentally overwrote the data object like this:
<<virus_stupid>>=
virus_info <- virus_info[["month"]]
names(virus_info)
@
\noindent
If we were saving our script the whole time, we could just go back and retrieve
the data frame, but that defeats the purpose of this section where we imagine
that we've recieved new information and wanted to add it to our hierarchy. If we
want to add this to our hierarchy, we just use the function
\texttt{addhierarchy} defined as thus:
\begin{quote}
Default Command:
<<addhierarchy_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "addhierarchy"
print_command(funk)
@
\end{quote}
\noindent
We can use this function to add on a new column to the data frame.  
\label{data.manip:hier:manip:add}
<<virus_add_arg>>=
addhierarchy(virus) <- virus_info 
virus
@
\noindent
Notice that the new hierarchical level is simply labeled as \texttt{NEW}. We
will customize the name of the hierarchical levels with the function
\texttt{namehierarchy}. 
\label{data.manip:hier:manip:name}

<<virus_name>>=
namehierarchy(virus) <- ~country/year/month
virus
@
\noindent
Of course, perhaps a better way still would be to use a data frame:
<<virus_add_df, eval = FALSE>>=
addhierarchy(virus) <- data.frame(month = virus_info)
@

\subsubsection{Defining populations with hierarchies}
\label{data.manip:hier:setpop}

Now that we have defined the hierarchical levels in the data set, setting the
population hierarchy allows us to group our data according to the hierarchical
level of your choice. This is a necessary step. For this example, we will use a
data set of \textit{Phytophthora infestans} collected from North America and
South America.

<<Pinf_setpop>>=
data(Pinf)
Pinf
@
\noindent
Above we have two hierarchies for Continent and Country, but the
populations only show Continent level populations. If we wanted to investigate
each country separately, we would need to reset the population to be represented
by Country. This can be done with the function \texttt{setpop}. This function
utilizes the defined population hierarchies to set the population. We'll use our
data set above to illustrate this:

<<Pinf_setpop2>>=
setpop(Pinf) <- ~Country
Pinf # Now set by country
@
\noindent
The beauty about it is the fact that it will also combine all the hierarchical
levels you want to use. Let's see when we ask it to set the population of
Country with respect to Continent.

<<Pinf_setpop_combine>>=
setpop(Pinf) <- ~Continent/Country
Pinf
@
\noindent
Nice!
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Replace or remove missing data \{Inside the golden days of missing data\}}
\label{data.manip:missing}

\tab\tab A data set without missing data is always ideal, but often not
achievable. Many functions in \adegenet{} cannot handle missing data and thus
the function \texttt{na.replace} exists \cite{Jombart:2008}. It will replace
missing data with with either ``0" representing a mysterious extra allele in the
data set resulting in more diversity or the mean of allelic frequencies at the
locus. There is no set method, however, for simply removing missing data from
analyses, which is why the \poppr{} function \texttt{missingno} (see below)
exists. If the name makes you uneasy it's because it should. Missing data can
mean different things based on your data type. For microsatellites, missing data
might represent any source of error that could cause a PCR product to not
amplify in gel electrophoresis, which may or may not be biologically relevant.
For a DNA alignment, missing data could mean something as simple as an insertion
or deletion, which is biologically relevant. The choice to exclude or estimate
data has very different implications for the type of data you have.

\begin{center}
  \fcolorbox{light-gray}{salmon}{
    \begin{minipage}[t]{0.8\textwidth}
      {\begin{center} \jala{}\jala{} \textbf{WARNING}\revjala{}\revjala{}\end{center}}
      Treatment of Missing data is a non-trivial task. You should understand the nature of missing data in your data set before treatment.
    \end{minipage}
  }
\end{center}

\tline{}
\subsubsection{Function: missingno}
\label{data.manip:missing:missingno}

\tab\tab \texttt{missingno} is a function that serves partially as a wrapper for
\adegenet{}'s \texttt{na.replace} to replace missing data and as a way to
exclude specific areas that contain systematic missing data.
\begin{quote}
Default Command:
<<missingo_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "missingno"
print_command(funk)
@
% \texttt{missingno(pop, type = "loci", cutoff = 0.05, quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{type -} This could be one of four options:
    \begin{description}
      \item[ ``mean"] This replaces missing data with the mean allele
      frequencies in the entire data set.
      \item[ ``zero" or ``0"] This replaces missing data with zero, signifying a
      new allele.
      \item[ ``loci"] This is to be used for a data set that has systematic
      problems with certain loci that contain null alleles or simply failed to
      amplify. This will remove loci with a defined threshold of missing data
      from the data set.
      \item[ ``geno"] This is to be used for genotypes (individuals) in your
      data set where many null alleles are present. Individuals with a defined
      threshold missing data will be removed.
    \end{description}
    \item \texttt{cutoff -} This is a numeric value from 0 to 1 indicating the
    percent allowable missing data for either loci or genotypes. If you have,
    for example, two loci containing missing 5\% and 10\% missing data,
    respectively and you set \texttt{cutoff = 0.05}, \texttt{missingno} will
    remove the second locus. Percent missing data for genotypes is considered
    the percent missing loci over number of total loci.
    \item \texttt{quiet -} When this is set to \texttt{FALSE}, the number of
    missing values replaced will be printed to screen if the method is ``zero"
    or ``mean". It will print the number of loci or individuals removed if the
    method is ``loci" or ``geno".
\end{itemize}
\bline{}

Let's take a look at what this does by focusing in on areas with missing data.
We'll use the data set \texttt{nancycats} as an example. Using the \poppr{}
function \texttt{info\_table}, we can assess missing data within populations.
<<initializing_poppr, out.width=".8\\linewidth", fig.height = 6, fig.width = 10>>=
library(poppr)
data(nancycats)
info_table(nancycats, plot = TRUE)
@
\label{function:info-table}

We can see that locus \Sexpr{locNames(nancycats)[1]} has a lot of missing data.
To demonstrate the function \cmdlink{data.manip:missing:missingno}{missingno}, we
will zoom into the first five individuals at the first locus.
<<nancy_indiv>>=
nancycats$tab[1:5, 8:13]
@

When looking at this data set, recall how a \texttt{genind} object is formatted.
You have a matrix of 0's, 1's and 0.5's. For diploids, if you see 0.5, that
means it is heterozygous at that allele, and a 1 means it's homozygous. Here we
see three heterozygotes and two individuals with missing data (indicated by NA).
Let's first replace it by zero and mean, respectively.
<<missingno_replace>>=
nanzero <- missingno(nancycats, type = "zero")
nanmean <- missingno(nancycats, type = "mean")
nanzero$tab[1:5, 8:13]
nanmean$tab[1:5, 8:13]
@
You notice how the values of NA changed, yet the basic structure stayed the
same. These are the replacement options from \adegenet{}. Let's look at the same
example with the exclusion options (set to the default cutoff of 5\%).
<<missingno_exclude>>=
nanloci <-  missingno(nancycats, "loci")
nangeno <-  missingno(nancycats, "geno")
nanloci$tab[1:5, 8:13]
@

Notice how we now see columns named ``L2.01" and ``L2.02". This is showing us
another locus because we have removed the first. Recall from the summary table
that the first locus had 16 alleles, and the second had 11. Now that we've
removed loci containing missing data, all others have shifted over.\\ Let's look
at the loci names and number of individuals.
<<missingno_loci>>=
nInd(nanloci) # Individuals
locNames(nanloci) # Names of the loci
@
You can see that the number of individuals stayed the same but the loci ``fca8",
``fca45", and ``fca96" were removed.\\
Let's look at what happened when we removed individuals.
<<missingno_geno>>=
nangeno$tab[1:5, 8:13]
nInd(nangeno) # Individuals
locNames(nangeno) # Names of the loci
@

We can see here that the number of individuals decreased, yet we have the same
number of loci. Notice how the frequency matrix changes in both scenarios? In
the scenario with ``loci", we removed several columns of the data set, and so
with our sub-setting, we see alleles from the second locus. In the scenario with
``geno", we removed several rows of the data set so we see other individuals in
our sub-setting.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Extract populations \{Divide (populations) and conquer (your analysis)\}}
\label{data.manip:divide}

\tab\tab \Adegenet{} provides methods for subsetting data by individual or
splitting all of the data into a list of populations. If you only want one or
two populations, these methods become tedious. The \poppr{} function
\texttt{popsub} makes this easier:

\subsubsection{Function: popsub}
\label{data.manip:divide:popsub}

\tab\tab The command \texttt{popsub} is powerful in that it allows you to choose
exactly what populations you choose to include or exclude from your analyses. As
with many R functions, you can also use this within a function to avoid
creating a new variable to keep track of.

\tline{}
\begin{quote}
Default Command:
<<popsub_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "popsub"
print_command(funk)
@

\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sublist -} vector of populations or integers representing
  the populations in your data set you wish to \textbf{retain}. For example:
  \texttt{sublist = c("pop\_z", "pop\_y")} or \texttt{sublist = 1:2}.
  \item \texttt{blacklist -} vector of populations or integers representing
  the populations in your data set you wish to \textbf{exclude}. This can take the same
  type of arguments as sublist, and can be used in conjunction with sublist for
  when you want a range of populations, but know that there is one in there that
  you do not want to analyze. For example: \texttt{sublist = 1:15, blacklist =
  "pop\_x"}. One very useful thing about the blacklist is that it allows the
  user to be extremely paranoid about the data. You can set the blacklist to
  contain populations that are not even in your data set and it will still work!
  \item \texttt{mat -} (see section \seclink{mlg}{Multilocus Genotype
  Analysis} for more information) A matrix produced from
  the \cmdlink{mlg:table:mlg.table}{mlg.table} function. This overrides the
  \textit{pop} argument and subsets this table instead.
\end{itemize}
\bline{}

To demonstrate this tool, let's revisit the \seclink{data:virus}{virus} data set
that we saw in \seclink{data.manip:hier:define}{Defining hierarchies.} Let's say
we wanted to analyze only the data in North America. To make sure we are all on
the same page, we will reset the population factor to ``country".
<<popsub_sublist>>=
setpop(virus) <- ~country
virus$pop.names # Only two countries from North America.
vna <- popsub(virus, sublist=c("USA", "Canada"))
vna$pop.names
@
\noindent
If we want to see the population size, we can use the \adegenet{} function
\texttt{nInd()}:
<<popsub_sizes>>=
c(NorthAmerica = nInd(vna), Total = nInd(virus))
@
\noindent
You can see that the population factors are correct and that the size of the
data set is considerably smaller. Let's see the data set without the North
American countries.
<<popsub_blacklist>>=
vnaminus <- popsub(virus, blacklist=c("USA", "Canada"))
vnaminus$pop.names
@
\noindent
Let's make sure that the number of individuals in both data sets is equal to
the number of individuals in our original data set:
<<length_test>>=
(nInd(vnaminus) + nInd(vna)) == nInd(virus)
@

Now we have data sets with and without North America. Let's try something a bit
more challenging. Let's say that we want the first 10 populations in
alphabetical order, but we know that we still don't want any countries in North
America. We can easily do this by using the \textit{base} function
\texttt{sort}.
<<popsub_combine>>=
vsort <- sort(virus$pop.names)[1:10]
vsort
valph <- popsub(virus, sublist=vsort, blacklist=c("USA", "Canada"))
valph$pop.names
@
\noindent
And that, is how you subset your data with poppr!
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Clone-censor data sets \{Attack of the clone correction\}}
\label{data.manip:cc}

\tab\tab Clone correction refers to the ability of keeping one observation of
each MLG in a given population (or sub-population). Clone correcting can be
hazardous if its done by hand (even on small data sets) and it requires a
defined population hierarchy to get relevant results. \Poppr{} has a clone
correcting function that that will correct down to the lowest level of any
defined population hierarchy. Note that clone correction in \poppr{} is
sensitive to missing data, as it treats all missing data as a single extra
allele.

This function will create new data sets, but it is also utilized by the functions
 \texttt{poppr} and \texttt{poppr.amova} natively.

\subsubsection{Function: clonecorrect}
\label{data.manip:cc:clonecorrect}

\tab\tab This function will return a clone corrected data set corrected for the
lowest population level. Population levels are specified with the \texttt{hier}
flag. You can choose to combine the population hierarchy to analyze at the
lowest population level by choosing \texttt{combine = TRUE}.

\tline{}
\begin{quote}
Default Command:
<<clonecorrect_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "clonecorrect"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genclone} object with a defined hierarchy or a
   \texttt{genind} object that has a population hierarchy data frame in the
   \texttt{@other} slot. Note, the \texttt{genind} object does not necessarily
   require a population factor to begin with.
  \item \texttt{hier -} A hierarchical formula (eg. \texttt{$\sim$Pop/Subpop}),
  representing the hierarchical levels in your data.
  \item \texttt{dfname -} \textbf{Only for use in genind objects, otherwise,
   deprecated} The name of a data frame you have in the \texttt{@other} slot
   with the population factors.
  \item \texttt{combine -} Do you want to combine the population hierarchy? If
   it's set to \texttt{FALSE} (default), you will be returned an object with the
   top most hierarchical level as a population factor unless the \textbf{keep}
   argument is defined. If set to \texttt{TRUE}, the hierarchy will be returned
   combined.
  \item \texttt{keep -} This flag is to be used if you set \texttt{combine =
   FALSE}. This will tell clone correct to return a specific combination of your
   hierarchy defined as integers. For example, imagine a hierarchy that needs to
   be clone corrected at three levels:
   \textit{Population} by \textit{Year} by \textit{Month}. If you wanted to only
   run an analysis on the \textit{Population} level, you would set \texttt{keep
   = 1} since \textit{Population} is the first level of the hierarchy. On the
   other hand, if you wanted to run analysis on \textit{Year} by \textit{Month},
   you would set
   \texttt{keep = 2:3} since those are the second and third levels of the
   hierarchy.
\end{itemize}
\bline{}

Let's look at ways to clone-correct our data. We'll look at our \textit{A.
euteichies} data that we loaded earlier in the
section \seclink{data.manip:hier}{Can you take me hier(archy)} since that data
set is known to include clonal populations \cite{Grunwald:2006}. Try playing
around with the data and see what different combinations of the \texttt{hier},
and \texttt{keep} flags produce. Below, I will give three examples of clone
corrections at the sample level with respect to field, at the field level, and
finally, at the level of the entire data set.

First, we will examine the original data set.
<<clonecorrect>>=
aphan # Original object
@
\noindent
Now we correct by sample with respect to field and keep the field as the population.
<<clonecorrect2>>=
clonecorrect(aphan,  hier = ~field/sample)
# Your turn: Use the same hierarchy and use combine = TRUE and then
# keep = 1:2. Is there any difference?
@
\noindent
Correcting by field. Notice how the number of MLG is much closer to our census.
<<clonecorrect3>>=
clonecorrect(aphan, hier = ~field)
@
\noindent
Correcting over whole data set. Our MLG is equal to our census.
<<clonecorrectx>>=
clonecorrect(aphan, hier = NA)
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Permutations and bootstrap resampling \{every day I'm shuffling (data sets)\}}
\label{data.manip:shuffle}

\tab\tab A common null hypothesis for populations with mixed reproductive modes
is panmixia, or to put it simply: lots of sex. \Poppr{} randomly shuffles data
sets in order to calculate P-values for the index of association ($I_A$ and
$\bar{r} _d$) \cite{Agapow:2001} using 4 different methods: 

% latex table generated in R 3.1.0 by xtable 1.7-3 package
% Fri May  2 23:17:17 2014
\begin{table}[ht]
\centering
\begin{tabular}{rll}
  \hline
method & strategy & units sampled \\ 
  \hline
1 & permutation & alleles \\ 
  2 & simulation & alleles \\ 
  3 & simulation & alleles \\ 
  4 & permutation & genotypes \\ 
   \hline
\end{tabular}
\end{table} 

These methods are detailed below. We will create a dummy data set to be shuffled
by each example below. Let's assume a single diploid locus with four alleles (1,
2, 3, 4) with the frequencies of 0.1, 0.2, 0.3, and 0.4, respectively:

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:52:35 2014
\begin{table}[h!]
\centering
\begin{tabular}{lc}
          \hline
            & A1/A2 \\ 
          \hline
          1 & 4/4 \\ 
          2 & 4/1 \\ 
          3 & 4/3 \\ 
          4 & 2/2 \\ 
          5 & 3/3 \\ 
           \hline
        \end{tabular}
        \caption{Original}
        \label{tab:original}
\end{table}
\noindent
The 4 methods are detailed below.

\tline{}
\subsubsection{Function: shufflepop}
\label{data.manip:shuffle:shufflepop}
\begin{quote}
Default Command:
<<shufflepop_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "shufflepop"
print_command(funk)
@
% \texttt{shufflepop(pop, method = 1)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{method -} a number indicating the method of sampling you wish to
  use. The following methods are available for use:
  \begin{enumerate}
    \item \textbf{Permute Alleles (default)} This is a sampling scheme that will \textbf{permute alleles within the locus.}
% <<shuffle_mat, echo=FALSE>>=
% exmat <- matrix(c(4,4,
%          4,1,
%          4,3,
%          2,2,
%          3,3), 5, byrow=TRUE)
% exmat
% @

The example above might become tables \ref{tab:permsinglebest} and \ref{tab:permtwobest}.
\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
            & A1/A2 \\ 
          \hline
          1 & 3/4 \\ 
          2 & 2/3 \\ 
          3 & 4/4 \\ 
          4 & 2/1 \\ 
          5 & 3/4 \\ 
           \hline
        \end{tabular}
        \caption{Permute 1}
        \label{tab:permsinglebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 2/4 \\ 
          3 & 3/4 \\ 
          4 & 4/3 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Permute 2}
        \label{tab:permtwobest}
    \end{minipage}
}}
\end{table}

As you can see, The heterozygosity has changed, yet the allelic frequencies
remain the same. Overall this would show you what would happen if
the sample you had underwent panmixis within this sample itself.
    \item \textbf{Parametric Bootstrap} The previous scheme reshuffled the
    observed sample, but the parametric bootstrap \textbf{draws samples from a
    multinomial distribution using the observed allele frequencies as weights.}
    Tables \ref{tab:param1} and \ref{tab:param2} are examples of what I mean.
% <<param_boot, echo=FALSE>>=
% set.seed(1001)
% cat("First Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% cat("Second Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/3 \\ 
          3 & 3/2 \\ 
          4 & 4/4 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Parametric 1}
        \label{tab:param1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 3/4 \\ 
          2 & 2/3 \\ 
          3 & 4/2 \\ 
          4 & 4/4 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Parametric 2}
        \label{tab:param2}
    \end{minipage}
}}
\end{table}

Notice how the heterozygosity has changed along with the allelic frequencies.
The frequencies for alleles 3 and 4 have switched in the first data set, and
we've lost allele 1 in the second data set purely by chance! This type of
sampling scheme attempts to show you what the true population would look like if
it were panmictic and your original sample gave you a basis for estimating
expected allele frequencies. Since estimates are made from the observed allele
frequencies, small samples will produce skewed results.
    \item \textbf{Non-Parametric Bootstrap} The third method is sampling with
    replacement, again \textbf{drawing from a multinomial distribution, but with no
    assumption about the allele frequencies} (tables \ref{tab:nonparam1} and \ref{tab:nonparam2}).
% <<boot, echo=FALSE>>=
% set.seed(1001)
% matrix(sample(1:4, 10, prob=rep(1, 4), replace=TRUE), 5, byrow=T)
% @

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:57:06 2014

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/3 \\ 
          3 & 3/1 \\ 
          4 & 2/2 \\ 
          5 & 3/1 \\ 
           \hline
        \end{tabular}
        \caption{Non-parametric 1}
        \label{tab:nonparam1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/1 \\ 
          3 & 2/3 \\ 
          4 & 2/1 \\ 
          5 & 4/3 \\ 
           \hline
        \end{tabular}
        \caption{Non-parametric 2}
        \label{tab:nonparam2}
    \end{minipage}
}}
\end{table}

Again, heterozygosity and allele frequencies are not maintained, but now all of
the alleles have a 1 in 4 chance of being chosen.
    \item \textbf{Multilocus permutation} This is called Multilocus permutation
    because it does the same thing as the permutation analysis in the program
    \textit{multilocus} by Paul Agapow and Austin Burt \cite{Agapow:2001}. This
    will shuffle the genotypes at each locus. Using our example above, tables
    \ref{tab:singlebest} and \ref{tab:twobest}
    are shuffled with method 4.
% <<multilocus_shuffle,echo=FALSE>>=
% set.seed(1001)
% exmat[sample(1:5), ]
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 3/3 \\ 
          2 & 4/1 \\ 
          3 & 2/2 \\ 
          4 & 4/4 \\ 
          5 & 4/3 \\ 
           \hline
        \end{tabular}
        \caption{ML 1}
        \label{tab:singlebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 4/4 \\ 
          2 & 2/2 \\ 
          3 & 3/3 \\ 
          4 & 4/3 \\ 
          5 & 4/1 \\ 
           \hline
        \end{tabular}
        \caption{ML 2}
        \label{tab:twobest}
    \end{minipage}
}}
\end{table}

Note that you have the same genotypes after shuffling, so at each locus, you
will maintain the same allelic frequencies and heterozygosity. So, in this
sample, you will only see a homozygote with allele 2. This also ensures that the
P-values associated with $I_A$ and $\bar{r} _d$ are exactly the same.
Unfortunately, if you are trying to simulate a sexual population, this does not
make much biological sense as it \textbf{assumes that alleles are not independently
assorting within individuals.}
  \end{enumerate}
\end{itemize}

\bline{}

These shuffling schemes have been implemented for the index of association, but
there may be other summary statistics you can use \texttt{shufflepop} for. All
you have to do is use the function \texttt{replicate}. Let's use
average Bruvo's distance with the first population of the
data set \texttt{nancycats} as an example:
<<shuffle_bd>>=
data(nancycats)
nan1 <- popsub(nancycats, 1)
reps <- rep(2, 9) # Assuming dinucleotide repeats.
observed <- mean(bruvo.dist(nan1, replen = reps))
observed
@
<<shuffle_bd_replicate_dummy, eval=FALSE>>=
set.seed(9999)
bd.test <- replicate(999, mean(bruvo.dist(shufflepop(nan1, method = 2), replen = reps)))
@
<<shuffle_bd_replicate, echo = FALSE>>=
bd.test <- c(0.383180217978395, 0.415172887731481, 0.395401716820988, 0.36112075617284, 
0.381246383101852, 0.391417100694444, 0.368165268132716, 0.44764419367284, 
0.39599006558642, 0.392292390046296, 0.416001157407407, 0.359629388503086, 
0.375589554398148, 0.405174575617284, 0.409643856095679, 0.391482204861111, 
0.382218123070988, 0.41436149691358, 0.383174189814815, 0.404762249228395, 
0.409695698302469, 0.351765046296296, 0.375487075617284, 0.394843508873457, 
0.403155140817901, 0.395619936342593, 0.35908203125, 0.396396363811728, 
0.387588011188272, 0.375771604938272, 0.374916811342593, 0.371144386574074, 
0.375567853009259, 0.372751494984568, 0.41537181712963, 0.390055941358025, 
0.372065489969136, 0.38319106867284, 0.418766878858025, 0.389811197916667, 
0.391309799382716, 0.380735194830247, 0.392493730709877, 0.407855902777778, 
0.373485725308642, 0.393967013888889, 0.419801311728395, 0.419554157021605, 
0.349768518518519, 0.368592062114198, 0.396170910493827, 0.38164665316358, 
0.397676745756173, 0.359424430941358, 0.390004099151235, 0.375790895061728, 
0.415828751929012, 0.396510898919753, 0.398491753472222, 0.399006558641975, 
0.378590374228395, 0.410376880787037, 0.373421826774691, 0.401580584490741, 
0.388343942901235, 0.389790702160494, 0.406230709876543, 0.410212914737654, 
0.411181037808642, 0.397419945987654, 0.409830729166667, 0.38501880787037, 
0.375995852623457, 0.374977092978395, 0.404217303240741, 0.381970968364198, 
0.427674093364198, 0.421094955632716, 0.392737268518519, 0.372973331404321, 
0.396556712962963, 0.41493537808642, 0.367643229166667, 0.417230902777778, 
0.37703872492284, 0.388992573302469, 0.390311535493827, 0.404422260802469, 
0.325649836033951, 0.382992139274691, 0.396333670910494, 0.385146604938272, 
0.40302734375, 0.369362461419753, 0.40317684220679, 0.400687210648148, 
0.402665653935185, 0.383434606481481, 0.398591820987654, 0.403266059027778, 
0.33031322337963, 0.381671971450617, 0.398115596064815, 0.401163435570988, 
0.416612413194444, 0.403988233024691, 0.421760464891975, 0.425095244984568, 
0.431723813657407, 0.401032021604938, 0.390247636959877, 0.431340422453704, 
0.390993923611111, 0.421104600694444, 0.339672550154321, 0.437996720679012, 
0.358885513117284, 0.368224344135802, 0.361101466049383, 0.384192949459877, 
0.410045331790123, 0.368414834104938, 0.340546633873457, 0.341089168595679, 
0.387595244984568, 0.371152826003086, 0.386452305169753, 0.438270399305556, 
0.414109519675926, 0.376890432098765, 0.367886766975309, 0.326484133873457, 
0.385950761959877, 0.429093123070988, 0.414934172453704, 0.395864679783951, 
0.385291280864198, 0.405513358410494, 0.373255449459877, 0.380583285108025, 
0.371088927469136, 0.367192322530864, 0.39708236882716, 0.337759211033951, 
0.412621768904321, 0.394872444058642, 0.381664737654321, 0.423829330632716, 
0.389819637345679, 0.420828510802469, 0.404482542438272, 0.414830488040123, 
0.383400848765432, 0.389350646219136, 0.38399040316358, 0.378415557484568, 
0.401076630015432, 0.367534722222222, 0.429076244212963, 0.419275655864198, 
0.369282889660494, 0.402340133101852, 0.341787229938272, 0.379204041280864, 
0.386735628858025, 0.446989535108025, 0.402697000385802, 0.433216386959877, 
0.367690248842593, 0.375049430941358, 0.368416039737654, 0.402647569444444, 
0.40395809220679, 0.425563030478395, 0.45283203125, 0.369378134645062, 
0.355145640432099, 0.419715711805556, 0.321680893132716, 0.400511188271605, 
0.399321228780864, 0.408874662422839, 0.380805121527778, 0.357367621527778, 
0.387917148919753, 0.46065055941358, 0.397224633487654, 0.365272955246914, 
0.419821807484568, 0.395893614969136, 0.434101321373457, 0.420037615740741, 
0.344226224922839, 0.380940152391975, 0.364171006944444, 0.419171971450617, 
0.419407069830247, 0.370770640432099, 0.3603515625, 0.408857783564815, 
0.417365933641975, 0.352559558256173, 0.399633487654321, 0.389433834876543, 
0.394340760030864, 0.383954234182099, 0.388071469907407, 0.359601658950617, 
0.363640528549383, 0.357619598765432, 0.37666015625, 0.39146412037037, 
0.360531201774691, 0.37396556712963, 0.396057581018519, 0.436072530864198, 
0.426344280478395, 0.404943094135802, 0.418567949459877, 0.360329861111111, 
0.44258415316358, 0.382421875, 0.396319203317901, 0.404704378858025, 
0.352875434027778, 0.401589023919753, 0.389913676697531, 0.38095100308642, 
0.390802228009259, 0.401812065972222, 0.410579427083333, 0.401623987268519, 
0.437044270833333, 0.403096064814815, 0.335836226851852, 0.393484760802469, 
0.39955150462963, 0.391191647376543, 0.347428385416667, 0.397435619212963, 
0.372844328703704, 0.405638744212963, 0.381063126929012, 0.377789834104938, 
0.406129436728395, 0.385578221450617, 0.371550684799383, 0.397008825231481, 
0.410454041280864, 0.383675733024691, 0.344425154320988, 0.352178578317901, 
0.395658516589506, 0.410639708719136, 0.372582706404321, 0.401175491898148, 
0.364237316743827, 0.401288821373457, 0.393103780864198, 0.371531394675926, 
0.369349199459877, 0.386342592592593, 0.43155502507716, 0.420232928240741, 
0.448606288580247, 0.345263069058642, 0.399540653935185, 0.376935040509259, 
0.357755835262346, 0.382535204475309, 0.408638358410494, 0.421451822916667, 
0.408481626157407, 0.416130160108025, 0.429947916666667, 0.387145543981481, 
0.427443817515432, 0.334611304012346, 0.389210792824074, 0.370070167824074, 
0.408222415123457, 0.400714940200617, 0.429736930941358, 0.365889033564815, 
0.416772762345679, 0.364687017746914, 0.407233796296296, 0.403978587962963, 
0.371117862654321, 0.43031322337963, 0.368804253472222, 0.376974826388889, 
0.432552083333333, 0.400812596450617, 0.379140142746914, 0.397846739969136, 
0.346225163966049, 0.372135416666667, 0.408092206790123, 0.414579716435185, 
0.404601900077161, 0.40112003279321, 0.364250578703704, 0.359230324074074, 
0.390632233796296, 0.392872299382716, 0.406500771604938, 0.396532600308642, 
0.433258584104938, 0.407444782021605, 0.369508342978395, 0.375815007716049, 
0.404651331018519, 0.398518277391975, 0.403392650462963, 0.393666811342593, 
0.407813705632716, 0.424363425925926, 0.389061294367284, 0.369866415895062, 
0.396776138117284, 0.409172453703704, 0.416928288966049, 0.378232301311728, 
0.40765697337963, 0.417314091435185, 0.389046826774691, 0.415744357638889, 
0.393634259259259, 0.36586612654321, 0.401743344907407, 0.426003086419753, 
0.39360050154321, 0.412666377314815, 0.41353443287037, 0.395747733410494, 
0.390230758101852, 0.386709104938272, 0.387943672839506, 0.35624397183642, 
0.415022183641975, 0.409261670524691, 0.396379484953704, 0.38554084683642, 
0.363905767746914, 0.397246334876543, 0.396917197145062, 0.370558449074074, 
0.326807243441358, 0.380318045910494, 0.371108217592593, 0.402881462191358, 
0.421170910493827, 0.377513744212963, 0.406248794367284, 0.432503858024691, 
0.389230082947531, 0.374774546682099, 0.385296103395062, 0.356553819444444, 
0.429593460648148, 0.399232011959877, 0.413334297839506, 0.357564139660494, 
0.380099826388889, 0.392191116898148, 0.425604021990741, 0.382099971064815, 
0.396692949459877, 0.378401089891975, 0.382632860725309, 0.379443962191358, 
0.353100887345679, 0.350179639274691, 0.400798128858025, 0.391773967978395, 
0.390212673611111, 0.421403597608025, 0.383235677083333, 0.404604311342593, 
0.382499035493827, 0.404053337191358, 0.380803915895062, 0.409326774691358, 
0.360821759259259, 0.352030285493827, 0.382887249228395, 0.362068383487654, 
0.395824893904321, 0.426868730709877, 0.350993441358025, 0.351259886188272, 
0.376520302854938, 0.405735194830247, 0.333004195601852, 0.375434027777778, 
0.454225742669753, 0.385618007330247, 0.397746672453704, 0.399845679012346, 
0.381020929783951, 0.390805844907407, 0.37349537037037, 0.366712480709877, 
0.34423828125, 0.384405140817901, 0.376293643904321, 0.423095100308642, 
0.362887008101852, 0.410147810570988, 0.407542438271605, 0.397905815972222, 
0.438437982253086, 0.391622058256173, 0.359475067515432, 0.412031008873457, 
0.395044849537037, 0.406966145833333, 0.377733169367284, 0.353202160493827, 
0.382794415509259, 0.39121696566358, 0.411637972608025, 0.406511622299383, 
0.395616319444444, 0.352868200231481, 0.411424575617284, 0.386510175540123, 
0.388442804783951, 0.381898630401235, 0.44444565007716, 0.414210792824074, 
0.415461033950617, 0.43555290316358, 0.386957465277778, 0.349611786265432, 
0.360434751157407, 0.417320119598765, 0.381280140817901, 0.383104263117284, 
0.404839409722222, 0.363233024691358, 0.379905719521605, 0.405243296682099, 
0.364553192515432, 0.345275125385802, 0.414390432098765, 0.405825617283951, 
0.371305941358025, 0.382529176311728, 0.404598283179012, 0.369455295138889, 
0.409336419753086, 0.394952015817901, 0.380199893904321, 0.405327690972222, 
0.405947386188272, 0.384239969135802, 0.40400390625, 0.397398244598765, 
0.386231674382716, 0.398750964506173, 0.366917438271605, 0.413671875, 
0.377615017361111, 0.441937934027778, 0.373066165123457, 0.426989293981481, 
0.393100163966049, 0.384252025462963, 0.386873070987654, 0.447501929012346, 
0.392793933256173, 0.350059076003086, 0.350538917824074, 0.375974151234568, 
0.394501109182099, 0.364362702546296, 0.359079619984568, 0.398760609567901, 
0.365193383487654, 0.413980516975309, 0.336530671296296, 0.367936197916667, 
0.427888695987654, 0.411747685185185, 0.361118344907407, 0.340543016975309, 
0.374469521604938, 0.376176697530864, 0.339312065972222, 0.36255184220679, 
0.428757957175926, 0.396603732638889, 0.398220486111111, 0.377998408564815, 
0.458297164351852, 0.411371527777778, 0.388263165509259, 0.38179012345679, 
0.393031442901235, 0.378683207947531, 0.365017361111111, 0.395235339506173, 
0.361461950231481, 0.387102141203704, 0.446594087577161, 0.402951388888889, 
0.413870804398148, 0.383012635030864, 0.392099488811728, 0.380672501929012, 
0.369762731481481, 0.404457224151235, 0.437080439814815, 0.42606819058642, 
0.344309413580247, 0.370612702546296, 0.386519820601852, 0.330557966820988, 
0.414650848765432, 0.376538387345679, 0.367432243441358, 0.434569106867284, 
0.410765094521605, 0.393921199845679, 0.430010609567901, 0.424990354938272, 
0.37861930941358, 0.389408516589506, 0.397084780092593, 0.418393132716049, 
0.404865933641975, 0.419696421682099, 0.42328197337963, 0.35384837962963, 
0.440784143518519, 0.339085407021605, 0.398503809799383, 0.38325496720679, 
0.343084490740741, 0.365447771990741, 0.394507137345679, 0.437507233796296, 
0.373072193287037, 0.383201919367284, 0.399937307098765, 0.379497010030864, 
0.356886574074074, 0.420395688657407, 0.356246383101852, 0.388859953703704, 
0.445442708333333, 0.361277488425926, 0.371222752700617, 0.388386140046296, 
0.385187596450617, 0.375283323688272, 0.387521701388889, 0.388689959490741, 
0.357333863811728, 0.453578317901235, 0.36547550154321, 0.39613956404321, 
0.417972366898148, 0.374092158564815, 0.382782359182099, 0.381862461419753, 
0.423981240354938, 0.414672550154321, 0.348871527777778, 0.387929205246914, 
0.413448832947531, 0.389042004243827, 0.336711516203704, 0.407901716820988, 
0.370625964506173, 0.412831548996914, 0.381561053240741, 0.366015625, 
0.37412712191358, 0.407411024305556, 0.378071952160494, 0.372794897762346, 
0.419258777006173, 0.402212336033951, 0.403891782407407, 0.425675154320988, 
0.415992717978395, 0.392179060570988, 0.407238618827161, 0.402026668595679, 
0.395384837962963, 0.380525414737654, 0.363785204475309, 0.412713396990741, 
0.398572530864198, 0.395569299768519, 0.383186246141975, 0.36587215470679, 
0.36796272183642, 0.365980661651235, 0.357057773919753, 0.41279899691358, 
0.395349874614198, 0.390680459104938, 0.377873022762346, 0.389040798611111, 
0.377109857253086, 0.348837770061728, 0.368975453317901, 0.357876398533951, 
0.374716676311728, 0.394544511959877, 0.394398630401235, 0.417626350308642, 
0.382323013117284, 0.351409384645062, 0.425944010416667, 0.388559751157407, 
0.428446903935185, 0.398743730709877, 0.392685426311728, 0.398725646219136, 
0.345968364197531, 0.377530623070988, 0.382658179012346, 0.349848090277778, 
0.396012972608025, 0.353338396990741, 0.430840084876543, 0.377238859953704, 
0.394731385030864, 0.411692226080247, 0.37016300154321, 0.399468315972222, 
0.453606047453704, 0.368296682098765, 0.33921802662037, 0.417118778935185, 
0.406395881558642, 0.389037181712963, 0.417344232253086, 0.374247685185185, 
0.358676938657407, 0.404021990740741, 0.412682050540123, 0.347416329089506, 
0.394303385416667, 0.333446662808642, 0.361119550540123, 0.397492283950617, 
0.450394241898148, 0.381412760416667, 0.429846643518519, 0.376713204089506, 
0.40488884066358, 0.372957658179012, 0.404951533564815, 0.3615234375, 
0.380840084876543, 0.375343605324074, 0.378115354938272, 0.386223234953704, 
0.407086709104938, 0.390598476080247, 0.38189380787037, 0.426994116512346, 
0.398075810185185, 0.355055217978395, 0.40372299382716, 0.384253231095679, 
0.377801890432099, 0.421995563271605, 0.438786410108025, 0.39292896412037, 
0.373168643904321, 0.396023823302469, 0.406528501157407, 0.385123697916667, 
0.411454716435185, 0.407146990740741, 0.354187162422839, 0.385707224151235, 
0.45199893904321, 0.423301263503086, 0.426093508873457, 0.357736545138889, 
0.41849681712963, 0.397376543209877, 0.388570601851852, 0.369656635802469, 
0.389693045910494, 0.364955873842593, 0.41753833912037, 0.381816647376543, 
0.366625675154321, 0.405238474151235, 0.381565875771605, 0.395021942515432, 
0.412459008487654, 0.359935619212963, 0.361991222993827, 0.385581838348765, 
0.415857687114198, 0.383632330246914, 0.434061535493827, 0.352875434027778, 
0.42680362654321, 0.364462770061728, 0.401983265817901, 0.371050347222222, 
0.382638888888889, 0.341284481095679, 0.388495852623457, 0.40468147183642, 
0.398787133487654, 0.434308690200617, 0.415680459104938, 0.407871576003086, 
0.431914303626543, 0.387229938271605, 0.388371672453704, 0.377091772762346, 
0.409389467592593, 0.37120346257716, 0.39843147183642, 0.385562548225309, 
0.366154272762346, 0.373057725694444, 0.399386332947531, 0.357748601466049, 
0.436159336419753, 0.362225115740741, 0.365024594907407, 0.396502459490741, 
0.415729890046296, 0.37396556712963, 0.361053240740741, 0.37051986882716, 
0.409051890432099, 0.406489920910494, 0.399397183641975, 0.346672453703704, 
0.385487798996914, 0.382908950617284, 0.387248022762346, 0.370142505787037, 
0.361493296682099, 0.373767843364198, 0.419709683641975, 0.432388117283951, 
0.345741705246914, 0.386319685570988, 0.368377459490741, 0.377933304398148, 
0.355714699074074, 0.379832175925926, 0.376674623842593, 0.352170138888889, 
0.402731963734568, 0.35858772183642, 0.409573929398148, 0.430726755401235, 
0.398097511574074, 0.387141927083333, 0.401740933641975, 0.397419945987654, 
0.374105420524691, 0.405016637731481, 0.382298900462963, 0.392015094521605, 
0.342367139274691, 0.41382137345679, 0.36112075617284, 0.39140625, 
0.391415895061728, 0.362373408564815, 0.418616174768519, 0.385100790895062, 
0.37310474537037, 0.359172453703704, 0.344196084104938, 0.405438609182099, 
0.393285831404321, 0.426271942515432, 0.407395351080247, 0.358265817901235, 
0.413771942515432, 0.348013117283951, 0.364741271219136, 0.38968822337963, 
0.404763454861111, 0.38482349537037, 0.415417631172839, 0.385947145061728, 
0.386601803626543, 0.356246383101852, 0.372376543209877, 0.420251012731481, 
0.380846113040123, 0.402442611882716, 0.404289641203704, 0.374849295910494, 
0.405134789737654, 0.424883053626543, 0.369742235725309, 0.394878472222222, 
0.402324459876543, 0.408324893904321, 0.36083984375, 0.401047694830247, 
0.370205198688272, 0.399468315972222, 0.365071614583333, 0.387427662037037, 
0.386566840277778, 0.387134693287037, 0.341704041280864, 0.386242525077161, 
0.389988425925926, 0.394380545910494, 0.373389274691358, 0.386977961033951, 
0.372048611111111, 0.361917679398148, 0.360828993055556, 0.338351176697531, 
0.39232494212963, 0.376856674382716, 0.377413676697531, 0.375761959876543, 
0.417889178240741, 0.408604600694444, 0.419092399691358, 0.392327353395062, 
0.426388888888889, 0.386496913580247, 0.418935667438272, 0.369508342978395, 
0.389066116898148, 0.35234375, 0.409077208719136, 0.397744261188272, 
0.402287085262346, 0.412764033564815, 0.399705825617284, 0.395793547453704, 
0.390901089891975, 0.390275366512346, 0.425829475308642, 0.422141444830247, 
0.40127555941358, 0.425836709104938, 0.408755304783951, 0.43119212962963, 
0.394044174382716, 0.445629581404321, 0.38599537037037, 0.429912953317901, 
0.356674382716049, 0.410478153935185, 0.384129050925926, 0.423949893904321, 
0.419736207561728, 0.354499421296296, 0.411144868827161, 0.437016541280864, 
0.371636284722222, 0.384575135030864, 0.369868827160494, 0.417621527777778, 
0.384243586033951, 0.411648823302469, 0.398116801697531, 0.388364438657407, 
0.386033950617284, 0.415200617283951, 0.407120466820988, 0.373558063271605, 
0.41405647183642, 0.406703317901235, 0.378138261959877, 0.399733555169753, 
0.388875626929012, 0.42020278742284, 0.355137201003086, 0.351853057484568, 
0.377156876929012, 0.415581597222222, 0.397840711805556, 0.351316550925926, 
0.43052059220679, 0.408252555941358, 0.373283179012346, 0.364079378858025, 
0.370189525462963, 0.39624324845679, 0.371161265432099, 0.436905623070988, 
0.372820216049383, 0.416814959490741, 0.367123601466049, 0.382185570987654, 
0.422733410493827, 0.412718219521605, 0.380322868441358, 0.385768711419753, 
0.429175106095679, 0.392156153549383, 0.336970727237654, 0.42496021412037, 
0.404698350694444, 0.385574604552469, 0.417764998070988, 0.347227044753086, 
0.387035831404321, 0.418354552469136, 0.401291232638889, 0.382189187885802, 
0.367764998070988, 0.366671489197531, 0.399421296296296, 0.348514660493827, 
0.392493730709877, 0.362890625, 0.391638937114198, 0.426443142361111, 
0.379252266589506, 0.411027922453704, 0.370541570216049, 0.378446903935185, 
0.394773582175926, 0.413078703703704, 0.443235194830247, 0.401103153935185, 
0.403628954475309, 0.431617717978395, 0.394756703317901, 0.41430362654321, 
0.387205825617284, 0.356032986111111, 0.377866994598765, 0.427340133101852, 
0.430457899305556, 0.369756703317901, 0.40421127507716, 0.42396556712963, 
0.394716917438272, 0.344619261188272, 0.429246238425926, 0.358376736111111, 
0.373515866126543, 0.376716820987654, 0.415721450617284, 0.398945071373457, 
0.390829957561728, 0.415590036651235, 0.372623697916667, 0.411378761574074, 
0.362014130015432, 0.385200858410494, 0.42539665316358, 0.358989197530864, 
0.39154369212963, 0.409165219907407, 0.354264322916667, 0.382320601851852, 
0.392441888503086, 0.38319106867284, 0.415165653935185, 0.419118923611111, 
0.438945553626543, 0.383711902006173, 0.406321132330247, 0.420744116512346, 
0.393296682098765, 0.373635223765432, 0.382902922453704, 0.370631992669753, 
0.386036361882716, 0.395402922453704, 0.386788676697531, 0.386981577932099, 
0.38959659529321, 0.391449652777778, 0.355647183641975, 0.376593846450617, 
0.354891251929012, 0.343709008487654, 0.404910542052469, 0.393446180555556, 
0.363194444444444, 0.393581211419753, 0.381512827932099, 0.385577015817901, 
0.361928530092593, 0.436765769675926, 0.38978587962963)
@
You could use this method to replicate the resampling 999 times and then create
a histogram to visualize a distribution of what would happen under different
assumptions of panmixia.

<<bd_histogram, resolution = 300>>=
hist(bd.test, xlab = "Bruvo's Distance", main = "Average Bruvo's distance over 999 randomizations")
abline(v = observed, col = "red")
legend('topleft', legend="observed", col="red", lty = 1)
@

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Removing uninformative loci \{Cut It Out!\}}
\label{data.manip:informloci}
\tab\tab Phylogenetically uninformative loci are those that have only one
sample differentiating from the rest. This can lead to biased results when
using multilocus analyses such as the index of association \cite{Brown:1980,Smith:1993}.
These nuisance loci can be removed with the following function.
\subsubsection{Function: informloci}
\label{data.manip:informloci:informloci}

\tline{}
\begin{quote}
Default Command:
<<informloci_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "informloci"
print_command(funk)
@
% \texttt{informloci(pop, cutoff = 2/nInd(pop), quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{cutoff -} this represents the minimum fraction of individuals
    needed for a locus to be considered informative. The default is set to $2/n$
    with $n$ being the number of individuals in the data set (represented by the
    \adegenet{} function \texttt{nInd}). Essentially, this means that any locus
    with fewer than 2 observations differing will be removed. The user can also
    specify a fraction of observations for the cutoff (eg. 0.05).
    \item \texttt{quiet -} if \texttt{TRUE}, nothing will be printed to the
    screen, if \texttt{FALSE} (default), the cutoff value in percentage and
    number of individuals will be printed as well as the names of the
    uninfomrative loci found.
  \end{itemize}
\bline{}

Here's a quick example using the H3N2 virus SNP data set. We will only retain
loci that have a minor allele frequency of $\geq 5\%$
<<inform.H3N2.1, eval = FALSE>>=
data(H3N2)
H.five <- informloci(H3N2, cutoff = 0.05)
@
<<inform.H3N2.2, echo = FALSE>>=
res <- c(157,177,233,243,262,267,280,303,313,327,357,382,384,399,412,418,424,425,429,433,451,470,529,546,555,557,564,576,592,595,597,602,612,627,642,647,648,654,658,663,667,681,717,806,824,837,882)
cat("cutoff value: 5 percent ( 95 individuals ).\n","47 uninfomative loci found:", res, fill = 80)
@
Now what happens when you have all informative loci. We'll use the nancycats
data set, which has microsatellite loci. It is important to note that this is
searching for loci with a specified genotype frequency as fixed heterozygous
sites are also uninformative:
<<inform.nancy>>=
data(nancycats)
naninform <- informloci(nancycats, cutoff = 0.05)
@

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Multilocus Genotype Analysis}
\label{mlg}

\tab\tab In populations with mixed sexual and clonal reproduction, it common to have multiple samples from the same population that have the same set of alleles at all loci. Here, we introduce tools for tracking MLGs within and across populations in \seclink{intro:genind}{genind} objects from the \adegenet{} package. We will be using the \seclink{data:virus}{virus} data set containing SNP data from isolates of the H3N2 virus from 2002 to 2006. Note that genclone objects are optimal for these analyses. %-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{How many multilocus genotypes are in our data set? \{Just a peek\}}
\label{mlg:mlg}
\tab\tab Counting the number of MLGs in a population is the
first step for these analyses as they allow us to see how many clones
exist. With the \seclink{intro:genclone}{genclone} object, This information is
already displayed when we view the object.
<<view_mlg>>=
virus
@
\noindent
If we need to store the number of MLGs as a variable, we can simply run the
\texttt{mlg} command.
<<mlg_genind>>=
virus_mlg <- mlg(virus)
virus_mlg
@
\label{mlg:mlg:mlg}

Since the number of individuals exceeds the number of multilocus
genotypes, we conclude that this data set contains clones. Let's examine what populations these clones belong to.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{MLGs across populations \{clone-ing around\}}
\label{mlg:cross}

\tab\tab Since you have the ability to define hierarchical levels of your
data set freely, it is quite possible to see some of the same MLGs across
different populations. Tracking them by hand can be a nightmare with large data
sets. Luckily, \texttt{mlg.crosspop} has you covered in that regard.
\subsubsection{Function: mlg.crosspop}
\label{mlg:cross:mlg.crosspop}

\tab\tab Analyze the MLGs that cross populations within your data set. This has
three output modes. The default one gives a list of MLGs, and for each MLG, it
gives a named numeric vector indicating the abundance of that MLG in each
population. Alternate outputs are described with \texttt{indexreturn} and
\texttt{df}.

\tline{}
\begin{quote}
Default Command:
<<mlg.crosspop_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "mlg.crosspop"
print_command(funk)
@
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sublist -} Populations to include (Defaults to ``ALL''). 
  see \cmdlink{data.manip:divide:popsub}{popsub.}
  \item \texttt{blacklist -} Populations to exclude. see \cmdlink{data.manip:divide:popsub}{popsub.}
  \item \texttt{mlgsub -} see \cmdlink{mlg:table:mlg.table}{mlg.table.} Only
  analyze specified MLGs. The vector for this flag can be produced by this
  function as you will see later in this vignette.
  \item \texttt{indexreturn -} return a vector of indices of MLGs. (You can
  use these in the \texttt{mlgsub} flag, or you can use them to subset the
  columns of an MLG table).
  \item \texttt{df -} return a data frame containing the MLGs, the populations
  they cross, and the number of copies you find in each population. This is
  useful for making graphs in \textit{ggplot2}.
  \item \texttt{quiet -} \texttt{TRUE} or \texttt{FALSE}. Should the
  populations be printed to screen as they are processed? (will print nothing
  if \texttt{indexreturn} is \texttt{TRUE})
\end{itemize}
  
\bline{}

We can see what MLGs cross different populations and then give a
vector that shows how many populations each one of those MLGs crosses.
<<crosspop, eval=FALSE>>=
setpop(virus) <- ~country
v.dup <- mlg.crosspop(virus, quiet=TRUE)
@
Here is a snippet of what the output looks like when \texttt{quiet} is
\texttt{FALSE}. It will print out the MLG name, the total number of individuals
that make up that MLG, and the populations where that MLG can be found.
<<crosspopout, echo=FALSE>>=
setpop(virus) <- ~country
v.dup <- structure(list(MLG.3 = structure(c(4L, 8L), .Names = c("USA", 
"Denmark")), MLG.9 = structure(c(1L, 13L, 1L, 1L), .Names = c("Japan", 
"USA", "Finland", "Denmark")), MLG.31 = structure(c(2L, 7L), .Names = c("Japan", 
"Canada")), MLG.75 = structure(c(2L, 8L, 2L, 1L, 6L, 2L, 1L, 
1L), .Names = c("Japan", "USA", "Finland", "Norway", "Denmark", 
"Austria", "Russia", "Ireland")), MLG.80 = structure(c(1L, 1L
), .Names = c("USA", "Denmark")), MLG.86 = structure(3:4, .Names = c("Denmark", 
"Austria")), MLG.95 = structure(c(1L, 1L), .Names = c("USA", 
"Bangladesh")), MLG.97 = structure(c(1L, 5L, 1L, 1L), .Names = c("USA", 
"Austria", "Bangladesh", "Romania")), MLG.104 = structure(1:2, .Names = c("USA", 
"France")), MLG.110 = structure(c(2L, 3L, 11L), .Names = c("Japan", 
"USA", "China"))), .Names = c("MLG.3", "MLG.9", "MLG.31", "MLG.75", 
"MLG.80", "MLG.86", "MLG.95", "MLG.97", "MLG.104", "MLG.110"))
printthings <- function(ind, x){
  cat(paste0(names(x)[ind], ":"), 
      paste0("(", sum(x[[ind]])," inds)"), 
      names(x[[ind]]), 
      "\n")
}
invisible(lapply(1:10, printthings, v.dup))
@
The output of this function is a list of MLGs, each containing a vector
indicating the number of copies in each population. We'll count the number of
populations each MLG crosses using the function \texttt{sapply} to loop over
the data with the function \texttt{length}.
<<crosspop2>>=
head(v.dup)
v.num <- sapply(v.dup, length) # count the number of populations each MLG crosses.
head(v.num)
@
%\newpage
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Producing MLG tables and graphs \{bringing something to the table\}}
\label{mlg:table}

We can also create a table of MLGs per population as well as bar graphs to give
us a visual representation of the data. This is achieved through the function
\texttt{mlg.table}
\subsubsection{Function: mlg.table}
\label{mlg:table:mlg.table}

\tab\tab This function will produce a matrix containing counts of MLGs (columns)
per population (rows). If there are not populations defined in your data set, a
vector will be produced instead.

\tline{}
\begin{quote}
Default Command:
<<mlg.table_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
funk <- "mlg.table"
print_command(funk)
@
% \texttt{mlg.table(pop, sublist = "ALL", blacklist = NULL, mlgsub = NULL, bar = TRUE, total = FALSE, quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{sublist -} Populations to include (Defaults to ``ALL'').
    see \cmdlink{data.manip:divide:popsub}{popsub.}
    \item \texttt{blacklist -} Populations to exclude.
    see \cmdlink{data.manip:divide:popsub}{popsub.}
    \item \texttt{mlgsub -} a vector containing the indices of MLGs you wish to
    subset your table with.
    \item \texttt{bar -} \texttt{TRUE} or \texttt{FALSE}. If  \texttt{TRUE}, a
    bar plot will be printed for each population with more than one individual.
    \item \texttt{total -} When set to \texttt{TRUE}, the pooled data set will
    be added to the table. Defaults to \texttt{FALSE}.
    \item \texttt{quiet -} Defaults to \texttt{FALSE}: population names will
    be printed to the console as they are processed.
  \end{itemize}
\bline{}

<<mlgbar, eval=FALSE>>=
v.tab <- mlg.table(virus, quiet=TRUE, bar=TRUE)
v.tab[1:10, 1:10] # Showing the first 10 columns and rows of the table.
@
<<echo=FALSE>>=
v.tab <- mlg.table(virus, quiet=TRUE, bar=FALSE)
v.tab[1:10, 1:10]
@
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a bar-chart produced by
  \texttt{mlg.table}. Note that this data set would produce several such
  charts but only the chart for Norway is shown here.}
  \label{nortable}
<<mlgbarplot, echo=FALSE, results='hide'>>=
mlg.table(virus, sublist="Norway", quiet=TRUE, bar=TRUE)
@
\end{figure}
\newpage

The MLG table is not limited to use with \poppr{}. In fact, one of the main
advantages of \texttt{mlg.table} is that it allows easy access to diversity
functions present in the package \textit{vegan} \cite{vegan}. One example is to
create a rarefaction curve for each population in your data set giving the
number of expected MLGs for a given sample size. For more information, type
\texttt{help("diversity", package="vegan")} in your R console.

For the sake of this example, instead of drawing a curve for each of the 37
countries represented in this sample, let's set the hierarchical level to year.
<<mlgrare1_dummy, eval = FALSE>>=
setpop(virus) <- ~year
summary(virus) # Check the data to make sure it's correct.
@
<<mlgrare1, echo = FALSE>>=
setpop(virus) <- ~year
res <- structure(list(N = 1903L, pop.eff = structure(c(158, 415, 399, 
469, 462), .Names = c("2002", "2003", "2004", "2005", "2006")), 
    loc.nall = structure(c(3L, 3L, 4L, 2L, 4L, 2L, 3L, 2L, 4L, 
    3L, 4L, 2L, 4L, 3L, 2L, 2L, 3L, 3L, 2L, 2L, 3L, 3L, 3L, 2L, 
    2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 4L, 4L, 3L, 3L, 3L, 4L, 
    2L, 2L, 2L, 4L, 3L, 2L, 3L, 4L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 
    4L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 4L, 4L, 4L, 3L, 3L, 2L, 3L, 
    4L, 3L, 2L, 3L, 3L, 3L, 3L, 2L, 3L, 2L, 4L, 2L, 3L, 2L, 2L, 
    3L, 3L, 3L, 3L, 2L, 2L, 2L, 2L, 3L, 2L, 3L, 2L, 3L, 2L, 3L, 
    2L, 3L, 3L, 2L, 2L, 2L, 3L, 2L, 2L, 2L, 3L, 3L, 3L, 2L, 2L, 
    3L, 3L, 3L, 3L, 4L, 2L, 3L, 3L, 4L, 3L, 2L), .Names = c("L001", 
    "L002", "L003", "L004", "L005", "L006", "L007", "L008", "L009", 
    "L010", "L011", "L012", "L013", "L014", "L015", "L016", "L017", 
    "L018", "L019", "L020", "L021", "L022", "L023", "L024", "L025", 
    "L026", "L027", "L028", "L029", "L030", "L031", "L032", "L033", 
    "L034", "L035", "L036", "L037", "L038", "L039", "L040", "L041", 
    "L042", "L043", "L044", "L045", "L046", "L047", "L048", "L049", 
    "L050", "L051", "L052", "L053", "L054", "L055", "L056", "L057", 
    "L058", "L059", "L060", "L061", "L062", "L063", "L064", "L065", 
    "L066", "L067", "L068", "L069", "L070", "L071", "L072", "L073", 
    "L074", "L075", "L076", "L077", "L078", "L079", "L080", "L081", 
    "L082", "L083", "L084", "L085", "L086", "L087", "L088", "L089", 
    "L090", "L091", "L092", "L093", "L094", "L095", "L096", "L097", 
    "L098", "L099", "L100", "L101", "L102", "L103", "L104", "L105", 
    "L106", "L107", "L108", "L109", "L110", "L111", "L112", "L113", 
    "L114", "L115", "L116", "L117", "L118", "L119", "L120", "L121", 
    "L122", "L123", "L124", "L125")), pop.nall = structure(c(203L, 
    255L, 232L, 262L, 240L), .Names = c("1", "2", "3", "4", "5"
    )), NA.perc = 2.36342616920652, Hobs = 0, Xexp = 0), .Names = c("N", 
"pop.eff", "loc.nall", "pop.nall", "NA.perc", "Hobs", "Xexp"))
listlab <- c("# Total number of genotypes: ", "# Population sample sizes: ", 
    "# Number of alleles per locus: ", "# Number of alleles per population: ", 
    "# Percentage of missing data: ", "# Observed heterozygosity: ", 
    "# Expected heterozygosity: ")
cat("\n", listlab[1], res[[1]], "\n")
for (i in 2:7) {
    cat("\n", listlab[i], "\n")
    print(res[[i]])
}
@
<<mlgrare2, eval=FALSE>>=
library(vegan)
H.year <- mlg.table(virus, bar=FALSE)
rarecurve(H.year, ylab="Number of expected MLGs", sample=min(rowSums(H.year)), border = NA, fill = NA, font = 2, cex = 1, col = "blue")
@
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a rarefaction curve produced using a MLG table.}
  \label{rarecurve}
<<mlgrareplot, echo=FALSE, results='hide'>>=
# library(vegan)
H.year <- mlg.table(virus, bar=FALSE)
vegan::rarecurve(H.year, ylab="Number of expected MLGs", sample=min(rowSums(H.year)), border = NA, fill = NA, font = 2, cex = 1, col = "blue")
@
\end{figure}
\newpage

The minimum value from the \textit{base} function \texttt{rowSums()} of the
table represents the minimum common sample size of all populations defined in
the table. Setting the ``sample" flag draws the horizontal and vertical lines
you see on the graph. The intersections of these lines correspond to the numbers
you would find if you ran the function \texttt{poppr} on this data
set (under the column ``\texttt{eMLG}").

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Combining MLG functions \{getting into the mix\}}
\label{mlg:mix}

\tab\tab Alone, the different functionalities are neat. Combined, we can create
interesting data sets. Let's say we wanted to know which MLGs were duplicated
across the regions of the United Kingdom, Germany, Netherlands, and Norway. All
we have to do is use the \texttt{sublist} flag in the function:
<<subcross>>=
setpop(virus) <- ~country
UGNN.list <- c("United Kingdom", "Germany", "Netherlands", "Norway")
UGNN <- mlg.crosspop(virus, sublist=UGNN.list, indexreturn=TRUE)
@
OK, the output tells us that there are three MLGs that are crossing between
these populations, but we do not know how many are in each. We can easily find
that out if we subset our original table, \texttt{v.tab}.

<<subtable>>=
UGNN # Note that we have three numbers here. This will index the columns for us.
UGNN.list # And let's not forget that we have the population names.
v.tab[UGNN.list, UGNN]
@

Now we can see that Norway has a higher incidence of nearly all of these MLGs.
We can investigate the incidence of these MLGs throughout our data set. One
thing that the \seclink{intro:genclone}{genclone} object keeps track of is a
single vector defining the unique multilocus genotypes within the data. These
are represented as integers and can be accessed with \texttt{mlg.vector}. This
is useful for finding MLGs that correspond to certain individuals or
populations. Let's use \texttt{mlg.vector} to find individuals corresponding to
the MLGs. First we'll investigate what the output of this function looks like.

<<mlg.vector_first>>=
v.vec <- mlg.vector(virus)
str(v.vec) # Analyze the structure.
@
\noindent
The integers produced are the MLG assigment of each individual in the same order
as the data set. This means that the first two individuals have the exact same
set of alleles at each locus, so they have the same MLG: \Sexpr{v.vec[1]}. If
we look at the number of unique integers in the vector, it corresponds to the
number of observed multilocus genotypes:
<<mlg.vector_second>>=
length(unique(v.vec)) # count the number of MLGs
virus # equal to the first number in this output.
@
\label{mlg:mix:mlg.vector}
\noindent
We will take \texttt{UGNN} (MLGs crossing UK, Germany, Netherlands, and Norway)
and compare its elements to the MLG vector (\texttt{v.vec}) to see where else
they occur.

<<mlg.vector_match>>=
UGNN # Show what we are looking for
UGNN_match <- v.vec %in% UGNN
table(UGNN_match) # How many individuals matched to those three MLGs?
@
\noindent
22 individuals matched to those three MLGs. We can use this vector to show us
the 22 individuals.

<<mlg.vector_inds>>=
indNames(virus)[UGNN_match]
@

Note that there is an alternative way to list individuals matching specific MLGs using the function \texttt{mlg.id}. This function will return a list where each element represents a unique MLG. You can use this data to find out which individuals correspond to specific MLGs. Each element in the list is named with the MLG, but the index does not necessarily match up, so it is important to convert your query MLGs to strings:
\label{mlg:mix:mlg.id}
<<mlg.id>>=
virus.id <- mlg.id(virus)
virus.id[as.character(UGNN)]
@


We can also use the vector of MLGs to
subset \cmdlink{mlg:table:mlg.table}{mlg.table} with the \texttt{mlgsub} flag.
<<mlgsub_flag, eval=FALSE>>=
mlg.table(virus, mlgsub = UGNN, bar = TRUE)
@
<<mlgsub_flagshow, echo=FALSE>>=
mlg.table(virus, mlgsub = UGNN, bar = FALSE)
@
\noindent
That showed us exactly which populations these three MLGs came from in our data set.
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of the same bar-chart as \textit{Figure 1},
  but focusing on three MLGs.}
  \label{nortable2}
<<subnor, results='hide', echo=FALSE>>=
mlg.table(virus, sublist = "Norway", mlgsub = UGNN)
@
\end{figure}
\newpage

%%%% Removing this section since it's a bit confusing.%%%%

% So, we've gotten this far, yet we haven't actually seen what the genotypes look
% like! For analyses where the genotypic signature is important, this is a crucial
% identification step. Lucky for us, the \texttt{genind} object retains all of the
% genotypic information and can be accessed using the \texttt{genind2df} function.
% Let's take a look at the three genotypes we specified above utilizing the vector
% of MLGs we created above, \texttt{H.vec}.
% <<df hashing_echo, eval=FALSE>>=
% v.df <- genind2df(virus)
% v.df[v.vec %in% UGNN, 1:15] # Showing only 15 columns becaus it is a large dataset.
% @
% <<df hashing_eval, echo=FALSE>>=
% structure(list(pop = structure(c(15L, 15L, 15L, 15L, 15L, 15L, 
% 15L, 21L, 25L, 6L, 1L, 1L, 6L, 6L, 6L, 6L, 21L, 1L, 1L, 13L, 
% 1L, 6L), .Label = c("Japan", "USA", "Finland", "China", "South Korea", 
% "Norway", "Taiwan", "France", "Latvia", "Netherlands", "Bulgaria", 
% "Turkey", "United Kingdom", "Denmark", "Austria", "Canada", "Italy", 
% "Russia", "Bangladesh", "Egypt", "Germany", "Romania", "Ukraine", 
% "Czech Republic", "Greece", "Iceland", "Ireland", "Sweden", "Nepal", 
% "Saudi Arabia", "Switzerland", "Iran", "Mongolia", "Spain", "Slovenia", 
% "Croatia", "Algeria"), class = "factor"), `6` = c("a", "a", "a", 
% "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", 
% "a", "a", "a", "a", "a", "a"), `17` = c("a", "a", "a", "a", "a", 
% "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", 
% "a", "a", "a", "a"), `39` = c("g", "g", "g", "g", "g", "g", "g", 
% "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
% "g", "g"), `42` = c("c", "c", "c", "c", "c", "c", "c", "c", "c", 
% "c", "c", "c", "c", "c", "c", "c", "c", "c", "c", "c", "c", "c"
% ), `45` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
% "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t"), 
%     `51` = c("c", "c", "c", "c", "c", "c", "c", "c", "c", "c", 
%     "c", "c", "c", "c", "c", "c", "c", "c", "c", "c", "c", "c"
%     ), `60` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", 
%     "a"), `72` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g"), `73` = c("c", "c", "c", "c", "c", "c", "c", "c", "c", 
%     "c", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", 
%     "a"), `90` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g"), `108` = c("a", "a", "a", "a", "a", "a", "a", "a", "a", 
%     "a", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", 
%     "t"), `123` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g"), `129` = c("t", "t", "t", "t", "t", "t", "t", "t", "t", 
%     "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", "t", 
%     "t"), `134` = c("g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", "g", 
%     "g")), .Names = c("pop", "6", "17", "39", "42", "45", "51", 
% "60", "72", "73", "90", "108", "123", "129", "134"), row.names = c("CY026119", 
% "CY026120", "CY026121", "CY026122", "CY026131", "CY026132", "CY026135", 
% "EU502462", "EU502463", "EU502464", "EU501513", "AB243868", "DQ883618", 
% "DQ883619", "DQ883620", "DQ883628", "EU501609", "EU501642", "EU501643", 
% "EU501735", "EU501742", "EU502513"), class = "data.frame")
% @
% Notice that there seems to be a clear separation between the SNPs of the first
% 10 isolates and the rest? This is no coincidence. Take a look at the output of
% our earlier sub-setting.
% <<subsetting>>=
% v.vec[UGNN_match]
% @

% We have the MLGs \Sexpr{UGNN[1]}, \Sexpr{UGNN[2]}, and \Sexpr{UGNN[3]}, and the
% result of the sub-setting shows us that \Sexpr{UGNN[3]} occurs earlier in our
% data set, and that MLGs \Sexpr{UGNN[1]} and \Sexpr{UGNN[2]} are mixed in
% together. The reason why we do not see a mixture of three different sets of SNP
% calls in our little window is because \texttt{mlg.vector} creates the MLGs by
% first concatenating and then sorting the genotypes. This way, the closer two MLG
% indexes are to each other, the fewer differences they will have between one
% another.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
% \subsection{Alternative data visualization \{do you see what I see?\}}
% \label{mlg:alt.vis}

% \tab\tab The graphs that are output by \poppr{} are simply aids for the user to
% make data analysis easier. We want to better visualize how these MLGs cross
% populations by MLG or population. We also want to see exactly what MLGs are in
% which populations, and how prevalent they are. As the package \textit{ggplot2}
% is based on data frames, we have to give ourselves a data frame to work with. We
% can do this using the \texttt{df = TRUE} flag.
% <<mlg_chart>>=
% df <- mlg.crosspop(virus, df=TRUE, quiet=TRUE)
% names(df)
% @
% Now that we have our data frame, we can do a couple of things. We can first see
% where the most omnipresent MLG occurs. After that, we will plot the top ten MLGs
% using ggplot2. Remember that \texttt{v.num} is the number of populations per
% multilocus genotype.
% <<>>=
% v.max <- names(sort(v.num, decreasing=TRUE)[1:10])
% # Showing the data frame by the largest MLG complex.
% df[df$MLG %in% v.max[1], ]
% @
% And now we can visualize the largest ten MLG complexes using \textit{ggplot2}'s
% \texttt{qplot} function.
% \begin{figure}[h]
%   \centering
%   \caption{\footnotesize An example of the versatility of the MLG information.}
%   \label{mlgtable2}
% <<ggplotchart, resolution=300>>=
% df2 <- df[df$MLG %in% v.max, ]
% library(ggplot2)
% qplot(y=MLG, x=Population, data=df2, color=Count, size=Count) +
%       theme(axis.text.x = element_text(size = 10, angle = -45, hjust = 0))
% @
% \end{figure}
%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
% \section{Data Analysis}
% \label{index}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
% \subsection{Calculating the index of association, $I_A$ and $\bar{r} _d$ \{the missing linkage disequilibrium\}}
% \label{index:iard}

% \tab\tab The index of association was originally developed as a measure of
% multilocus linkage disequilibrium \cite{Brown:1980} and was found to be able to
% detect signatures of sexual reproduction and population structure
% \cite{Brown:1980, Smith:1993}. Unfotunately, $I_A$ was found to increase with
% the number of loci, and was not suitable to comparisons across studies
% \cite{Agapow:2001}. To remedy this, $\bar{r} _d$ was developed that corrects for
% this scaling and forces the index to lie between 0 (linkage equilibrium) and 1
% (full disequilibrium). $I_A$ has previously been implemented in a couple of
% programs including \textit{multilocus} \cite{Agapow:2001} and \textit{LIAN}
% \cite{Haubold:2000}. While both of these programs are still available for
% download, \textit{multilocus} is no longer actively supported, and
% \textit{LIAN}, despite its speed, is only appropriate for haplotypic data. Both
% of these programs each require one specific file format, and, until
% recently\footnote{LIAN 3.6 allows the user to run multiple contiguous data sets
% within a single file or across multiple files. It is impossible to run
% MULTILOCUS in batch.}, neither of these programs had an internal ability to run
% in batch across multiple populations within a file or multiple files within a
% directory in the same way that poppr can (see footnote).

% It is important to note that for this algorithm, all missing values are treated
% in the same way as \textit{multilocus} in that all missing alleles are imputed
% to be the same as the alleles they are being compared to. Depending on the
% percent missing data in your data set, this might influence the statistic. If
% you have a lot of missing data, consider using the \texttt{missing} flag in this
% function.
% \subsubsection{Function: ia}
% \label{index:iard:ia}

% \tab\tab This function is a quick look at a single data set. It can do almost
% everything that \texttt{poppr} can do except for sorting through populations.
% \begin{quote}
% Default Command:
% <<ia_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "ia"
% print_command(funk)
% @
% % \texttt{ia(pop, sample = 0, method = 1, quiet = FALSE, missing = "ignore", 
% %     hist = TRUE)}
% \end{quote}
% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object.
%   \item \texttt{sample -} You should use this flag whenever you want to
%   reshuffle your data set. Indicate how many times you want to reshuffle your
%   data set to obtain a P-value.
%   \item \texttt{method -} a number from 1 to 4 indicating the sampling method:
%   \begin{enumerate}
%     \item permutation over alleles.
%     \item parametric bootstrap.
%     \item non-parametric bootstrap.
%     \item \textit{multilocus} style permutation \cite{Agapow:2001}.
%   \end{enumerate}
%   The methods are detailed
%   in \cmdlink{data.manip:shuffle:shufflepop}{shufflepop.}
%   \item \texttt{quiet -} If set to \texttt{TRUE}, nothing will be printed to the
%   screen as the sampling progresses. If \texttt{FALSE} will produce a progress
%   bar.
%   \item \texttt{missing -} This will preprocess your missing values. It is set
%   to ignore missing data, so that they do not contribute to the distance
%   measure. It can also be set to \texttt{"loci", "geno", "zero", or "mean"}. For
%   details, see \seclink{data.manip:missing:missingno}{missingno.}
%   \item \texttt{hist -} This will produce a pair of histograms for each
%   population showing the distribution of $I_A$ and $\bar{r} _d$ across the
%   sampled data sets, and plot the observed value as a single vertical line.
%   \item \texttt{valuereturn -} If set to \texttt{TRUE} and the number of samples
%   is greater than zero, it will return all values generated from the permuted
%   data.
% \end{itemize}
% Running the analysis is as simple as this:
% <<ia_demo>>=
% ia(nancycats)
% @
% We can use \texttt{popsub} to subset for specific populations. Here, we'll also
% demonstrate the sampling flag and show you what the histogram looks like.
% <<ia_demo_sampling_dummy, eval=FALSE>>=
% set.seed(1009)
% ia(popsub(nancycats, 5), sample=999)
% @
% <<ia_demo_sampling, echo=FALSE>>=
% set.seed(1009)
% simplenan <- ia(popsub(nancycats, 5))
% cat("|================================================================================| 100%\n")
% c(simplenan[1], p.Ia = 0.572, simplenan[2], p.rD = 0.572)
% @

% This analysis produced the histograms you see below. What these histograms
% represent are 999 resamplings of the data under the null hypothesis ($H_0$) of
% sexual reproduction. The way that $H_0$ is created is determined by the sampling
% method chosen. In this case, the method was to shuffle genotypes at each locus
% to simulate unlinked loci. Since the P = 0.572, we would fail to reject $H_0$
% and we therefore might conclude that this population is sexually reproducing
% \cite{Brown:1980} \cite{Smith:1993} \cite{Agapow:2001}.
% \begin{figure}[h!]
%   \centering
%   \caption{\footnotesize Histograms of 999 values of $I_A$ and $\bar{r} _d$
%   calculated from 999 resamplings of population 5 from the data set
%   ``nancycats". The observed values of $I_A$ and $\bar r_d$ are represented as
%   vertical blue lines overlaid on the distributions. The ticks at the bottom of
%   each histogram represent individual observations.}
%   \label{ia_demo_fig}
% <<fig.width=8, fig.height=8, echo=FALSE, eval=TRUE, figs.only=TRUE, resolution=300>>=
% set.seed(1009)
% nan5 <- ia(popsub(nancycats, 5), sample=999, quiet=TRUE)
% @
% \end{figure}
% %\newpage

% If we wanted to, we could also have set the flag \texttt{valuereturn = TRUE} to
% get back our permuted data if we wanted to make our own histograms (we'll set
% the number of samples to 9 for demonstrative purposes):

% <<ia_demo_sampling_vr_dummy, eval = FALSE>>=
% set.seed(1009)
% ia(popsub(nancycats, 5), sample = 9, hist = FALSE, valuereturn = TRUE)
% @

% <<ia_demo_sampling_vr, echo = FALSE>>=
% cat("|================================================================================| 100%\n")
% structure(list(index = structure(c(-0.0475399533129828, 0.5, 
% -0.00600425397248417, 0.5), .Names = c("Ia", "p.Ia", "rbarD", 
% "p.rD")), samples = structure(list(Ia = c(-0.174180206794681, 
% 0.110998135909168, -0.0516575036742681, -0.227057548622598, -0.290794613187196, 
% 0.17142682029909, 0.127426390403491, -0.0489769895090723, -0.0100523130577507
% ), rbarD = c(-0.022056780840299, 0.0142082562146926, -0.00661071136361462, 
% -0.0289477478354951, -0.0366851757977678, 0.0217644448059182, 
% 0.0160542108673502, -0.00622397887147145, -0.00126986051456087
% )), .Names = c("Ia", "rbarD"), row.names = c(NA, -9L), class = "data.frame")), .Names = c("index", 
% "samples"))
% @


% There, are, of course a couple of caveats that need to be mentioned regarding
% our P-values. First, while we have equivalent P-values for $I_A$ and
% $\bar{r} _d$, they might not always be equal due to the difference in
% calculation. Details about that can be found in the Appendix
% section \seclink{appendix:algorithm:iard}{$I_A$ and $\bar{r} _d$.} Second, the
% P-values are calculated by comparing how many permuted values are greater than
% or equal to the observed value. This includes the observed value (which is why
% setting the randomizations to 999 will give you a round P-value) which means
% that the lowest P-value you will ever have is $1/(n+1)$ where $n$ is the number
% of permutations you select. Take for example this population of a clonal root
% rot pathogen, \textit{Aphanomyces euteiches}:
% <<ia_Aeut_ex, eval=FALSE>>=
% data(Aeut)
% set.seed(1001)
% ia(popsub(Aeut, 1), sample=999, method=2, quiet=TRUE, hist=FALSE)
% @
% <<ia_Aeut_ex_real, echo=FALSE>>=
% data(Aeut)
% set.seed(1001)
% A.dum <- ia(popsub(Aeut, 1))
% c(A.dum[1], p.Ia = 0.001, A.dum[2], p.rD = 0.001)
% @
% If you want to be able to report $P < 0.001$ in this situation, then you can
% simply increase the number in sample: \texttt{sample = 1999}
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %-----------------------------------------------------------------------------%
% %
% %-----------------------------------------------------------------------------%
% \subsection{Genetic distances \{may I have distance?\}}
% \label{index:gendist}

% \tab\tab Genetic distances are great tools for analyzing diversity in
% populations as they are the basis for creating dendrograms with bootstrap
% support and also for AMOVA. This section will simply present different genetic
% distances along with a few notes about them. Most of these distances are derived
% from the \textit{ade4} and \adegenet packages, where they were implemented as
% distances between populations. \Poppr extends the implementation to individuals
% as well (with the exception of Bruvo's distance).

% \begin{table}[ht]
% \centering
% \begin{tabular}{llll}
%   \hline
%  Method & Function & Assumption & Euclidean \\ 
%   \hline
% \seclink{distance:dissimilarity}{Provesti} & \texttt{provesti.dist} & - & No \\
%  & \texttt{diss.dist} & & \\
% \seclink{distance:nei}{Nei} & \texttt{nei.dist} & Infinite Alleles & No \\
%  & & Genetic Drift & \\
% \seclink{distance:edwards}{Edwards} & \texttt{edwards.dist} & Genetic Drift & Yes \\
% \seclink{distance:reynolds}{Reynolds} & \texttt{reynolds.dist} & Genetic Drift & Yes \\
% \seclink{distance:rogers}{Rogers} & \texttt{rogers.dist} & - & Yes \\
% \seclink{distance:bruvo}{Bruvo} & \texttt{bruvo.dist} & Stepwise Mutation & No \\
%    \hline
% \end{tabular}
% \end{table}

% Note on these distances: It is valuable for the user to know which distance is
% appropriate for use within his/her system. All of these distances except for
% Bruvo's distance are based on allele frequencies. Bruvo's distance takes into
% account the value of the allele, and thus may be more appropriate for questions
% of finding clonal descendents as opposed to a distance that will estimate the
% number of mutations that occured.

% Currently only Bruvo's distance and Provesti's distance perform as expected with
% polyploid data. The other distances appear to give spurious results.

% All of the distances are based on the table found in
% a \seclink{intro:genind}{genind object.} I have translated the following from math
% jargon into English with a few minor modifications:

% \begin{quote}
% Let \textbf{A} a table containing allelic frequencies with $t$ populations or
% individuals (rows) and $m$ alleles (columns).\\
% Let $\nu$ be the number of loci. The locus $j$ gets $m(j)$ alleles. 


% \begin{equation}
%   m=\sum_{j=1}^{\nu} m(j)
% \end{equation}
% \end{quote}


% Again, this is describing the table present in the \seclink{intro:genind}{genind
% object} where, instead of having the number of columns equal the number of loci,
% the number of columns equals the number of observed alleles in the entire data
% set. So, if you had a data set with 5 loci that had 2 alleles each, your table
% would have ten columns. Of course, codominant loci like microsatellites have
% varying numbers of alleles.


% \begin{quote}
% For the row $i$ and the modality $k$ of the variable $j$, notice the value

% \begin{equation}
%   a_{ijk}\\ (1 \leq i \leq t,\\ 1 \leq j \leq \nu,\\ 1 \leq k \leq m(j))
% \end{equation}

% the value of the initial table.

% \begin{equation}
%   a_{ij\cdot}=\sum_{k=1}^{m(j)} a_{ijk} 
% \end{equation}

% and 

% \begin{equation}
%   p_{ijk}=\frac{a_{ijk}}{a_{ij\cdot}}
% \end{equation}
% \end{quote}

% The above couple of equations are basically defining the allele frequency
% ($p_{ijk}$). Remember that $i$ is individual, $j$ is locus, and $k$ is allele.
% The following continutes to describe properties of the table:

% \begin{equation}
%  p_{ij\cdot}=\sum_{k=1}^{m(j)} p_{ijk}=1
% \end{equation}
% The sum of all allele frequencies for a single population (or individual) at a 
% single locus is one.

% \begin{equation}
% p_{i{\cdot}\cdot}=\sum_{j=1}^{\nu} p_{ij\cdot}=\nu
% \end{equation}
% The sum of all allele frequences over all loci is equal to the number of loci.
 
% \begin{equation}
% p_{{\cdot}{\cdot}\cdot}=\sum_{j=1}^{\nu} p_{i{\cdot}\cdot}=t\nu
% \end{equation}
% The the sum of the entire table is the sum of all loci multiplied by the number 
% of populations (or individuals).


% %
% %-----------------------------------------------------------------------------%
% %

% \subsubsection{Non-Euclidean distances}
% \label{index:gendist:neu}
% Dissimilarity distance
% \label{distance:dissimilarity}

% One of the least known distances and yet more conceptually satisfying is
% Provesti's (Also spelled Prevosti) distance. It's conceptually satisfying
% because it can be thought of as a percentage of dissimilar sites between two
% individuals or populations or the absolute genetic distance. It is implemented
% in two functions, \texttt{provesti.dist} and \texttt{diss.dist}.

% \label{distance:provesti}
% \begin{equation}
%   D_{P}(a,b)=\frac{1}{2{\nu}} \sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
%   |p_{ajk} - p_{bjk}|
% \end{equation}
% Note: for AFLP data, the $2$ is dropped. 


% Nei's distance
% \label{distance:nei}
% \begin{equation}
%   D_1(a,b)= -\ln(\frac{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
%   p_{ajk} p_{bjk}}{\sqrt{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
%   {(p_{ajk}) }^2}\sqrt{\sum_{k=1}^{\nu} \sum_{j=1}^{m(k)}
%   {(p_{bjk})}^2}})
% \end{equation}

% \subsubsection{Euclidean distance}
% \label{index:gendist:eu}

% Edward's Angular distance
% \label{distance:edwards}
% \begin{equation}
%   D_2(a,b)=\sqrt{1-\frac{1}{\nu} \sum_{k=1}^{\nu}
%   \sum_{j=1}^{m(k)} \sqrt{p_{ajk}  p_{bjk}}}
% \end{equation}

% Reynold's Coancestry distance
% \label{distance:reynolds}
% \begin{equation}
%   D_3(a,b)=\sqrt{\frac{\sum_{k=1}^{\nu}
%   \sum_{j=1}^{m(k)}{(p_{ajk} - p_{bjk})}^2}{2 \sum_{k=1}^{\nu} (1-
%   \sum_{j=1}^{m(k)} p_{ajk} p_{bjk})}}
% \end{equation}


% Roger's distance 
% \label{distance:rogers}
% \begin{equation}
%   D_4(a,b)=\frac{1}{\nu} \sum_{k=1}^{\nu} \sqrt{\frac{1}{2}
%   \sum_{j=1}^{m(k)}{(p_{ajk} - p_{bjk})}^2}
% \end{equation}

% \subsubsection{Bruvo's distance for microsatellites}
% \label{index:gendist:bruvo}

% This is based off of a specific model where it is necessary to specify the
% repeat lengths of the markers at each locus. Eg a repeat of $(CAT)^n$ would have
% a repeat length of 3.
% \label{distance:bruvo}


% Comparing all distances (WIP)

% <<mantel>>=
% data(nancycats)
% nancy9 <- popsub(nancycats, 9)
% repeats <- rep(2, 9)
% pro_nan <- provesti.dist(nancy9)
% nei_nan <- nei.dist(nancy9)
% edw_nan <- edwards.dist(nancy9)
% rey_nan <- reynolds.dist(nancy9)
% rog_nan <- rogers.dist(nancy9)
% bru_nan <- bruvo.dist(nancy9, replen = repeats)
% distlist <- list(Provesti = pro_nan,
%                  Nei = nei_nan,
%                  Edwards = edw_nan,
%                  Reynolds = rey_nan,
%                  Rogers = rog_nan,
%                  Bruvo = bru_nan)
% combs <- combn(x = 1:length(distlist), m = 2)
% mtest <- apply(combs, 2, function(x) mantel.randtest(distlist[[x[1]]], distlist[[x[2]]])$obs)
% attr(mtest, "class") <- "dist"
% attr(mtest, "Size") <- 6
% attr(mtest, "Labels") <- names(distlist)
% mtest <- as.matrix(mtest)
% diag(mtest) <- 1
% library(reshape2)
% library(ggplot2)
% ggplot(melt(mtest)) + geom_tile(aes_string(x = "Var1", y = "Var2", fill = "value"))
% @


% \subsection{Bootstrap analysis \{give `em the boot(strap)\}}
% \label{index:boot}
% \subsubsection{Bootstrapping any distance}
% \label{index:boot:any}
% \subsubsection{Bootstrapping Bruvo's Distance}
% \label{index:boot:bruvo}
% This is optimized for Bruvo's distance. 

% \subsection{Minimum spanning networks \{nothing but net(works)\}}

% \subsection{Analysis of MOlecular VAriance \{Come here! AMOVA here!\}}
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %
% %-----------------------------------------------------------------------------%
% %
% %-----------------------------------------------------------------------------%
% \subsection{Going the distance \{dissimilarity distance\}}
% \label{index:dist}
% \tab\tab Since \poppr{} is still in its infancy, the number of distance measures
% it can offer are few. Bruvo's distance is well supported and allows you to
% quickly visualize your data, but it only allows for microsatellites. The index
% of association, above, utilizes a discreet dissimilarity distance matrix. It is
% with this matrix that we have constructed a relative dissimilarity distance
% where the distance is the ratio of the number of dissimilarities to the number
% of dissimilarities possible. The number of dissimilarities possible is the
% number of loci multiplied by the ploidy, so if you have 10 loci from a diploid
% population, then there are 20 dissimilarities possible. For details, see
% equations (\ref{eq:ia_d}) and (\ref{eq:ia_D})
% in \seclink{appendix:algorithm:iard}{$I_A$ and $\bar{r} _d$.}

% \subsubsection{Function: diss.dist}
% \label{index:dist:diss.dist}

% \tab\tab Use this function to calculate relative dissimilarity between
% individuals and return a distance matrix for use in creating cladograms or
% minimum spanning networks. A note: missing alleles will be imputed to be the
% same as the challenging allele, decreasing the distance between some
% individuals. If you want to consider all missing data as special alleles, treat
% your data with \texttt{missingno(pop, type = "zero")} beforehand.

% \begin{quote}
% Default Command:
% <<diss.dist_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "diss.dist"
% print_command(funk)
% @
% % \texttt{diss.dist(pop)}
% \end{quote}

% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object. 
% \end{itemize}
% Since we have a data set that we know is very clonal, let's analyze the
% \textit{A. euteiches} data set \cite{Grunwald:2006} and create a heatmap to
% visualize the degree of difference between populations.
% <<diss_dist, eval=FALSE>>=
% data(Aeut)
% A.dist <- diss.dist(Aeut)
% heatmap(as.matrix(A.dist), symm=TRUE)
% @
% \begin{figure}[h!]
%   \centering
%   \caption{\footnotesize Heatmap representation of a dissimilarity distance for
%   the data set ``Aeut"}
%   \label{diss_heat_map}
% <<echo=FALSE, resolution=300>>=
% data(Aeut)
% A.dist <- diss.dist(Aeut)
% heatmap(as.matrix(A.dist), symm=TRUE)
% @
% \end{figure}
% \newpage
% %-----------------------------------------------------------------------------%
% %
% %-----------------------------------------------------------------------------%
% \subsection{Bruvo's distance \{step by stepwise mutation\}}
% \label{index:bruvo}

% \tab\tab Bruvo's distance is a genetic distance measure for microsatellite
% markers utilizing a stepwise mutation model that allows for differing ploidy
% levels \cite{Bruvo:2004}. As \textit{adegenet's} \texttt{genind} object has an
% all or none approach to missing data, any genotypes not exhibiting full ploidy
% will be treated as missing. This means that only non-special cases will be
% considered for the calculation and missing data will be ignored
% \cite{Bruvo:2004}.

% This is true only if missing data is treated as missing when importing to
% \adegenet{}. If missing data in the initial data frame has missing
% microsatellite alleles coded as 0, then the genind object will not treat them as
% missing (unless the genotype has no alleles in it). An example adapted from the
% \adegenet{} ``Getting Started" vignette shows how this can be done:

% <<cheating>>=
% set.seed(5001)
% temp <- lapply(1:30, function(i) sample(0:9, 4, replace=TRUE))
% temp <- sapply(temp, paste, collapse = "/")
% temp <- matrix(temp, nrow=10, dimnames=list(paste("ind",1:10), paste("loc",1:3)))
% temp 
% obj <- df2genind(temp, ploidy=4, sep="/")
% pop(obj) <- paste("ind", 1:10)
% @

% We will save this object for a later demonstration of the addition and loss
% models of Bruvo's distance. It is important to note that this is a distance
% between individuals, not populations, unlike Nei's 1978 distance
% \cite{Nei:1978}. For distances between populations, see the \adegenet{} function
% \texttt{dist.genpop}

% \subsubsection{Function: bruvo.dist}
% \label{index:bruvo:bruvo.dist}

% \tab\tab Bruvo's distance requires knowledge of the repeat lengths of each
% locus, so take care to read the description below.
% \begin{quote}
% Default Command:
% <<bruvo.dist_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "bruvo.dist"
% print_command(funk)
% @
% % \texttt{bruvo.dist(pop, replen = 1, add = TRUE, loss = TRUE)}
% \end{quote}
% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object.
%   \item \texttt{replen -} This is a vector of numbers indicating the repeat
%   length for each locus in your sample. If you have two dinucleotide repeats and
%   five tetranucleotide repeats, you would put \texttt{c(2,2,4,4,4,4,4)} in this
%   field. If you have imported data where that represents the raw number of
%   steps, all you would have to type is \texttt{rep(1, n)}, replacing $n$ with
%   the number of loci in your sample. It is important that you place something in
%   this field because this function will attempt to estimate the repeat length
%   based on the minimum difference of the alleles represented; with variability
%   of position calls, relying on this estimation is NOT recommended.
%   \item \texttt{add -} For missing data: use the genome addition model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
%   \item \texttt{loss -} For missing data: use the genome loss model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
% \end{itemize}

% To illustrate why it is important to specify the repeat lengths, let's imagine a
% locus that contains 5 alleles and the true repeat length is 4. Note that Bruvo's
% distance between alleles is calculated as $1 - 2^{-[x]}$, where $x$ is the
% difference in repeat lengths:
% <<replen_example1>>=
% locus1 <- c(244, 248, 256, 240, 236)
% locus1/4
% 1 - 2^-dist(locus1/4)
% @
% We can see that the distance between them ranges from 1 to 5. Let's say, that we
% accidentally wrote 2 or 8 instead of 4:
% <<replen_example2>>=
% locus1/2
% 1 - 2^-dist(locus1/2) # Distance increase

% locus1/8
% 1 - 2^-dist(locus1/8) # Distance decrease
% @
% While we will still get results from this analysis with the incorrect repeat
% length, they will be inherently wrong as they do not represent the true
% distance. That being said, it's important to note that the repeat lengths we
% represent for the rest of the manual are not known by the authors, but are used
% as a simple example.

% This function will return a distance matrix (displaying the smallest population
% in the data set ``nancycats"):
% <<bruvo_matrix>>=
% dist9 <- bruvo.dist(popsub(nancycats, 9), replen=rep(1,9))
% dist9
% @

% You can visualize this better with a simple heatmap:
% %\newpage

% <<bruvo_heat, eval = FALSE>>=
% heatmap(as.matrix(dist9), symm=TRUE)
% @
% \begin{figure}[h!]
%   \centering
%   \caption{\footnotesize Heatmap representation of Bruvo's distance for
%   population 9 of the data set ``nancycats"}
%   \label{bruvo_heat_map}
% <<resolution=300, echo = FALSE>>=
% heatmap(as.matrix(dist9), symm=TRUE)
% @
% \end{figure}
% %\newpage

% Let's take a closer look at the two individuals, N113 and N111. They seem to
% have large distances between everyone else and themselves. The names and columns
% of the matrix contain the names of individuals, but not the population
% information. We can make a comparison of Bruvo's distance across populations
% easier by editing the ``Labels" attribute of the distance object. Let's take a
% look at the labels attribute using the \texttt{attr()} command. <<attrLabels>>=
% attr(dist9, "Labels")
% @
% Remember that they all came from population 9, so let's append that to each
% label using the \texttt{paste()} command.
% <<attrLabel_replace>>=
% dist9.attr <- attr(dist9, "Labels")
% attr(dist9, "Labels") <- paste(rep("P09", 9), dist9.attr)
% dist9
% @
% Now we can see that all of the labels are corresponding to population 9. Let's
% calculate Bruvo's distance between populations 8 and 9.
% <<popcompare_bruvo1, eval=FALSE>>=
% dist9to8 <- bruvo.dist(popsub(nancycats, 8:9), replen=rep(1,9))
% dist9to8.attr <- attr(dist9to8, "Labels")
% nan9to8pop <- nancycats@pop[nancycats@pop %in% c("P08", "P09")]
% attr(dist9to8, "Labels") <- paste(nan9to8pop, dist9to8.attr)
% heatmap(as.matrix(dist9to8), symm=TRUE)
% @
% \begin{figure}[h!]
%   \centering
%   \caption{\footnotesize Heatmap representation of Bruvo's distance for
%   populations 8 and 9 of the data set ``nancycats"}
%   \label{bruvo_heat_map_8to9}
% <<popcompare_bruvo2, echo=FALSE, resolution=300>>=
% dist9to8 <- bruvo.dist(popsub(nancycats, 8:9), replen=rep(1,9))
% dist9to8.attr <- attr(dist9to8, "Labels")
% nan9to8pop <- nancycats@pop[nancycats@pop %in% c("P08", "P09")]
% attr(dist9to8, "Labels") <- paste(nan9to8pop, dist9to8.attr)
% heatmap(as.matrix(dist9to8), symm=TRUE)
% @
% \end{figure}

% Remember N113 and N111? Take a look at where they fall on the heatmap. They
% don't cluster together with population 9 anymore, but somewhere in population 8.
% % \newpage

% %-----------------------------------------------------------------------------%
% %
% %-----------------------------------------------------------------------------%
% \subsection{See the forest for the trees \{visualizing distances with dendrograms and networks\}}
% \label{index:trees}

% \tab\tab Staring at a raw distance matrix might be able to tell you something
% about your data, but it also might be able to ruin your eyesight. In this
% section, we present functions to display this data in trees and networks.

% \subsubsection{Function: bruvo.boot}
% \label{index:trees:bruvo.boot}

% \tab\tab This function provides the ability to draw a dendrogram based on
% Bruvo's distance including bootstrap support.
% \begin{quote}
% Default Command:
% <<bruvo.boot_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "bruvo.boot"
% print_command(funk)
% @
% % \texttt{bruvo.boot(pop, replen = 1, add = TRUE, loss = TRUE, sample = 100, tree = "upgma", showtree = TRUE, cutoff = NULL, quiet = FALSE)}
% \end{quote}
% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object.
%   \item \texttt{replen -} see \texttt{bruvo.dist}, above.
%   \item \texttt{add -} For missing data: use the genome addition model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
%   \item \texttt{loss -} For missing data: use the genome loss model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
%   \item \texttt{sample -} How many bootstraps do you want to perform?
%   \item \texttt{tree -} Two trees are available, Neighbor-Joining \texttt{"nj"}
%   or UPGMA \texttt{"upgma"}.
%   \item \texttt{showtree -} if \texttt{TRUE}, a tree will be plotted
%   automatically.
%   \item \texttt{cutoff -} This is a number between 0 and 100 indicating the
%   cutoff value for the bootstrap nodelables. If you only wanted to see the the
%   boostrap values for nodes that were present more than 75\% of the time, you
%   would use \texttt{cutoff = 75}. If you don't put anything for this parameter,
%   all values will be shown.
%   \item \texttt{quiet -} if \texttt{quiet = TRUE}, no standard messages will be
%   printed to screen. If \texttt{quiet = FALSE} (default), then a progress bar
%   and standard message will be printed to the screen.
% \end{itemize}

% For this example, let's set the cutoff to 50\%.
% <<bruvo_boot, eval=FALSE>>=
% set.seed(410)
% nan9tree <- bruvo.boot(popsub(nancycats, 8:9), replen=rep(1,9), sample=1000, cutoff=50)
% @
% <<progbar, echo=FALSE>>=
% cat("\nBootstrapping...\n(note: calculation of node labels can take a while even after the progress bar is full)\n\n")
% cat("|================================================================================| 100%\n")
% @
% \begin{figure}[h!]
%   \centering
%   \caption{\footnotesize UPGMA Tree of Bruvo's distance for population 9 of the
%   data set ``nancycats" with 1000 Bootstrap Replicates. Node labels represent
%   percentage of bootstrap replicates that contained that node.}
%   \label{bruvo_upgma}
% %  \includegraphics{bruvo_upgma.png}

% <<bruvo_tree, echo=FALSE, resolution=300>>=
%  set.seed(410)
%  nan9tree <- phangorn::upgma(bruvo.dist(popsub(nancycats, 8:9), replen = rep(1, 9)))
%  nan9tree$node.labels <- c(100, NA, NA, NA, NA, 64, NA, NA, NA, NA, NA, 80, NA,
%                            62, NA, 52, NA, NA)
%  nan9tree$tip.label <- indNames(popsub(nancycats, 8:9))
% #  ape::plot.phylo(nan9tree, show.node.label=TRUE)
% #  ape::axisPhylo(3)
%  poppr:::poppr.plot.phylo(nan9tree, "upgma")
% @

% \end{figure}
% \newpage
% \subsubsection{Function: greycurve}
% \label{index:trees:greycurve}
% \tab\tab Use this function to display a gradient of grey values based on user-
% defined parameters. The following functions will display a minimum spanning
% network that utilize a grey scale to display the weight of the lines (referred
% to as ``edges") that connect two or more individuals. The darker the line the
% closer the distance. Since this is based off of a linear grey scale, what
% happens when you have a distance matrix comprised of values all below 0.2 or all
% above 0.8?

% With linear grey scaling, it becomes very difficult to detect the differences in
% these ranges. The following function allows you to visualize and manipulate a
% gradient from black to white so that you can use it in \poppr{}'s msn functions
% below to maximize the visual differences in your data.

% \begin{quote}
% Default Command:
% <<greycurve_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "greycurve"
% print_command(funk)
% @
% % \texttt{greycurve(glim = c(0, 0.8), gadj = 3, gweight = 1)}
% \end{quote}


% This function does not return any values. It will print a visual gradient from
% black to white horizontally. On this gradient, it will plot the adjustment curve
% (in opposing grey values), yellow horizontal lines bounding the maximum and
% minimum values, and the equation used to calculate the correction in red. By
% default it will use a sequence from 1 to 0 to plot the curve, but you can use
% any sequence. Let's take 1000 random normal draws:

% <<greycurve_rnorm>>=
% set.seed(9999)
% xnorm <- rnorm(1000)
% @


% %\newpage
% First, we'll see what happens when we change the weight parameter.
% \begin{figure}[h!]
% \begin{minipage}[b]{0.45\linewidth}
% \centering
% \caption{\footnotesize Default for \texttt{greycurve()}, weighted for small
% values.}
% <<greycurve_normal, out.width='\\linewidth'>>=
% greycurve(xnorm)
% @
% \end{minipage}
% \hspace{0.5cm}
% \begin{minipage}[b]{0.45\linewidth}
% \centering
% \caption{\footnotesize weighting for large values.}
% <<greywidth_inverse, out.width='\\linewidth'>>=
% greycurve(xnorm, gweight = 2)
% @
% \end{minipage}
% \end{figure}

% If you change the adjustment parameter, \texttt{gadj}, the shape of the curve
% will change, and if you change the limit parameter, \texttt{glim}, the bounds of
% the curve will change.

% This function also will plot scalebars for use with minimum spanning networks
% produced in previous versions of poppr. Just use the scalebar argument and you
% will get a scalebar using the quantiles from the data and a scalebar with the
% data smoothed from the minimum to the maximum.

% \begin{figure}[h!]
% \begin{minipage}[b]{0.45\linewidth}
% \centering
% \caption{\footnotesize We can see that more data lies around zero (as expected
% with a random normal distribution)}
% <<greycurve_small_heavy, out.width='\\linewidth'>>=
% greycurve(xnorm, scalebar = TRUE)
% @
% \end{minipage}
% \hspace{0.5cm}
% \begin{minipage}[b]{0.45\linewidth}
% \centering
% \caption{\footnotesize Same as the figure on the left, but weighting heavily
% toward larger values.}
% <<greywidth_large_heavy, out.width='\\linewidth'>>=
% greycurve(xnorm, gweight=2, scalebar = TRUE)
% @
% \end{minipage}
% \end{figure}
% \newpage

% \subsubsection{Function: bruvo.msn}
% \label{index:trees:bruvo.msn}
% \tab\tab This function will automatically draw a minimum spanning network of
% MLGs based on Bruvo's distance. It's important to note that this will
% recalculate Bruvo's distance each time it is run, but the amount of time it
% takes to run is on the order of seconds. It will return a list containing the
% network, the populations and the related colors in the network so you can export
% or redraw it with the legend if you wanted to using the package \textit{igraph}
% (type \texttt{help("plot.igraph")} for details).
% \begin{quote}
% Default Command:
% <<bruvo.msn_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "bruvo.msn"
% print_command(funk)
% @
% % \texttt{bruvo.msn(pop, replen = 1, add = TRUE, loss = TRUE, palette = topo.colors,\\ 
% %   \tab sublist = "All", blacklist = NULL, vertex.label = "MLG", gscale = TRUE, \\
% %   \tab glim = c(0, 0.8), gadj = 3, gweight = 1, wscale = TRUE, ...)
% % }
% \end{quote}
% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object.
%   \item \texttt{replen -} see \texttt{bruvo.dist}, above.
%   \item \texttt{add -} For missing data: use the genome addition model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
%   \item \texttt{loss -} For missing data: use the genome loss model
%   (see \seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's
%   distance.})
%   \item \texttt{palette -} this is a \textbf{function} definining a color
%   palette to use. The default is \texttt{topo.colors}. There are different
%   palettes, which you can search by typing \texttt{?rainbow}. If you want a
%   custom color palette, an easy way is to use the function
%   \texttt{colorRampPalette}.
%   \item \texttt{sublist -} The populations you wish to analyze. This defaults to
%   ``All". See section \ref{data.manip:divide:popsub} for details.
%   \item \texttt{blacklist -} Populations you do not want to include in the
%   graph. See section \ref{data.manip:divide:popsub} for details.
%   \item \texttt{vertex.label -} This is an option that is passed on to
%   \textit{igraph}'s \texttt{plot} function. \Poppr{} has added two arguments
%   specific to \poppr{}. If you want to label the graph with the multilocus
%   genotypes from the whole data set, use the argument \texttt{vertex.label =
%   "mlg"}. If you want to display the representative individual names, you can
%   use the argument \texttt{vertex.label = "inds"}. I say representative
%   individual names because, only one representative from each MLG will be
%   present in the clone corrected data set used to calculate the distance. For no
%   labels, you can choose \texttt{vertex.label = NA}.
%   \item \texttt{gscale -} If this is set to \texttt{TRUE}, the edge color will
%   be converted to greyscale based on Bruvo's distance. If two nodes are closely
%   related, the edge will appear darker. The limits of the scale can be set by
%   the argument \texttt{glim}. If this is set to \texttt{FALSE}, all edge colors
%   will be black.
%   \item \texttt{glim -} This is a vector of numbers between 0 and 1. This lets
%   you set the limits of the grey scaling based on R's internal \texttt{grey}
%   function. For example, if you wanted a maximum of 50\% white saturation (for
%   use if you have distantly related nodes) and a minimum of 1\%, you would use
%   \texttt{glim = c(0.01, 0.5)}.
%   \item \texttt{gadj -} This is an integer greater than zero used to adjust the
%   scaling factor for the grey curve. Since very small changes in the grey scale
%   are not easily precieved, it's useful to be able to adjust the grey scale to
%   be able to show you the weights of each edge. For example, a population with
%   most weights less than 0.3, you might want to set \texttt{gadj = 10} to
%   exaggerate the grey scale.
%   \item \texttt{gweight -} If \texttt{gweight = 1}, the grey scale adjustment
%   will be weighted towards separating out smaller values of Bruvo's distance. If
%   \texttt{gweight = 2}, the grey scale ajustment will be weighted towards
%   separating out larger values of Bruvo's distance.
%   \item \texttt{wscale -} If this is set to \texttt{TRUE}, edge widths will be
%   displayed corresponding to Bruvo's distance in that thicker edges will
%   represent a smaller distance between nodes. If this is set to \texttt{FALSE},
%   all edges will be set to a width of 2.
%   \item \texttt{... -} This is a placeholder for any other arguments that you
%   want to supply to \textit{igraph}. Useful arguments are
%   \texttt{vertex.label.cex} to adjust the size of the labels,
%   \texttt{vertex.label.dist} to adjust the position of the labels, and
%   \texttt{vertex.label.color} to adjust the color of the labels.
% \end{itemize}

% Often, minimum spanning networks are the preferred way to visualize Bruvo's
% distance. \Poppr{} offers an easy way to plot these. For a demonstration, let's
% analyze a simulated data set of 50 individuals from populations that reproduce
% at a 99.9\% rate of clonal reproduction.

% <<bruvo_msn_code, eval=FALSE>>=
% data(partial_clone)
% set.seed(9005)
% pc.msn <- bruvo.msn(partial_clone, replen=rep(1, 10), vertex.label.cex=0.7, 
%           vertex.label.dist=-0.5, palette=colorRampPalette(c("blue", "yellow")))
% @
% \begin{figure}[ht!]
%   \centering
%   \caption{\footnotesize Minimum Spanning Network representing 4 simulated
%   populations. Each node represents a different multi locus genotype (MLG). Node
%   sizes and colors correspond to the number of individuals and population
%   membership, respectively. Edge thickness and color are proportional to Bruvo's
%   distance. Edge lengths are arbitrary.}
%   \label{mst_bruvo}
% <<bruvo_msn, resolution=300, echo=FALSE, out.width='0.8\\linewidth'>>=
% data(partial_clone)
% set.seed(9005)
% pc.msn <- bruvo.msn(partial_clone, replen=rep(1, 10), vertex.label.cex=0.7, 
%           vertex.label.dist=-0.5, palette=colorRampPalette(c("blue", "yellow")))
% @
% \end{figure}
% \setkeys{Gin}{width=0.5\textwidth}

% The output, as mentioned earlier, is a list containing the graph constructed via
% the \textit{igraph} package, a vector of the population names and a vector of
% colors representing the populations.
% <<bruvo_msn_igraph>>=
% library(igraph)
% pc.msn
% @

% Note that the thickness of the edges (the lines that are connecting the dots) is
% representative of relatedness between individuals, but the lengths do not
% necessarily mean anything due to the fact that with a larger data sets,
% displaying lengths proportional to relatedness would be impossible to draw on a
% 2D surface. Interpreting these data would show that MLG 9 has 5 individuals from
% all four populations and that it is most closely related to MLG 7, whereas the
% most distantly related connection exists between MLG 25 and MLG 26.

% %\newpage
% Since a graph can be represented in many ways, you might want to play around
% with different layouts using the \texttt{layout()} function in \textit{igraph}.
% Type \texttt{help("layout", package = igraph)} for details. Below is the code
% for reconstructing the previous graph using the output:
% <<bruvo_msn_reconstruct, eval=FALSE>>=
% set.seed(9005)
% library(igraph)
% plot(pc.msn$graph, vertex.size = V(pc.msn$graph)$size * 3, 
%      vertex.label.cex=0.7, vertex.label.dist=-0.5,)
% legend(-1.55, 1, bty = "n", cex = 0.75, legend = pc.msn$populations, 
%        title = "Populations", fill = pc.msn$colors, border = NULL)
% @

% \subsubsection{Function: poppr.msn}
% \label{index:trees:poppr.msn}

% \tab\tab Use this function to draw a minimum spanning network from your data set
% and a distance matrix derived from your data set. Since there are hundreds of
% distances that can be calculated for genetic data, and since I want to be able
% to graduate at some point in this decade, functions to automatically calculate
% distances and draw the minimum spanning networks will be few and far between.
% This function is an attempt to meet the user halfway and draw a minimum spanning
% network provided that the user has supplied two things:
% \begin{enumerate}
%   \item A distance matrix over all individuals.
%   \item The original data set containing demographic information.
% \end{enumerate}

% That's it. For the most part, this function is functionally the same as
% \texttt{bruvo.msn}, except that instead of being exclusive to microsatellite
% markers, you can now visualize distances in any marker type provided that you
% have the two items listed above.

% \begin{quote}
% Default Command:
% <<poppr.msn_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "poppr.msn"
% print_command(funk)
% @
% % \texttt{poppr.msn(pop, distmat, palette = topo.colors, sublist = "All",\\ 
% %   \tab blacklist = NULL, vertex.label = "MLG", gscale = TRUE, glim = c(0, 0.8),\\ 
% %   \tab gadj = 3, gweight = 1, wscale = TRUE, ...)
% % }
% \end{quote}
% \begin{itemize}
%   \item \texttt{pop -} a \texttt{genind} object.
%   \item \texttt{distmat -} a dissimilarity distance matrix derived from your data with distances between zero and one.
%   \item \texttt{palette -} this is a \textbf{function} definining a color
%   palette to use. The default is \texttt{topo.colors}. There are different
%   palettes, which you can search by typing \texttt{?rainbow}. If you want a
%   custom color palette, an easy way is to use the function
%   \texttt{colorRampPalette}.
%   \item \texttt{sublist -} The populations you wish to analyze. This defaults to
%   ``All".
%   \item \texttt{blacklist -} Populations you do not want to include in the
%   graph.
%   \item \texttt{vertex.label -} This is an option that is passed on to
%   \textit{igraph}'s \texttt{plot} function. \Poppr{} has added two arguments
%   specific to \poppr{}. If you want to label the graph with the multilocus
%   genotypes from the whole data set, use the argument \texttt{vertex.label =
%   "mlg"}. If you want to display the representative individual names, you can
%   use the argument \texttt{vertex.label = "inds"}. I say representative
%   individual names because, only one representative from each MLG will be
%   present in the clone corrected data set used to calculate the distance. For no
%   labels, you can choose \texttt{vertex.label = NA}.
%   \item \texttt{gscale -} If this is set to \texttt{TRUE}, the edge color will
%   be converted to greyscale based on the distance. If two nodes are closely
%   related, the edge will appear darker. The limits of the scale can be set by
%   the argument \texttt{glim}. If this is set to \texttt{FALSE}, all edge colors
%   will be black.
%   \item \texttt{glim -} This is a vector of numbers between 0 and 1. This lets
%   you set the limits of the grey scaling based on R's internal \texttt{grey}
%   function. For example, if you wanted a maximum of 50\% white saturation (for
%   use if you have distantly related nodes) and a minimum of 1\%, you would use
%   \texttt{glim = c(0.01, 0.5)}.
%   \item \texttt{gadj -} This is an integer greater than zero used to adjust the
%   scaling factor for the grey curve. Since very small changes in the grey scale
%   are not easily precieved, it's useful to be able to adjust the grey scale to
%   be able to show you the weights of each edge. For example, a population with
%   most weights less than 0.3, you might want to set \texttt{gadj = 10} to
%   exaggerate the grey scale.
%   \item \texttt{gweight -} If \texttt{gweight = 1}, the grey scale adjustment
%   will be weighted towards separating out smaller values of the distance. If
%   \texttt{gweight = 2}, the grey scale ajustment will be weighted towards
%   separating out larger values of Bruvo's distance.
%   \item \texttt{wscale -} If this is set to \texttt{TRUE}, edge widths will be
%   displayed corresponding to Bruvo's distance in that thicker edges will
%   represent a smaller distance between nodes. If this is set to \texttt{FALSE},
%   all edges will be set to a width of 2.
%   \item \texttt{... -} This is a placeholder for any other arguments that you
%   want to supply to \textit{igraph}. Useful arguments are
%   \texttt{vertex.label.cex} to adjust the size of the labels,
%   \texttt{vertex.label.dist} to adjust the position of the labels, and
%   \texttt{vertex.label.color} to adjust the color of the labels.
% \end{itemize}

% Since we have the ability, let's visualize the \textit{A. euteiches} data set
% \cite{Grunwald:2006}.
% <<poppr_msn, eval=FALSE>>=
% data(Aeut)
% A.dist <- diss.dist(Aeut)
% set.seed(9005)
% A.msn <- poppr.msn(Aeut, A.dist, vertex.label=NA, palette=rainbow, gadj=15)
% @

% \begin{figure}[ht!]
%   \centering
%   \caption{\footnotesize Minimum Spanning Network representing 4 simulated
%   populations. Each node represents a different multi locus genotype (MLG). Node
%   sizes and colors correspond to the number of individuals and population
%   membership, respectively. Edge thickness and color are proportional to Bruvo's
%   distance. Edge lengths are arbitrary.}
%   \label{mst_poppr}
% <<poppr_msn_fig, resolution=300, echo=FALSE, out.width='0.8\\linewidth'>>=
% data(Aeut)
% A.dist <- diss.dist(Aeut)
% set.seed(9005)
% A.msn <- poppr.msn(Aeut, A.dist, vertex.label=NA, palette=rainbow, gadj=15)
% @
% \end{figure}
% \newpage
% %\subsubsection{Gory details} 
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %=============================================================================%
% %=============================================================================%
% %
% %
% %
% %=============================================================================%
% %=============================================================================%
% \section{Diversity table \{I know what you did last summary table\}}
% \label{summary}

% \tab\tab Remember the summary function that you used to get all the diversity
% statistics in section \ref{intro:qstart}? In this section, we will flesh out all
% that you can do with this function. This was the very first function that was
% written for \poppr{} to make it easy for the user to manipulate and summarize
% the data in one function.
% %-----------------------------------------------------------------------------%
% %
% %-----------------------------------------------------------------------------%
% \subsection{Function: poppr}
% \label{summary:poppr}

% \tab\tab This function is quite daunting with all its possibilities. You have
% the option to subset your data for specific populations, correct for missing
% data, and clone correct. With each of these possibilities, comes the need to
% provide all the arguments for their various functions.
% \begin{quote}
% Default Command:
% <<poppr_command, echo = FALSE, comment = NA, size = 'normalsize'>>=
% funk <- "poppr"
% print_command(funk)
% @
% % \texttt{poppr(pop, total = TRUE, sublist = c("ALL"), blacklist = c(NULL), sample = 0,\\ 
% %         \tab method = 1, missing = "ignore", cutoff = 0.05, quiet = FALSE, \\
% %         \tab clonecorrect = FALSE, hier = c(1), dfname = "population\_hierarchy", \\
% %         \tab hist = TRUE, minsamp = 10)}
% \end{quote}
% \begin{itemize}
%   \item \texttt{dat -} A \texttt{genind} object, \texttt{genclone} object, or a
%   path to a file on your machine that contains genetix, structure, fstat,
%   genpop, or genalex formatted data.
%   \item \texttt{total -} This is also a synonym for ``pooled". This will
%   calculate all diversity statistics on the entire data set if set to
%   \texttt{TRUE} or if there is no population structure.
%   \item \emph{popsub functions:} See section \ref{data.manip:divide}
%   \begin{description}
%     \item[sublist -] A list of populations you want to include in your analysis.
%     \item[blacklist -] A list of populations you want to exclude from your
%     analysis.
%   \end{description}
%   \item \emph{shufflepop functions:} See section \ref{data.manip:shuffle} \\
%   Note that this only affects the calculation for $I_A$ and $\bar r_d$.
%   \begin{description}
%     \item[sample -] The number of samples you desire (eg. 999)
%     \item[method -] Which sampling method? 1: permute, 2: parametric bootstrap,
%     3: non-parametric bootstrap, 4: multilocus.
%   \end{description}
%   \item \emph{missingno functions:} See Section \ref{data.manip:missing} \\ Note
%   that all analyses in this function ignore/impute missing data by default.
%     \begin{description}
%       \item[missing -] How to deal with missing data. This feeds into the
%       \texttt{type} flag of \texttt{missingno}.
%       \item[cutoff -] Allowable percentage of missing data per genotype or
%       locus.
%     \end{description}
%   \item \texttt{quiet -} If set to \texttt{TRUE}, nothing will be printed to the
%   screen as the sampling progresses. If \texttt{FALSE} (default) a progress bar
%   will be produced.
%   \item \emph{clonecorrect functions:} See section \ref{data.manip:cc}
%   \begin{description}
%     \item[clonecorrect -] if this is set to \texttt{TRUE}, then you will need to
%     set the next two parameters.
%     \item[hier -] A list of the population hierarchy, or names of columns in the
%     data frame noted below.
%     \item[dfname -] A data frame in the \texttt{@other} slot of the
%     \texttt{genind} object containing all of the population factors in different
%     columns. For an example, see sections \ref{data.manip:hier} and
%     \ref{data.manip:cc}.
%     \item[keep -] A vector of integers as indexes for the \texttt{hier} flag
%     indicating which levels of the hierarchy you want to analyze. See section
%     \ref{data.manip:cc} for details.
%   \end{description}
%   \item \texttt{hist -} if \texttt{TRUE}, a histogram of distributions of $I_A$
%   and $\bar r_d$ will be displayed with each population if there is sampling.
%   \item \texttt{minsamp -} The minimum number of individuals you want to use to
%   calculate the expected number of MLGs. The default is set to 10.
% \end{itemize}

% This function produces a table that contains the population name, number of
% individuals observed, number of MLGs observed, number of MLGs expected at the
% lowest common sampling size within the data set \cite{Hurlbert:1971}
% \cite{Heck:1975}, the Shannon-Wiener index \cite{Shannon:1948}, Stoddart and
% Taylor's index for expected MLGs \cite{Stoddart:1988}, Nei's 1987 genotypic
% diversity \cite{Nei:1978}, evenness
% \cite{Pielou:1975}\cite{Ludwig:1988}\cite{Grunwald:2003}, the index of
% association \cite{Brown:1980}\cite{Smith:1993}, the standardized index of
% association \cite{Agapow:2001}, and the file name. Most of these indices are
% calculated by converting the population into an MLG table with
% \texttt{mlg.table} (see section \ref{mlg:table}) and using the \textit{vegan}
% package's \texttt{diversity} function (To see details, type
% \texttt{?vegan::diversity} into the R console).

% To begin, let's revisit our example data set of \textit{Aphanomyces euteiches}
% \cite{Grunwald:2006}.
% <<Aeut_rehash>>=
% data(Aeut)
% poppr(Aeut)
% @
% OK, so we were able to get a table out of this. Now let's see what happens when
% we do some sampling to see if this is reproducing clonally or not. We will turn
% quiet on and the histogram off to save space.
% <<Aeut_sample, eval=FALSE>>=
% poppr(Aeut, sample=999, hist=FALSE, quiet=TRUE)
% @
% <<Aeut_sample_show, echo=FALSE>>=
% none1 <- poppr(Aeut, hist=FALSE, quiet=TRUE)
% cbind(none1[1:10],list(p.Ia = rep(0.001, 3)), none1[11], list(p.rD = rep(0.001, 3)), none1[12])
% @
% From now on, we'll set \texttt{quiet = TRUE} to save space on our vignette.
% Let's clone correct at different levels to see if that affects the index of
% association. First, we'll clone correct at the sub population level.
% <<Aeut_cc_sub_show, eval=FALSE>>=
% poppr(Aeut, sample=999, clonecorrect=TRUE, hier=c("Pop","Subpop"), 
%       dfname="population_hierarchy", quiet=TRUE, hist=FALSE)
% @
% <<Aeut_cc_sub, echo=FALSE>>=
% sub1 <- poppr(Aeut, clonecorrect=TRUE, hier=c("Pop","Subpop"), dfname="population_hierarchy", quiet=TRUE, hist=FALSE)
% cbind(sub1[1:10],list(p.Ia = rep(0.001, 3)), sub1[11], list(p.rD = rep(0.001, 3)), sub1[12])
% @
% And at the population level.
% <<Aeut_cc_pop_show, eval=FALSE>>=
% poppr(Aeut, sample=999, clonecorrect=TRUE, hier="Pop", 
%       dfname="population_hierarchy", quiet=TRUE, hist=FALSE)
% @
% <<Aeut_cc_pop, echo=FALSE>>=
% pop1 <- poppr(Aeut, sample=0, clonecorrect=TRUE, hier="Pop", dfname="population_hierarchy", quiet=TRUE, hist=FALSE)
% cbind(pop1[1:10],list(p.Ia = rep(0.001, 3)), pop1[11], list(p.rD = rep(0.001, 3)), pop1[12])
% @
% As you can see, clone correction doesn't always have to involve creation of new
% data sets!

% You might notice that the P-values for both $I_A$ and $\bar r_d$ are often equal
% to each other. This will always be the case with the sampling method utilized in
% method 4 \cite{Agapow:2001}. Here, we show examples where they are not equal and
% why it's okay.
% <<nancy_example_show, eval=FALSE>>=
% set.seed(2002)
% poppr(nancycats, sublist=5:6, total=FALSE, sample=999, method=2, quiet=TRUE, hist=FALSE)
% @
% <<nancy_example_eval, echo=FALSE>>=
% set.seed(2001)
% nan_ex <- poppr(nancycats, sublist=5:6, total=FALSE, sample=0, method=2, quiet=TRUE, hist=FALSE)
% cbind(nan_ex[1:10],list(p.Ia = c(0.576, 0.070), nan_ex[11], list(p.rD = c(0.576, 0.071), nan_ex[12])))
% @
% The reason why the P-values would be different is described at the end of
% section \ref{index:iard:ia}. The differences in P-values are normally not very
% far off. It's important to note this because of what can happen in extremely
% clonal populations. You can end up with a large enough sample size consisting of
% very few MLGs. Upon shuffling using method 4, you find that there are very few
% values of $I_A$ and $\bar r_d$ that can be obtained. Observe with this simulated
% data set:
% <<simulated_dist, eval=FALSE>>=
% set.seed(2004)
% poppr(system.file("files/simulated.dat", package="poppr"), sample=999, method=4, quiet=TRUE)
% @
% <<simulated_dist_out, echo=FALSE>>=
% set.seed(2004)
% sim_ex <- poppr(system.file("files/simulated.dat", package="poppr"), sample=0, method=4, quiet=TRUE, hist=FALSE)
% cbind(sim_ex[1:10],list(p.Ia = c(0.09), sim_ex[11], list(p.rD = c(0.09), sim_ex[12])))
% @

% Take a look a these two histograms. The number of ways you can recombine the
% data with the default sampling method is very small. Other sampling methods
% could give a more theoretical distribution. Let's try the parametric bootstrap
% (For details, see section \ref{data.manip:shuffle}).

% \begin{figure}[h!]
% \begin{minipage}[b]{0.5\linewidth}
% \centering
% \caption{\footnotesize Output of multilocus-style sampling. Note the multimodal distribution.}
%   \label{simulated_dist_fig}
%   \includegraphics{simulated_dist_fig.pdf}
% \end{minipage}
% \hspace{0.5cm}
% \begin{minipage}[b]{0.5\linewidth}
% \centering
%   \caption{\footnotesize Output for parametric bootstrap sampling.}
%   \label{simulated_param_fig}
%   \includegraphics{simulated_param_fig.pdf}
% \end{minipage}
% \end{figure}





% % \begin{figure}[h!]
% %   \centering
% %   \caption{\footnotesize Output of multilocus-style sampling. Note the multi-
% %   modal distribution.}
% %   \label{simulated_dist_fig}
% %   \includegraphics{simulated_dist_fig.png}
% % % <<fig=TRUE, echo=FALSE, resolution=300, figs.only=TRUE, width=8, height=8>>=
% % % set.seed(2004)
% % % der <- poppr(system.file("files/simulated.dat", package="poppr"), sample=999, method=1, quiet=TRUE, hist=TRUE)
% % % @
% % \end{figure}
% % \newpage


% % \begin{figure}[h!]
% %   \centering
% %   \caption{\footnotesize Output for parametric bootstrap sampling.}
% %   \label{simulated_param_fig}
% %   \includegraphics{simulated_param_fig.png}
% % % <<fig=TRUE, echo=FALSE, resolution=300, figs.only=TRUE, width=8, height=8>>=
% % % set.seed(2004)
% % % der <- poppr(system.file("files/simulated.dat", package="poppr"), sample=999, method=3, quiet=TRUE)
% % % @
% % \end{figure}

% As you can see, the distribution is much closer to a distribution we would
% expect if this were a small sample of a larger population.


%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Appendix}
\label{appendix}

\subsection{General hierarchy method use}
\label{appendix:hier:method}

\tab\tab To reiterate, there are currently 5 methods that manipulate population
hierarchies in genclone objects:
% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sat Mar 22 20:24:23 2014
\begin{table}[ht]
\centering
\begin{tabular}{llll}
  \hline
 Method & Function & Input & Result\\ 
  \hline
 split & \cmdlink{data.manip:hier:define:split}{splithierarchy} & formula & defined hierarchical levels\\
 set & \cmdlink{data.manip:hier:define:set}{sethierarchy} & data frame & new hierarchy\\ 
 get & \cmdlink{data.manip:hier:view}{gethierarchy} & formula & data frame\\ 
 name & \cmdlink{data.manip:hier:manip:name}{namehierarchy} & formula & new hierarchy names\\ 
 add & \cmdlink{data.manip:hier:manip:add}{addhierarchy} & vector or data frame & new hierarchical level\\
   \hline
\end{tabular}
\end{table}
\noindent
NOTE: Refer to \seclink{intro:genclone:access}{Accessing hierarchies} for more
details on how to access hierarchies.\\

These functions all have a syntax that looks like this:
<<hier_syntax, eval = FALSE>>=
newobject <- FUNCTION(object, input)
@
Let's take a data set of \textit{Phytophthora infestans} collected from North
America and South America and use that as an example. It has two population
hierarchies defined, Continent and Country:
<<Pinf_load>>=
data(Pinf)
Pinf
@
\noindent
Let's say I wanted to change the hierarchy names to Spanish. I can do that using
\texttt{namehierarchy}.
<<Pinf_rename>>=
elPinf <- namehierarchy(Pinf, ~continente/pais) # Don't forget the formula syntax!
elPinf
Pinf
@
\noindent
The original data set has stayed the same and we now have a new data set with
the names we want.

Of course, it would be silly to create a new data set every time we wanted to do
something like change names. This is why all of the above functions (with the
exception of \texttt{gethierarchy}) all have the replacement syntax of:
<<hier_syntax_replace, eval = FALSE>>=
FUNCTION(object) <- input
@
\noindent
\textbf{NOTE: This is the preferred syntax}.\\ 
\noindent
This allows the object to be edited \textit{in place} and makes things generally
easier. Let's revisit our previous example:
<<Pinf_replace>>=
Pinf
namehierarchy(Pinf) <- ~continente/pais
Pinf
@
While we will mainly be using the replacement syntax in this vignette, the 
advantage to having both systems is that with the 
\texttt{function(object, input)} syntax, you can test manipulation without 
affecting your object.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
% \subsection{Algorithmic Details}
% \label{appendix:algorithm}
% \subsubsection{$I_A$ and $\bar r_d$}
% \label{appendix:algorithm:iard}

% \tab \tab The index of association was originally developed by A.H.D. Brown
% analyzing population structure of wheat \cite{Brown:1980}. It has been widely
% used as a tool to detect clonal reproduction within populations
% \cite{Smith:1993}. Populations whose members are undergoing sexual reproduction,
% whether it be selfing or out-crossing, will produce gametes via meiosis, and
% thus have a chance to shuffle alleles in the next generation. Populations whose
% members are undergoing clonal reproduction, however, generally do so via
% mitosis. This means that the most likely mechanism for a change in genotype is
% via mutation. The rate of mutation varies from species to species, but it is
% rarely sufficiently high to approximate a random shuffling of alleles. The index
% of association is a calculation based on the ratio of the variance of the raw
% number of differences between individuals and the sum of those variances over
% each locus \cite{Smith:1993}. You can also think of it as the observed variance
% over the expected variance. If they  are the same, then the index is zero after
% subtracting one (from Maynard-Smith, 1993 \cite{Smith:1993}):
% \begin{equation}
% \label{eq:I_A}
% I_A = \frac{V_O}{V_E}-1
% \end{equation}
% Since the distance is more or less a binary distance, any sort of marker can be
% used for this analysis. In the calculation, phase is not considered, and any
% difference increases the distance between two individuals. Consider the
% genotypes of the dummy data frame we created earlier:
% <<echo=FALSE>>=
% df <- data.frame(list(locus1=c("101/101", "102/103", "102/102"), 
%                       locus2=c("201/201", "202/203", "203/204"), 
%                       locus3=c("301/302", "301/303", "304/305")))
% df
% @
% Now, consider the first locus represented in the genind object:
% <<echo=FALSE>>=
% dfg <- df2genind(df, sep="/")
% dfg@tab[, 1:3]
% @
% Remember that each column represents a different allele and that each entry in
% the table represents the fraction of the genotype made up by that allele at that
% locus. Notice also that the sum of the rows all equal one. \Poppr{} uses this to
% calculate distances by simply taking the sum of the absolute values of the
% differences between rows.

% The calculation for the distance between two individuals at a single locus with
% $a$ allelic states and a ploidy of $k$ is as follows\footnote{Individuals with
% Presence / Absence data will have the $k/2$ term dropped.}:
% \begin{equation}
% \label{eq:ia_d}
% d = \displaystyle \frac{k}{2}\sum_{i=1}^{a} \mid ind_{Ai} - ind_{Bi}\mid
% \end{equation}
% <<>>=
% abs(dfg@tab[1, 1:3] - dfg@tab[2, 1:3])
% abs(dfg@tab[1, 1:3] - dfg@tab[3, 1:3])
% abs(dfg@tab[2, 1:3] - dfg@tab[3, 1:3])
% @
% As you can see, these values of $d$ at locus one add up to 2, 2, and 1, respectively.

% To find the total number of differences between two individuals over all loci,
% you just take $d$ over $m$ loci, a value we'll call $D$:

% \begin{equation}
% \label{eq:ia_D}
% D = \displaystyle \sum_{i=1}^{m} d_i
% \end{equation}

% These values are calculated over all possible combinations of individuals in the
% data set, ${n \choose 2}$ after which you end up with ${n \choose 2}\cdot{} m$
% values of $d$ and ${n \choose 2}$ values of $D$. Calculating the observed
% variances is fairly straightforward (modified from Agapow and Burt, 2001)
% \cite{Agapow:2001}:

% \begin{equation}
% \label{eq:V_O}
% V_O = \frac{\displaystyle \sum_{i=1}^{n \choose 2} D_{i}^2 - \frac{(\displaystyle\sum_{i=1}^{n \choose 2} D_{i})^2}{{n \choose 2}}}{{n \choose 2}}
% \end{equation}

% Calculating the expected variance is the sum of each of the variances of the
% individual loci. The calculation at a single locus, $j$ is the same as the
% previous equation, substituting values of $D$ for $d$ \cite{Agapow:2001}:

% \begin{equation}
% \label{eq:var_j}
% var_j = \frac{\displaystyle \sum_{i=1}^{n \choose 2} d_{i}^2 - \frac{(\displaystyle\sum_{i=1}^{n \choose 2} d_i)^2}{{n \choose 2}}}{{n \choose 2}}
% \end{equation}

% The expected variance is then the sum of all the variances over all $m$ loci
% \cite{Agapow:2001}:

% \begin{equation}
% \label{eq:V_E}
% V_E = \displaystyle \sum_{j=1}^{m} var_j
% \end{equation}

% Now you can plug the sums of equations (\ref{eq:V_O}) and (\ref{eq:V_E}) into
% equation (\ref{eq:I_A}) to get the index of association. Of course, Agapow and
% Burt showed that this index increases steadily with the number of loci, so they
% came up with an approximation that is widely used, $\bar r_d$
% \cite{Agapow:2001}. For the derivation, see the manual for \textit{multilocus}.
% The equation is as follows, utilizing equations (\ref{eq:V_O}),
% (\ref{eq:var_j}), and (\ref{eq:V_E}) \cite{Agapow:2001}:

% \begin{equation}
% \label{eq:r_d}
% \bar{r_d} = \frac{V_O - V_E}
% {2\displaystyle \sum_{j=1}^{m}\displaystyle \sum_{k \neq j}^{m}\sqrt{var_j\cdot{} var_k}}
% \end{equation}

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsubsection{Bruvo's distance}
% \label{appendix:algorithm:bruvo}

% \tab \tab Bruvo's distance between two individuals calculates the minimum
% distance across all combinations of possible pairs of alleles at a single locus
% and then averaging that distance across all loci \cite{Bruvo:2004}. The distance
% between each pair of alleles is calculated as \cite{Bruvo:2004}:

% \begin{equation}
% \label{eq:m_x}
% m_x = 2^{-\mid x \mid}
% \end{equation}

% \begin{equation}
% \label{eq:d_a}
% d_a = 1 - m_x
% \end{equation}

% Where $x$ is the number of steps between each allele. So, let's say we were
% comparing two haploid $(k = 1)$ individuals with alleles 228 and 244 at a locus
% that had a tetranucleotide repeat pattern (CATG$)^n$. The number of steps for
% each of these alleles would be $228/4 = 57$ and $244/4 =61$, respectively. The
% number of steps between them is then $\mid 57 - 61 \mid = 4$. Bruvo's distance
% at this locus between these two individuals is then $1-2^{-4} = 0.9375$. For
% samples with higher ploidy ($k$), there would be $k$ such distances of which we
% would need to take the sum \cite{Bruvo:2004}.

% \begin{equation}
% \label{eq:s_i}
% s_i = \displaystyle \sum_{a=1}^{k} d_a
% \end{equation}

% Unfortunately, it's not as simple as that since we do not assume to know phase.
% Because of this, we need to take all possible combinations of alleles into
% account. This means that we will have $k^2$ values of $d_a$, when we only want
% $k$. How do we know which $k$ distances we want? We will have to invoke
% parsimony for this and attempt to take the minimum sum of the alleles, of which
% there are $k!$ possibilities \cite{Bruvo:2004}:

% \begin{equation}
% \label{eq:d_l}
% d_l = \frac{\left(\displaystyle \min_{i \dotsc k!} s_i\right)}{k}
% \end{equation}

% Finally, after all of this, we can get the average distance over all loci
% \cite{Bruvo:2004}.

% \begin{equation}
% \label{eq:D}
% D = \frac{\displaystyle \sum_{i=1}^l d_i}{l}
% \end{equation}

% This is calculated over all possible combinations of individuals and results in
% a lower triangle distance matrix over all individuals.

% \subsubsection{Special Cases of Bruvo's distance}
% \label{appendix:algorithm:bruvospecial}
% \tab\tab As shown in the above section, ploidy is irrelevant with respect to
% calculation of Bruvo's distance. However, since it makes a comparison between
% all alleles at a locus, it only makes sense that the two loci need to have the
% same ploidy level. Unfortunately for polyploids, it's often difficult to fully
% separate distinct alleles at each locus, so you end up with genotypes that
% appear to have a lower ploidy level than the organism \cite{Bruvo:2004}.

% To help deal with these situatons, Bruvo has suggested three methods for dealing
% with these differences in ploidy levels \cite{Bruvo:2004}:
% \begin{itemize}
%   \item{Infinite Model -} The simplest way to deal with it is to count all
%   missing alleles as infinitely large so that the distance between it and
%   anything else is 1. Aside from this being computationally simple, it will tend
%   to inflate distances between individuals.
%   \item{Genome Addition Model -} If it is suspected that the organism has gone
%   through a recent genome expansion, the missing alleles will be replace with
%   all possible combinations of the observed alleles in the shorter genotype. For
%   example, if there is a genotype of [69, 70, 0, 0] where 0 is a missing allele,
%   the possible combinations are: [69, 70, 69, 69], [69, 70, 69, 70], and [69,
%   70, 70, 70]. The resulting distances are then averaged over the number of
%   comparisons.
%   \item{Genome Loss Model -} This is similar to the genome addition model,
%   except that it assumes that there was a recent genome reduction event and uses
%   the observed values in the full genotype to fill the missing values in the
%   short genotype. As with the Genome Addition Model, the resulting distances are
%   averaged over the number of comparisons.
%   \item{Combination Model -} Combine and average the genome addition and loss
%   models.
% \end{itemize}

% As mentioned above, the infinite model is biased, but it is not nearly as
% computationally intensive as either of the other models. The reason for this is
% that both of the addition and loss models requires replacement of alleles and
% recalculation of Bruvo's distance. The number of replacements required is equal
% to the multiset coefficient: $\left({n \choose k}\right) == {(n-k+1) \choose k}$
% where $n$ is the number of potential replacements and $k$ is the number of
% alleles to be replaced. So, for the example given above, The genome addition
% model would require $\left({2 \choose 2}\right) = 3$ calculations of Bruvo's
% distance, whereas the genome loss model would require $\left({4 \choose
% 2}\right) = 10$ calculations.

% To reduce the number of calcuations and assumptions otherwise, Bruvo's distance
% will be calculated using the largest observed ploidy. This means that when
% comparing [69,70,71,0] and [59,60,0,0], they will be treated as triploids.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Manipulating Graphics}

\Poppr{} utilizes \textit{ggplot2} to produce many of its graphs. One advantage
it gives the user is the ability to manipulate these graphs. With base R graphs,
the only manipulation that can be performed is by adding elements to the graph.
It is a static image. The ggplot graphs are actually represented as objects in
your R environment. We can use the function \texttt{last\_plot()} from
\textit{ggplot2} to be able to grab the plot that was plotted last in our
window. Let's illustrate this using a MLG bar graph from the Athena population
of the Aeut data set.

<<Aeut_MLG_Ahena>>=
library(poppr)
library(ggplot2)
data(Aeut)
Athena.tab <- mlg.table(Aeut, sublist = "Athena")
p <- last_plot()
@

We've captured our plot using \texttt{last\_plot()} and now we can manipulate
it. Let's say we didn't like the scale going from blue to black and we wanted
make it monotone without a color guide. (NOTE: the () around
the call allows us to show the result immediately.)

<<Aeut_MLG_black>>=
(pb <- p + scale_fill_continuous(low = "black", high = "black", guide = "none"))
@

We could also change the title

<<Aeut_MLG_title>>=
(pbt <- pb + ggtitle("Distribution of multilocus genotypes for the Athena population")) + xlab("Multilocus genotype")
@

This allows you to produce publication quality graphs directly in R. Please see
Hadley Wickham's \textit{ggplot2} package for more details \cite{ggplot2}. Note
that if you don't like using \textit{ggplot2}, you can access the data in the
ggplot2 object and plot the data yourself:

<<Aeut_MLG_data>>=
head(p$data)
@


%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Exporting Graphics}
\label{appendix:graphics}
\tab\tab R has the ability to produce nice graphics from most any type of data,
but to get these graphics into a report, presentation, or manuscript can be a
bit challenging. It's no secret that the R Documentation pages are a little
difficult to interpret, so I will give the reader here a short example on how to
export graphics from R. Note that any code here that will produce images will
also be present in other places in this vignette. The default installation of
the R GUI is quite minimal, and for an easy way to manage your plots and code, I
strongly encourage the user to use Rstudio \url{http://www.rstudio.com/}.

\subsubsection{Basics}
\label{appendix:graphics:basics}
\tab\tab Before you export graphics, you have to ask yourself what they will be
used for. If you want to use the graphic for a website, you might want to opt
for a low-resolution image so that it can load quickly. With printing, you'll
want to make sure that you have a scalable or at least a very high resolution
image. Here, I will give some general guidelines for graphics (note that these
are merely suggestions, not defined rules).
\begin{itemize}
  \item \textbf{What you see is not always what you get} I have often seen
  presentations where the colors were too light or posters with painfully
  pixellated graphs. Think about what you are going to be using a graphic for
  and how it will appear to the intended audience given the media type.
  \item \textbf{$\geq$ 300 dpi unless its for a web page} For any sort of
  printed material that requires a raster based image, 300dpi (dots per inch) is
  the absolute minimum resolution you should use. For simple black and white
  line images, 1200dpi is better. This will leave you with crisp, professional
  looking images.
  \item \textbf{If possible, save to SVG, then rasterize} Raster images (bmp,
  png, jpg, etc...) are based off of the number of pixels or dots per inch it
  takes to render the image. This means that the raster image is more or less a
  very fine mosaic. Vector images (SVG) are built upon several interconnected
  polygons, arcs, and lines that scale relative to one another to create your
  graphic. With vector graphics, you can produce a plot and scale it to the size
  of a building if you wanted to. When you save to an SVG file first, you can
  also manipulate it in programs such as Adobe Illustrator or Inkscape.
  \item \textbf{Before saving, make sure the units and dimensions are correct}
  Unless you really wanted to save a graph that's over 6 feet wide.
\end{itemize}

\subsubsection{Image Editors}
\label{appendix:graphics:editors}
\tab\tab Often times, fine details such as labels on networks need to be tweaked
by hand. Luckily, there are a wide variety of programs that can help you do
that. Here is a short list of image editors (both free and for a price) that you
can use to edit your graphics.
\begin{itemize}
  \item Bitmap based editors (for jpeg, bmp, png, etc...)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape The GIMP ] Free, cross-platform. \url{http://www.gimp.org}
    \item[ \scshape Paint.net ] Free, Windows only.
    \url{http://www.getpaint.net}
    \item[ \scshape Adobe Photoshop ] Pricey, Windows and Mac.
    \url{http://www.adobe.com/products/photoshop.html}
  \end{itemize}
  \end{quote}
  \item Scalable Vector Graphics based editors (for svg, pdf)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape Inkscape ] Free, cross-platform \url{http://inkscape.org}
    \item[ \scshape Adobe Illustrator ] Pricey, Windows and Mac.
    \url{http://www.adobe.com/products/illustrator.html}
  \end{itemize}
  \end{quote}
\end{itemize}

\subsubsection{Exporting ggplot2 graphics}
\label{appendix:graphics:ggplot2}
\tab\tab \textit{ggplot2} is a fantastic package that \poppr{} uses to produce
graphs for the \texttt{mlg.table}, \texttt{poppr}, and \texttt{ia} functions.
Saving a plot with \textit{ggplot2} is performed with one command after your
plot has rendered:
<<ggsave1, eval=FALSE>>=
data(nancycats) # Load the data set.
poppr(nancycats, sublist=5, sample=999) # Produce a single plot.
ggsave("nancy5.pdf")
@
Note that you can name the file anything, and \texttt{ggsave} will save it in
that format for you. The details are in the documentation and you can access it
by typing \texttt{help("ggsave")} in your R console. The important things to
note are that you can set a \texttt{width}, \texttt{height}, and \texttt{unit}.
The only downside to this function is that you can only save one plot at a time.
If you want to be able to save multiple plots, read on to the next section.

\subsubsection{Exporting any graphics}
\label{appendix:graphics:export}
\tab\tab Some of the functions that \poppr{} offers will give you multiple
plots, and if you want to save them all, using \texttt{ggsave} will require a
lot of tedious typing and clicking. Luckily, R has Functions that will save any
plot you generate in nearly any image format you want. You can save in raster
images such as png, bpm, and jpeg. You can also save in vector based images such
as svg, pdf, and postscript. The important thing to remember is that when you
are saving in a raster format, the default units of measurement are ``pixels",
but you can change that by specifying your unit of choice and a resolution.

For raster images and svg files, you can only save your plots in multiple files,
but pdf and postscript plots can be saved in one file as multiple pages. All of
these functions have the same basic form. You call the function to specify the
file type you want (eg. \texttt{pdf("myfile.pdf")}), create any graphs that you
want to create, and then make sure to close the session with the function
\texttt{dev.off()}. Let's give an example saving to pdf and png files.

<<png_save, eval=FALSE>>=
data(H3N2)
pop(H3N2) <- H3N2$other$x$country
####
png("H3N2_barchart%02d.png", width = 14, height = 14, units = "in", res = 300)
H.tab <- mlg.table(H3N2)
dev.off()
####
@

Since this data set is made up of 30 populations with more than 1 individual,
this will save 30 files to your working directory named
``H3N2\_barchart01.png...H3N2\_barchart30.png". The way R knows how to number
these files is because of the \texttt{\%02d} part of the command. That's telling
R to use a number that is two digits long in place of that expression. All of
these files will be 14x14" and will have a resolution of 300 dots per inch. If
you wanted to do the same thing, but place them all in one file, you should use
the pdf option.

<<pdf_save, eval=FALSE>>=
pdf("H3N2_barcharts.png", width = 14, height = 14, compress = FALSE)
H.tab <- mlg.table(H3N2)
dev.off()
@

Remember, it is important not to forget to type \texttt{dev.off()} when you are
done making graphs. Note that I did not have to specify a resolution for this
image since it is based off of vector graphics.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Table of Functions}
\label{appendix:funk}

\tab\tab Below is a table of functions found in \poppr{}. These functions are
linked within the document. If a function name is blue, simply click on it to go
to its definition and description.

\begin{center}
\begin{longtable}{ll}
\caption{Functions available in \poppr{}} \label{function_table} \\

\hline \\[-1.5ex] \textbf{\large Function} & \textbf{\large Description} \\ \hline \\[-1.5ex]
\endfirsthead

\multicolumn{2}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline \\[-1.5ex] \textbf{\large Function} & \textbf{\large Description} \\ \hline \\[-1.5ex]
\endhead

\hline \multicolumn{2}{r}{\textbf{Continued on next page...}} \\
\endfoot

\hline \hline
\endlastfoot

\multicolumn{2}{l}{\Large\textsc{Import/Export}}\\
\cmdlink{intro:import:getfile}{getfile} & Provides a quick GUI to grab files for import \\
\cmdlink{intro:import:read.genalex}{read.genalex} & Read \textit{GenAlEx} formatted csv files to a genind object \\
\cmdlink{intro:import:genind2genalex}{genind2genalex} & Converts genind objects to \textit{GenAlEx} formatted csv files \\
\cmdlink{intro:genclone:as.genclone}{as.genclone} & Converts genind objects to genclone objects \\
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Manipulation}}\\
\cmdlink{data.manip:hier:setpop}{setpop} & Set the population using defined hierarchies\\
\cmdlink{data.manip:hier:define}{splithierarchy} & Split a concatenated hierarchy imported as a population\\
\cmdlink{data.manip:hier:define}{sethierarchy} & Define a population hierarchy of a genclone object\\
\cmdlink{data.manip:hier:view}{gethierarchy} & Extract the hierarchy data frame\\
\cmdlink{data.manip:hier:manip}{addhierarchy} & Add a vector or data frame to an existing hierarchy \\
\cmdlink{data.manip:hier:manip}{namehierarchy} & Rename a population hierarchy\\
\cmdlink{data.manip:missing:missingno}{missingno} & Handles missing data \\
\cmdlink{data.manip:cc:clonecorrect}{clonecorrect} & Clone censors at a specified population hierarchy \\
\cmdlink{data.manip:informloci}{informloci} & Detects and removes phylogenetically uninformative loci \\
\cmdlink{data.manip:divide:popsub}{popsub} & Subsets genind objects by population \\
\cmdlink{data.manip:shuffle:shufflepop}{shufflepop} & Shuffles genotypes at each locus using four different shuffling algorithms \\
\texttt{splitcombine*} & Manipulates population hierarchy *Deprecated\\
\cmdlink{intro:import:polyploid}{recode\_polyploids} &  recode polyploid data sets with missing alleles imported as ``0''\\
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Distances}}\\
\texttt{bruvo.dist} & Bruvo's distance \\
\texttt{diss.dist} & Absolute genetic distance (see \texttt{provesti.dist}) \\
\texttt{nei.dist} & Nei's 1978 genetic distance \\
\texttt{rogers.dist} & Rogers' euclidean distance \\
\texttt{reynolds.dist} & Reynolds' coancestry distance \\
\texttt{edwards.dist} & Edwards' angular distance \\
\texttt{provesti.dist} & Provesti's absolute genetic distance \\
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Bootstrapping}}\\
\texttt{aboot} & Creates a bootstrapped dendrogram for any distance measure \\
\texttt{bruvo.boot} & Produces dendrograms with bootstrap support\\
 & based on Bruvo's distance \\
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Analysis}}\\
\texttt{poppr.amova} & Analysis of Molecular Variance (as implemented in ade4) \\
\texttt{ia} & Calculates the index of association \\
\cmdlink{mlg:mlg:mlg}{mlg} & Calculates the number of multilocus genotypes \\
\cmdlink{mlg:cross:mlg.crosspop}{mlg.crosspop} & Finds all multilocus genotypes that cross populations \\
\cmdlink{mlg:table:mlg.table}{mlg.table} & Returns a table of populations by multilocus genotypes \\
\cmdlink{mlg:mix:mlg.vector}{mlg.vector} & Returns a vector of a numeric multilocus genotype assignment for \\ 
 & each individual \\
\cmdlink{mlg:mix:mlg.id}{mlg.id} & Identifies individuals associated with each MLG \\
\texttt{poppr} & Returns a diversity table by population \\
\texttt{poppr.all} & Returns a diversity table by population for all compatible files specified \\
\texttt{private\_alleles} & Tabulates the occurrences of alleles that only occur in one population\\
\texttt{locus\_table} & Creates a table of summary statistics per locus\\
\hline \\[-1.5ex]
\multicolumn{2}{l}{\Large\textsc{Visualization}}\\
\texttt{plot\_poppr\_msn} & Plots minimum spanning networks produced in poppr with\\
 & scale bar and legend \\
\texttt{greycurve} & Helper to determine the appropriate parameters for adjusting the\\
 & grey level for msn functions \\
\texttt{bruvo.msn} & Produces minimum spanning networks based off Bruvo's distance\\
 & colored by population \\
\texttt{poppr.msn} & Produces a minimum spanning network for any pairwise distance\\  
 & matrix related to the data \\
\texttt{info\_table} & Creates a heatmap representing missing data or observed ploidy\\
\texttt{genotype\_curve} & Creates a series of boxplots demonstrating how many loci are\\
 & needed to represent the diversity of your data.\\
\hline

\end{longtable}
\end{center}
\bibliographystyle{plain}
\bibliography{poppr_man}
\end{document}
