\documentclass[letterpaper]{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0, 0, 0}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.502,0,0.502}{\textbf{#1}}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.651,0.522,0}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{1,0.502,0}{#1}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{1,0,0.502}{\textbf{#1}}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.733,0.475,0.467}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.502,0.502,0.753}{\textbf{#1}}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0,0.502,0.753}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0,0.267,0.4}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
%\VignetteIndexEntry{Poppr User Manual}
%\VignetteEngine{knitr::knitr}
\usepackage{graphicx}
\usepackage[colorlinks = true,
            urlcolor = blue,
            citecolor = blue,
            linkcolor = blue]{hyperref}
\usepackage{array}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[utf8]{inputenc} % for UTF-8/single quotes from sQuote()
\usepackage{fullpage}
\usepackage{mathtools}
\usepackage{makeidx}

% for bold symbols in mathmode
\usepackage{bm}
\newcommand{\R}{\mathbb{R}}
\newcommand{\m}[1]{\mathbf{#1}}
\newcommand{\tab}{\hspace*{1em}}
\newcolumntype{H}{>{\setbox0=\hbox\bgroup}c<{\egroup}@{}}
\newcommand{\cmdlink}[2]{
  \texttt{\hyperref[#1]{#2}}
}
\newcommand{\seclink}[2]{
  \textsc{\hyperref[#1]{#2}}
}

\newcommand{\poppr}{\textit{poppr}}
\newcommand{\Poppr}{\textit{Poppr}}
\newcommand{\adegenet}{\textit{adegenet}}
\newcommand{\Adegenet}{\textit{Adegenet}}

\title{Poppr 1.1.0.99: An R package for genetic analysis of populations with mixed (clonal/sexual) reproduction}
\author{Zhian N. Kamvar$^{1}$\ and Niklaus J. Gr\"unwald$^{1,2}$\\\scriptsize{1) Department of Botany and Plant Pathology, Oregon State University, Corvallis, OR}\\\scriptsize{2) Horticultural Crops Research Laboratory, USDA-ARS, Corvallis, OR}}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\begin{document}
% Set the width of figures.
\setkeys{Gin}{width=0.5\textwidth}







\definecolor{light-gray}{gray}{0.95}
\definecolor{salmon}{HTML}{F0AAAA}

\maketitle
\begin{abstract}
\Poppr{} provides open-source, cross-platform tools for quick analysis of population genetic data enabling focus on data analysis and interpretation. While there are a plethora of packages for population genetic analysis, few are able to offer quick and easy analysis of populations with mixed reproductive modes. \Poppr{}'s main advantage is the ease of use and integration with other packages such as \adegenet{} and \textit{vegan}, including support for novel methods such as clone correction, multilocus genotype analysis, calculation of Bruvo's distance and the index of association. 
\end{abstract}
% Inserting the \Poppr{} logo here
\begin{figure}[b]
  \centering
  \label{logo}
  \includegraphics{popprlogo}
\end{figure}
\newpage
\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\endgroup
%\linenumbers

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Introduction}
\label{intro}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Purpose}
\label{intro:purpose}

\tab\tab\Poppr{} is an R package with convenient functions for analysis of genetic data with mixed modes of reproduction including sexual and clonal reproduction. While there are many R packages in CRAN and other repositories with tools for population genetic analyses, few are appropriate for populations with mixed modes of reproduction. There are several stand alone programs that can handle these types of data sets, but they are often platform specific and often only accept specific data types. Furthermore, a typical analysis often involves switching between many programs, and converting data to each specific format.

\Poppr{} is designed to make analysis of populations with mixed reproductive modes more streamlined and user friendly so that the researcher using it can focus on data analysis and interpretation. \Poppr{} allows analysis of haploid and diploid dominant/co-dominant marker data including microsattelites, Single Nucleotide Polymorphisms (SNP), and Amplified Fragment Length Polymorphisms (AFLP). To avoid creating yet another file format that is specific to a program, \poppr{} was created on the backbone of the popular R package \adegenet{} and can take all the file formats that \adegenet{} can take (Genpop, Genetix, Fstat, and Structure) and newly introduces compatibility with GenAlEx formatted files (exported to CSV). This means that anything you can analyze in \adegenet{} can be further analyzed with \poppr{}.

The real power of \poppr{} is in the data manipulation and analytic tools. \Poppr{} has the ability to define multiple population hierarchies, clone-censor, and subset data sets. With \poppr{} you can also quickly calculate Bruvo's distance, the index of association, and easily determine which multilocus genotypes are shared across populations.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Installation}
\label{intro:install}

\tab\tab This manual assumes that you have already installed R. If you have not, please refer to The CRAN home page at \url{http://cran.r-project.org/}. The author also recommends utilizing an R gui such as Rstudio (\url{http://www.rstudio.com/}) for a better R experience. 

\subsubsection{From CRAN}
\tab\tab To install \poppr{} from CRAN is as simple as selecting ``Package Installer" from the menu ``Packages \& Data" in the gui or by typing in your command line:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"poppr"}\hlstd{,} \hlkwc{dependencies} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

If everything is working perfectly, all the dependencies (\textit{adegenet, pegas, vegan, ggplot2, phangorn, ape} and \textit{igraph}) should be installed. In the unfortunate case this does not work, consult \url{http://cran.r-project.org/doc/manuals/R-admin.html#Installing-packages}.

\subsubsection{From Source}
\tab\tab The tarball for \poppr{} can be from CRAN: \url{http://cran.r-project.org/package=poppr}, the Gr\"unwald Lab website: \url{http://http://grunwaldlab.cgrb.oregonstate.edu/} under the \textsc{Resources} tab, or github at \url{https://github.com/grunwaldlab/poppr}. 

Since \poppr{} contains C code, it needs to be compiled, which means that you need a working C compiler. If you are on Linux, you shouldn't have to worry too much about that, but if you are on Windows or OSX, you might need to download some special tools:

\begin{description}
  \item[Windows] Download Rtools: \url{http://cran.r-project.org/bin/windows/Rtools/}
  \item[OSX] Download Xcode: \url{https://developer.apple.com/xcode/}
\end{description}

If you choose to install \poppr{} from a source file, you should first make sure to install all of the dependencies with the following command:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"adegenet"}\hlstd{,} \hlstr{"pegas"}\hlstd{,} \hlstr{"vegan"}\hlstd{,} \hlstr{"ggplot2"}\hlstd{,} \hlstr{"phangorn"}\hlstd{,} \hlstr{"ape"}\hlstd{,}
    \hlstr{"igraph"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

\textbf{If you want to install from github, you may skip to the next section.}

After installing dependencies, download the package to your computer and then you can install it with:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"/path/to/poppr.tar.gz"}\hlstd{,} \hlkwc{type} \hlstd{=} \hlstr{"source"}\hlstd{,} \hlkwc{repos} \hlstd{=} \hlkwa{NULL}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\subsubsection{From github}
\tab\tab Github is a repository where you can find all stable and development versions of \poppr{}. Installing from github requires a C compiler, so be sure to read the section above for instructions on how to obtain that if you aren't on a Linux system. 

To install from github, you do not need to actually download the tarball since there is a package called \textit{devtools} that will download and install the package for you directly from github. After you have installed all dependencies (see above section), you should download \textit{devtools}:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{install.packages}\hlstd{(}\hlstr{"devtools"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Now you can execute the command \texttt{install\_github} with the user and repository name:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(devtools)}
\hlkwd{install_github}\hlstd{(}\hlkwc{repo} \hlstd{=} \hlstr{"grunwaldlab/poppr"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


If you are the adventurous type and are willing to test out unreleased versions of the package, you can also install the development version:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(devtools)}
\hlkwd{install_github}\hlstd{(}\hlkwc{repo} \hlstd{=} \hlstr{"grunwaldlab/poppr"}\hlstd{,} \hlkwc{ref} \hlstd{=} \hlstr{"devel"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Users who install this version do so at their own risk. Since it is a development version, documentation may be rough or nonexistant for new functions. 

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Quick start}
\label{intro:qstart}

\tab\tab The author assumes that if you have reached this point in the manual, then you have successfully installed R and \poppr{}. Before proceeding, you should be aware that R is case sensitive. This means that the words ``Case" and ``case" are different from R's perspective. You should also know where your R package Library is located.
\begin{center}
   \fcolorbox{black}{light-gray}{
        \begin{minipage}[t]{0.8\textwidth}
{\large \textsc{What or where is my R package library?}}\\
R is as powerful as it is through a community of people who submit extra code called ``Packages" to help it do specific things. These packages live in a certain place on your computer called an R library. You can find out where this library is by typing
.libPaths()
        \end{minipage}
    }
\end{center}
Importing a file into R involves you knowing the path to your file and then typing that into R's console. \texttt{getfile()} will help provide a point and click interface for selecting a file. There are two steps:


Before you do anything, you'll want to tell your computer to search R's library to find the \poppr{} and load the package:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(poppr)}
\end{alltt}
\end{kframe}
\end{knitrout}

After that, you can use \texttt{getfile()}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlkwd{getfile}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}

At this point, a pop up window will appear like this\footnote{This window sometimes appears behind your current session of R, depending on the GUI and you will have to toggle to this window}:
\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize A popup window as it appears in OSX (Mountain Lion).}
  \label{getfile window}
\includegraphics{getfile.png}
\end{figure}
\begin{center}
   \fcolorbox{black}{light-gray}{
        \begin{minipage}[t]{0.8\textwidth}
{\large \textsc{Hey! My window doesn't look like that!}}\\
Now, this window will not match up to your window on your computer because you will probably not be in the right directory. Remember the first path in \texttt{.libPaths()}? Move to a folder called \textbf{poppr} in that path. In that folder, you will find another folder called \textbf{files}. Move there and your window will match the one displayed.
        \end{minipage}
    }
\end{center}
\newpage

We can navigate throughout your entire computer through this little window and tell R where to go. The example I'm using goes to your R library directory. If you don't know where that is, you can find it by typing \texttt{.libPaths()} into the R command line.
Once we select a file, the file name and its path will be stored in the variable, x. We can confirm what we selected by simply typing \texttt{x} into R's command line.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x}
\end{alltt}
\begin{verbatim}
## $files
## [1] "/path/to/R/poppr/files/rootrot.csv"
## 
## $path
## [1] "/path/to/R/poppr/files"
\end{verbatim}
\end{kframe}
\end{knitrout}

Here we can see that \texttt{x} is a list with two entries: \texttt{\$files} giving you the files you selected and \texttt{\$path} giving you the path to those files. 
\begin{center}
   \fcolorbox{black}{light-gray}{
         \begin{minipage}[t]{0.8\textwidth}
{\large \textsc{Not sure what I mean by path or working directory?}}\\
For anyone who has never used a command line, this is a new concept. 
You can think of the path as an address. So instead of \texttt{"/path/to/R"}, you could have \texttt{"/USA/Oregon/Corvallis"}. Or on your computer, it could be \texttt{"C:/users/poppr-user/R/win-library/2.15"} on Windows (where poppr-user" is your username) or \texttt{"/Library/Frameworks/R.framework/Versions/2.15/Resources/library"} on OSX. Each slash represents a folder that you would click through when you are using the mouse.

A working directory is simply the folder that R is working in. It is where you can access and write files. When you tell R to read a file, it will only look for that file in your working directory. Note that you will not endanger your files by reading them into R. R works by making a copy of the file into memory. This means that you can manipulate the data in any way that you want without ever losing the content.\\

To find out your current working directory, type \texttt{getwd()} into the R console. Usually, you will start off a session in your ``home" directory, which will look like this: \texttt{``$\sim$/"}.
The command \texttt{setwd()} will change your working directory to any place of your choice on your computer as indicated by the path that you provide.
For more information, see Quick R at \url{http://www.statmethods.net}.
         \end{minipage}
      }
\end{center}

We will use \texttt{x\$files} to access the file. The \texttt{poppr()} function provides a quick and convenient first analysis of your data directly from the file on the your disk (For information on importing your data into R, see section\seclink{intro:import}{Get out of my dreams and into my R.})
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{popdata} \hlkwb{<-} \hlkwd{poppr}\hlstd{(x}\hlopt{$}\hlstd{files)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## | Athena_1 
## | Athena_2 
## | Athena_3 
## | Athena_4 
## | Athena_5 
## | Athena_6 
## | Athena_7 
## | Athena_8 
## | Athena_9 
## | Athena_10 
## | Mt. Vernon_1 
## | Mt. Vernon_2 
## | Mt. Vernon_3 
## | Mt. Vernon_4 
## | Mt. Vernon_5 
## | Mt. Vernon_6 
## | Mt. Vernon_7 
## | Mt. Vernon_8 
## | Total
\end{verbatim}
\end{kframe}
\end{knitrout}

The output of \texttt{poppr()} was assigned to the variable \texttt{popdata}, so let's look at the data.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{popdata}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##             Pop   N MLG  eMLG    SE     H     G  Hexp   E.5    Ia rbarD        File
## 1      Athena_1   9   7  7.00 0.000 1.889  6.23 0.944 0.932  2.92 0.210 rootrot.csv
## 2      Athena_2  12  12 10.00   NaN 2.485 12.00 1.000 1.000  4.16 0.128 rootrot.csv
## 3      Athena_3  10   2  2.00 0.000 0.325  1.22 0.200 0.571  2.00 1.000 rootrot.csv
## 4      Athena_4  13   9  7.15 0.769 1.946  5.12 0.872 0.687  5.49 0.372 rootrot.csv
## 5      Athena_5  10   7  7.00 0.000 1.834  5.56 0.911 0.866  4.53 0.353 rootrot.csv
## 6      Athena_6   5   5  5.00 0.000 1.609  5.00 1.000 1.000  2.46 0.190 rootrot.csv
## 7      Athena_7  11  10  9.18 0.386 2.272  9.31 0.982 0.955  2.13 0.086 rootrot.csv
## 8      Athena_8   8   6  6.00 0.000 1.667  4.57 0.893 0.831  3.86 0.323 rootrot.csv
## 9      Athena_9  10  10 10.00 0.000 2.303 10.00 1.000 1.000  2.82 0.118 rootrot.csv
## 10    Athena_10   9   8  8.00 0.000 2.043  7.36 0.972 0.948  2.85 0.137 rootrot.csv
## 11 Mt. Vernon_1  10   9  9.00 0.000 2.164  8.33 0.978 0.952  7.13 0.276 rootrot.csv
## 12 Mt. Vernon_2   6   6  6.00 0.000 1.792  6.00 1.000 1.000 20.65 0.492 rootrot.csv
## 13 Mt. Vernon_3   8   6  6.00 0.000 1.667  4.57 0.893 0.831  2.12 0.106 rootrot.csv
## 14 Mt. Vernon_4  12   8  6.83 0.665 1.814  4.50 0.848 0.681  3.01 0.255 rootrot.csv
## 15 Mt. Vernon_5  17   7  5.54 0.828 1.758  5.07 0.853 0.848  2.68 0.340 rootrot.csv
## 16 Mt. Vernon_6  12  11  9.32 0.466 2.369 10.29 0.985 0.958 19.50 0.467 rootrot.csv
## 17 Mt. Vernon_7  12   9  7.82 0.649 2.095  7.20 0.939 0.870  1.21 0.153 rootrot.csv
## 18 Mt. Vernon_8  13   9  7.35 0.764 2.032  6.26 0.910 0.794  1.15 0.169 rootrot.csv
## 19        Total 187 119  9.61 0.612 4.558 68.97 0.991 0.720 14.37 0.271 rootrot.csv
\end{verbatim}
\end{kframe}
\end{knitrout}

One thing to note about this output is the \texttt{NaN} in the column labeled \texttt{SE}. This is produced from calculation of a standard error based on rarefaction analysis. Occasionally, this calculation will encounter a situation in which it must attempt to take a square root of a negative number. As you no doubt have learned in high school mathematics, the root of any negative number is not defined in the set of real numbers, and must have an imaginary component, $i$. Unfortunately, R will not represent the imaginary components of numbers unless you specifically tell it to do so. To account for this, R represents the square roots of negatives as ``not a number" or \texttt{NaN}.\\
The fields you see in the output include:
\begin{itemize}
  \item \texttt{Pop -} Population name (Note that ``Total" also means ``Pooled").
  \item \texttt{N -} Number of individuals observed.
  \item \texttt{MLG -} Number of multilocus genotypes (MLG) observed.
  \item \texttt{eMLG -} The number of expected MLG at the smallest sample size $\geq 10$ based on rarefaction. \cite{Hurlbert:1971}
  \item \texttt{SE -} Standard error based on \texttt{eMLG} \cite{Heck:1975}
  \item \texttt{H -} Shannon-Wiener Index of MLG diversity. \cite{Shannon:1948}
  \item \texttt{G -} Stoddart and Taylor's Index of MLG diversity. \cite{Stoddart:1988}
  \item \texttt{Hexp -} Nei's 1978 genotypic diversity (corrected for sample size), or  Expected Heterozygosity. \cite{Nei:1978}
  \item \texttt{E.5 -} Evenness, $E_5$. \cite{Pielou:1975}\cite{Ludwig:1988}\cite{Grunwald:2003}
  \item \texttt{Ia -} The index of association, $I_A$. \cite{Brown:1980} \cite{Smith:1993} \cite{Agapow:2001}
  \item \texttt{rbarD -} The standardized index of association, $\bar r_d$. \cite{Agapow:2001}
\end{itemize}

These fields are further described in section\seclink{summary}{I know what you did last summary table}at the end of this vignette. 

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Get out of my dreams and into my R \{importing data into poppr\}}
\label{intro:import}
There are several ways of reading data into R. 
\subsubsection{Function: getfile}
\label{intro:import:getfile}
\tab\tab \texttt{getfile} gives the user an easy way to point R to the directory in which your data is stored. It is only meant for R GUIs such as Rstudio. Using this on the command line has very little advantage over setting the working directory manually. 
\begin{quote}
Default Command:
% \texttt{getfile(multi = FALSE, pattern = NULL, combine = TRUE)}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
getfile(multi = FALSE, pattern = NULL, combine = TRUE)
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
\begin{itemize}
  \item \texttt{multi -} This is normally set to \texttt{FALSE}, meaning that it will only grab the file you selected. If it's \texttt{TRUE}, it will grab all files within the directory, constrained only by what you type into the \texttt{pattern} field.
  \item \texttt{pattern -} A pattern that you want to filter the files you get. This accepts regular expressions, so you must be careful with anything that is not an alphanumeric character.
  \item \texttt{combine -} This tells \texttt{getfile} to combine the path and all the files. This is set to \texttt{TRUE} by default so that you can access your files no matter what working directory you are in. 
\end{itemize}

This method works for a single file, but let's say you had a lot of data sets you wanted to import. You would have to do all of these one by one, right? Not so. \texttt{getfile} has a nice little flag called \texttt{multi} telling the computer that you want to grab multiple files in the folder. You would use this with \texttt{poppr.all} to produce a summary table for all of your files\footnote{These files do not need to be similar in any way to do this analysis}:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x} \hlkwb{<-} \hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

A window would pop up again, and you should navigate to the same directory as you had before, and select any of the files in that directory. 
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{x}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
## [1] "/path/to/R/poppr/files/rootrot.csv"   "/path/to/R/poppr/files/rootrot2.csv" 
## [3] "/path/to/R/poppr/files/simulated.dat"
## 
## $path
## [1] "/path/to/R/poppr/files"
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see, now all of the files that existed in that directory are there! Now you can look at all those files at once! For space reasons, we will only print 2 siginficant digits.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{all_files} \hlkwb{<-} \hlkwd{poppr.all}\hlstd{(x}\hlopt{$}\hlstd{files)}
\hlkwd{print}\hlstd{(all_files,} \hlkwc{digits} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##  \    
##   | File: rootrot.csv 
##  /    
## | Athena_1 
## | Athena_2 
## | Athena_3 
## | Athena_4 
## | Athena_5 
## | Athena_6 
## | Athena_7 
## | Athena_8 
## | Athena_9 
## | Athena_10 
## | Mt. Vernon_1 
## | Mt. Vernon_2 
## | Mt. Vernon_3 
## | Mt. Vernon_4 
## | Mt. Vernon_5 
## | Mt. Vernon_6 
## | Mt. Vernon_7 
## | Mt. Vernon_8 
## | Total 
##  \    
##   | File: rootrot2.csv 
##  /    
## | 1 
## | 2 
## | 3 
## | 4 
## | 5 
## | 6 
## | 7 
## | 8 
## | 9 
## | 10 
## | Total 
##  \    
##   | File: simulated.dat 
##  /    
## | Total 
##             Pop   N MLG eMLG      SE    H    G Hexp  E.5    Ia rbarD          File
## 1      Athena_1   9   7  7.0 0.0e+00 1.89  6.2 0.94 0.93  2.92 0.210   rootrot.csv
## 2      Athena_2  12  12 10.0     NaN 2.48 12.0 1.00 1.00  4.16 0.128   rootrot.csv
## 3      Athena_3  10   2  2.0 0.0e+00 0.33  1.2 0.20 0.57  2.00 1.000   rootrot.csv
## 4      Athena_4  13   9  7.2 7.7e-01 1.95  5.1 0.87 0.69  5.49 0.372   rootrot.csv
## 5      Athena_5  10   7  7.0 0.0e+00 1.83  5.6 0.91 0.87  4.53 0.353   rootrot.csv
## 6      Athena_6   5   5  5.0 0.0e+00 1.61  5.0 1.00 1.00  2.46 0.190   rootrot.csv
## 7      Athena_7  11  10  9.2 3.9e-01 2.27  9.3 0.98 0.96  2.13 0.086   rootrot.csv
## 8      Athena_8   8   6  6.0 0.0e+00 1.67  4.6 0.89 0.83  3.86 0.323   rootrot.csv
## 9      Athena_9  10  10 10.0 0.0e+00 2.30 10.0 1.00 1.00  2.82 0.118   rootrot.csv
## 10    Athena_10   9   8  8.0 0.0e+00 2.04  7.4 0.97 0.95  2.85 0.137   rootrot.csv
## 11 Mt. Vernon_1  10   9  9.0 0.0e+00 2.16  8.3 0.98 0.95  7.13 0.276   rootrot.csv
## 12 Mt. Vernon_2   6   6  6.0 0.0e+00 1.79  6.0 1.00 1.00 20.65 0.492   rootrot.csv
## 13 Mt. Vernon_3   8   6  6.0 0.0e+00 1.67  4.6 0.89 0.83  2.12 0.106   rootrot.csv
## 14 Mt. Vernon_4  12   8  6.8 6.6e-01 1.81  4.5 0.85 0.68  3.01 0.255   rootrot.csv
## 15 Mt. Vernon_5  17   7  5.5 8.3e-01 1.76  5.1 0.85 0.85  2.68 0.340   rootrot.csv
## 16 Mt. Vernon_6  12  11  9.3 4.7e-01 2.37 10.3 0.98 0.96 19.50 0.467   rootrot.csv
## 17 Mt. Vernon_7  12   9  7.8 6.5e-01 2.09  7.2 0.94 0.87  1.21 0.153   rootrot.csv
## 18 Mt. Vernon_8  13   9  7.3 7.6e-01 2.03  6.3 0.91 0.79  1.15 0.169   rootrot.csv
## 19        Total 187 119  9.6 6.1e-01 4.56 69.0 0.99 0.72 14.37 0.271   rootrot.csv
## 20            1  19  16  9.2 7.0e-01 2.73 14.4 0.98 0.94 14.23 0.313  rootrot2.csv
## 21            2  18  18 10.0 4.2e-07 2.89 18.0 1.00 1.00  9.14 0.194  rootrot2.csv
## 22            3  18   8  5.3 1.0e+00 1.61  3.4 0.75 0.59 22.84 0.573  rootrot2.csv
## 23            4  25  17  7.9 1.1e+00 2.58  9.6 0.93 0.71 18.49 0.415  rootrot2.csv
## 24            5  27  14  7.5 1.1e+00 2.45  9.7 0.93 0.83 23.00 0.520  rootrot2.csv
## 25            6  17  15  9.3 6.3e-01 2.67 13.8 0.99 0.95 17.78 0.410  rootrot2.csv
## 26            7  23  19  9.2 7.6e-01 2.87 16.0 0.98 0.90 19.16 0.405  rootrot2.csv
## 27            8  21  15  8.3 9.8e-01 2.56 10.8 0.95 0.82 24.31 0.543  rootrot2.csv
## 28            9  10  10 10.0 0.0e+00 2.30 10.0 1.00 1.00  2.82 0.118  rootrot2.csv
## 29           10   9   8  8.0 0.0e+00 2.04  7.4 0.97 0.95  2.85 0.137  rootrot2.csv
## 30        Total 187 119  9.6 6.1e-01 4.56 69.0 0.99 0.72 14.37 0.271  rootrot2.csv
## 31        Total 100   6  6.0 0.0e+00 1.23  2.8 0.65 0.73  0.05 0.061 simulated.dat
\end{verbatim}
\end{kframe}
\end{knitrout}


You've seen examples of how to use \texttt{getfile} to extract a single file and all the files in a directory, but what if you wanted many files, but only wanted ones that were of a certain type or had a certain name? This is what you would use the \texttt{pattern} argument for.
A perfect use would be the example data contained in the \adegenet{} package. Let's take a look at the names of these files.
\begin{center}
   \fcolorbox{black}{salmon}{
        \begin{minipage}[t]{0.8\textwidth}
         For the rest of this section, remember that every time you invoke \texttt{getfile()}, a window will pop up and you should select a file before hitting enter.
        \end{minipage}
      }
\end{center}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Navigate to the \adegenet{} folder in your R library.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
##  [1] "/path/to/R/adegenet/files/AFLP.txt"         
##  [2] "/path/to/R/adegenet/files/exampleSnpDat.snp"
##  [3] "/path/to/R/adegenet/files/mondata1.rda"     
##  [4] "/path/to/R/adegenet/files/mondata2.rda"     
##  [5] "/path/to/R/adegenet/files/nancycats.dat"    
##  [6] "/path/to/R/adegenet/files/nancycats.gen"    
##  [7] "/path/to/R/adegenet/files/nancycats.gtx"    
##  [8] "/path/to/R/adegenet/files/nancycats.str"    
##  [9] "/path/to/R/adegenet/files/pdH1N1-HA.fasta"  
## [10] "/path/to/R/adegenet/files/pdH1N1-NA.fasta"  
## [11] "/path/to/R/adegenet/files/pdH1N1-data.csv"  
## [12] "/path/to/R/adegenet/files/usflu.fasta"      
## 
## $path
## [1] "/path/to/R/adegenet/files"
\end{verbatim}
\end{kframe}
\end{knitrout}


We can see that we have a mix of files with different formats. If we tried to run all of these files using poppr, we would have a problem because some of the file formats have no direct import into a \texttt{genind} object (*.fasta, or *.snp), or just simply are not supported (eg. *.rda files). We want to be able to filter these files out, and we will do so with the \texttt{pattern} argument. Let's say we only wanted the files that have the word "nancy" in them.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{pattern} \hlstd{=} \hlstr{"nancy"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
## [1] "/path/to/R/adegenet/files/nancycats.dat" "/path/to/R/adegenet/files/nancycats.gen"
## [3] "/path/to/R/adegenet/files/nancycats.gtx" "/path/to/R/adegenet/files/nancycats.str"
## 
## $path
## [1] "/path/to/R/adegenet/files"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now, let's exclude everything but genetix files (*.gtx).
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{pattern} \hlstd{=} \hlstr{"gtx"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
## [1] "/path/to/R/adegenet/files/nancycats.gtx"
## 
## $path
## [1] "/path/to/R/adegenet/files"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now, let's only get FSTAT files (*.dat)
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{pattern} \hlstd{=} \hlstr{"dat"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
## [1] "/path/to/R/adegenet/files/mondata1.rda"   
## [2] "/path/to/R/adegenet/files/mondata2.rda"   
## [3] "/path/to/R/adegenet/files/nancycats.dat"  
## [4] "/path/to/R/adegenet/files/pdH1N1-data.csv"
## 
## $path
## [1] "/path/to/R/adegenet/files"
\end{verbatim}
\end{kframe}
\end{knitrout}


Uh-oh. We've run into a problem. Three out of our four files are not FSTAT files. Why did this happen? It happened because they happen to have \texttt{"dat"} within their name. This problem can be solved, by using regular expressions. If you are unfamiliar with regular expressions, you can think of them as special characters that you can use to make your search pattern more strict or more flexible. Since the topic of regular expressions can take up several lectures, I will spare you the gory details. For this situation, the only one you need to know is ``\texttt{\$}". The dollar sign indicates the end of a word or string. If we want specific file extensions all we have to do is add this to the end of the search term like so:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{getfile}\hlstd{(}\hlkwc{multi} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{pattern} \hlstd{=} \hlstr{"dat$"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## $files
## [1] "/path/to/R/adegenet/files/nancycats.dat"
## 
## $path
## [1] "/path/to/R/adegenet/files"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now we have our FSTAT file!
\subsubsection{Function: read.genalex}
\label{intro:import:read.genalex}

\tab\tab A very popular program for population genetics is GenAlEx (\url{http://biology.anu.edu.au/GenAlEx/Welcome.html}) \cite{Peakall:2012, Peakall:2006}. GenAlEx runs within the Excel environment and can be very powerful in its analyses. \Poppr{} has added the ability to read *.CSV files\footnote{*.CSV files are comma separated files that are easily machine readable.} produced in the GenAlEx format. It can handle data types containing regions and geographic coordinates, but currently it cannot import allelic frequency data from GenAlEx. All the user has to do is to export a single sheet of GenAlEx data from Excel into a *.CSV file, and the \poppr{} function \texttt{read.genalex} will import it into \adegenet{}'s \texttt{genind} object or \poppr{}'s \texttt{genclone} object (more information on that below). For ways of formatting a GenAlEx file, see the manual here: \url{http://biology.anu.edu.au/GenAlEx/Download_files/GenAlEx\%206.5\%20Guide.pdf}
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
read.genalex(genalex, ploidy = 2, geo = FALSE, region = FALSE, 
    genclone = TRUE, sep = ",")
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
\begin{itemize}
  \item \texttt{genalex -} a *.CSV file exported from GenAlEx on your disk (For example: \texttt{"my\_genalex\_file.csv"}).
  \item \texttt{ploidy -} a number indicating the ploidy for the data set (eg 2 for diploids, 1 for haploids).
  \item \texttt{geo -} GenAlEx allows you to have geographic data within your file. To do this for \poppr{}, you will need to follow the first format outlined in the GenAlEx manual and place the geographic data AFTER all genetic and demographic data with one blank column separating it (See the GenAlEx Manual for details). If you have geographic information in your file, set this flag to \texttt{TRUE} and it will be included within the resulting genind object in the \texttt{@other} slot. (If you don't know what that is, don't worry. It will be explained later in\seclink{intro:genind:other}{The other slot.})
  \item \texttt{region -} To format your GenAlEx file to include regions along with your populations, You can choose to include a separate column for regional data, or, since regional data must be in contiguous blocks, you can simply format it in the same way you would any other data (see the GenAlEx manual for details). If you have your file organized in this manner, select this option and the regional information will be stored in the resulting genind object in the \texttt{@other} slot.
  \item \texttt{genclone -} This flag defaults to \texttt{TRUE} and will automatically convert your data into a \texttt{genclone} object (see\seclink{intro:genclone}{Send in the clones}for more info).
  \item \texttt{sep -} The separator argument for your data. It defaults to ``,", but some countries use ``;" by default. This avoids the user having to
  specifically restructure his or data.
\end{itemize}

\begin{center}
   \fcolorbox{black}{light-gray}{
         \begin{minipage}[t]{0.8\textwidth}
{\large \textsc{If you are unfamiliar with exporting data from Excel}}\\
\begin{enumerate}
  \item Click the Microsoft Office Button in the top left corner of Excel. (Or go to the File menu if you have an older version)
  \item Click Save As...
  \item In the ``Save as type" drop down box, select CSV (comma delimited). 
\end{enumerate}
        \end{minipage}
      }
\end{center}

Note that regional data and geographic data are not mutually exclusive. You can have both in one file, just make sure that they are on the same sheet and that the geographic data is always placed after all genetic and demographic data.

We have a short example of genalex formatted data with no geographic or regional formatting. We will first see where the data is using the command \texttt{system.file()}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{system.file}\hlstd{(}\hlstr{"files/rootrot.csv"}\hlstd{,} \hlkwc{package} \hlstd{=} \hlstr{"poppr"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## [1] "/path/to/R/library/poppr/files/rootrot.csv"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now import the data into \poppr{} like so:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{rootrot} \hlkwb{<-} \hlkwd{read.genalex}\hlstd{(}\hlkwd{system.file}\hlstd{(}\hlstr{"files/rootrot.csv"}\hlstd{,} \hlkwc{package} \hlstd{=} \hlstr{"poppr"}\hlstd{))}
\end{alltt}
\end{kframe}
\end{knitrout}

Executing rootrot shows that this file is now in genclone format and can be used
with any function in \poppr{} and \adegenet{}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{rootrot}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      1 population hierarchy - Pop
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Genalex formatting shortcuts}
\label{intro:import:genalex.short}

\tab\tab The GenAlEx format is a nice way to import data because it allows you to have geographic coordinates and two hierarchical levels of sampling (Region and population). If you have multiple levels of hierarchy, you will need to code them so that you combine multiple columns of hierarchy into one using a common separator (For an example, see below). A problem arises when it becomes more work than it's worth to do that since, for the GenAlEx format, you must provide the sizes of each population in the header. Here, I'll show you a simple way to circumvent that. First, let's use the microbov data set from \adegenet{} (for details, type \texttt{help("microbov")} into your R console). It contains three demographic factors: Country, Species and Breed contained within the \texttt{@other} slot (detailed in\seclink{intro:genind:other}{The other slot}). We will combine these and save the file to our desktop. We will cover these functions later in this manual. For now, just know they exist.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(poppr)}
\hlkwd{data}\hlstd{(microbov)}
\hlstd{microbov} \hlkwb{<-} \hlkwd{as.genclone}\hlstd{(microbov)}
\hlkwd{sethierarchy}\hlstd{(microbov)} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwd{other}\hlstd{(microbov))}
\hlkwd{setpop}\hlstd{(microbov)} \hlkwb{<-} \hlopt{~}\hlstd{coun}\hlopt{/}\hlstd{breed}\hlopt{/}\hlstd{spe}
\hlkwd{genind2genalex}\hlstd{(microbov,} \hlkwc{file} \hlstd{=} \hlstr{"~/Desktop/microbov.csv"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## Extracting the table ... Writing the table to ~/Desktop/microbov.csv ... Done.
\end{verbatim}
\end{kframe}
\end{knitrout}

After we do this, we can open the file in our favorite spreadsheet editor and see the following image.

\setkeys{Gin}{width=\textwidth}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of the microbov data set. The first column contains the individual names, the second column contains the population names, and each subsequent column represents microsatellite genetic data. Highlighted in red is a list of populations and their relative sizes.}
  \label{microbov unmodified}
\includegraphics{unmod_dat}
\end{figure}

\newpage
All that \poppr{} needs from the first header row are the first three numbers (unless you are including regional data, but it's not terribly necessary with the hierarchical support \poppr{} provides.), which represent the number of loci, individuals, and populations, respectively. After that, you have counts of individuals per population in each subsequent cell. For \poppr{}, These cells don't matter because we already have that information in column 2.

If you have a large data set with many population levels, you can use the following shortcut by setting the number in the third cell to 1. The number in cell 4 is arbitrary (but must be there). In the following figure, it is set to the number of individuals in your data set, but can easily be replaced with any other number (perhaps your favorite number?). 

\begin{figure}[h!]
  \centering
  \caption{\footnotesize \footnotesize The first 15 individuals and 4 loci of the microbov data set. This is the same figure as above, however the populations and counts have been removed from the header row and the third number in the header has been replaced by 1.}
\includegraphics{mod_dat}
\end{figure}

\setkeys{Gin}{width=0.5\textwidth}

\subsubsection{Other ways of importing data}
\label{intro:import:other}

\tab\tab \Adegenet{} already supports the import of FSTAT, Structure, Genpop, and Genetix formatted files, so if you have those formats, you can import them using the function \texttt{import2genind}. For sequence data, check if you can use \texttt{read.dna} from the \textit{ape} package to import your data. If you can, then you can use the \adegenet{} function \texttt{DNAbin2genind}. If you don't have any of these formats handy, you can still import your data using R's \texttt{read.table} along with \texttt{df2genind} from \adegenet{}. For more information, see \adegenet{}'s ``Getting Started" vignette.

\subsubsection{Function: genind2genalex}
\label{intro:import:genind2genalex}

\tab\tab Of course, being able to export data is just as useful as being able to import it, so we have this handy little function that will write a GenAlEx formatted file to wherever you desire.\\ 
WARNING: This will overwrite any file that exists with the same name.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
genind2genalex(pop, filename = "genalex.csv", quiet = FALSE, 
    geo = FALSE, geodf = "xy", sep = ",")
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{genind2genalex(pop, filename = "genalex.csv", quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{filename -} This is where you specify where you want the file to go. If you simply type the file name, it will deposit the file in the directory R is currently in. If you don't know what directory you are in, you can type \texttt{getwd()} to find out.
  \item \texttt{quiet -} If this is set to \texttt{FALSE}, a message will be printed to the screen.
  \item \texttt{geo -} This is set to \texttt{FALSE} by default. If it is set to \texttt{TRUE}, then that means you have a data frame or matrix in the \texttt{@other} slot of your genind object that contains geographic coordinates for all individuals or all populations. Setting this to \texttt{TRUE} means that you want the resulting file to have two extra columns at the end of your file with geographic coordinates.
  \item \texttt{geodf -} The name of the data frame or matrix containing the geographic coordinates. The default is \texttt{geodf = "xy"}.
  \item \texttt{sep -} A separator to separate columns in the resulting file.
  Defaults to ``,".
\end{itemize}

First, a simple example for the rootrot data we demonstrated in section 1.4.2:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{genind2genalex}\hlstd{(rootrot,} \hlstr{"~/Desktop/rootrot.csv"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## Extracting the table ... Writing the table to ~/Desktop/rootrot.csv ... Done.
\end{verbatim}
\end{kframe}
\end{knitrout}


Now here's an example of exporting the nancycats data set into GenAlEx format with geographic information. If we look at the nancycats geographic information, we can see it's coordinates for each population, but not each individual:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}
\hlstd{nancycats}\hlopt{@}\hlkwc{other}\hlopt{$}\hlstd{xy}
\end{alltt}
\begin{verbatim}
##         x      y
## P01 263.3 171.11
## P02 183.5 122.41
## P03 391.1 254.70
## P04 458.6  41.72
## P05 182.8 219.08
## P06 335.2 344.84
## P07 359.2 375.36
## P08 271.3  67.89
## P09 256.8 150.03
## P10 270.6  17.01
## P11 493.5 237.26
## P12 305.5  85.34
## P13 463.0  86.79
## P14 429.6 291.05
## P15 531.2 115.14
## P16 407.8  99.87
## P17 345.4 251.79
\end{verbatim}
\end{kframe}
\end{knitrout}

And we can export it easily:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{genind2genalex}\hlstd{(nancycats,} \hlstr{"~/Desktop/nancycats_pop_xy.csv"}\hlstd{,} \hlkwc{geo} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## Extracting the table ... Writing the table to ~/Desktop/nancycats_pop_xy.csv ... Done.
\end{verbatim}
\end{kframe}
\end{knitrout}

If we wanted to assign a geographic coordinate to each individual, we can simply use this little repetition trick knowing that there are 17 populations in the data set:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nan2} \hlkwb{<-} \hlstd{nancycats}
\hlstd{nan2}\hlopt{@}\hlkwc{other}\hlopt{$}\hlstd{xy} \hlkwb{<-} \hlstd{nan2}\hlopt{@}\hlkwc{other}\hlopt{$}\hlstd{xy[}\hlkwd{rep}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{17}\hlstd{,} \hlkwd{table}\hlstd{(}\hlkwd{pop}\hlstd{(nan2))), ]}
\hlkwd{head}\hlstd{(nan2}\hlopt{@}\hlkwc{other}\hlopt{$}\hlstd{xy)}
\end{alltt}
\begin{verbatim}
##         x     y
## P01 263.3 171.1
## P01 263.3 171.1
## P01 263.3 171.1
## P01 263.3 171.1
## P01 263.3 171.1
## P01 263.3 171.1
\end{verbatim}
\end{kframe}
\end{knitrout}

Now we can export it to a different file.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{genind2genalex}\hlstd{(nan2,} \hlstr{"~/Desktop/nancycats_inds_xy.csv"}\hlstd{,} \hlkwc{geo} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## Extracting the table ... Writing the table to ~/Desktop/nancycats_inds_xy.csv ... Done.
\end{verbatim}
\end{kframe}
\end{knitrout}

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Getting to know \adegenet{}'s genind object}
\label{intro:genind}

\tab\tab Since \poppr{} was built around \adegenet{}'s framework, it is
important to know how \adegenet{} stores data in the genind object, as
that is the object used by \poppr{}. To create a genind object, 
\adegenet{} takes a data frame of genotypes (rows) across multiple loci
(columns) and converts them into a matrix of individual allelic frequencies at
each locus \cite{Jombart:2008}.

For example, if you had a data frame with 3 diploid individuals each with 3 loci
that had 3, 4, and 5 allelic states respectively, the resulting \texttt{genind}
object would contain a matrix that has 3 rows and 12 columns. 

\noindent Let's look at the example data frame:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##    locus1  locus2  locus3
## 1 101/101 201/201 301/302
## 2 102/103 202/203 301/303
## 3 102/102 203/204 304/305
\end{verbatim}
\end{kframe}
\end{knitrout}

And the resulting matrix after importing to genind.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##   L1.1 L1.2 L1.3 L2.1 L2.2 L2.3 L2.4 L3.1 L3.2 L3.3 L3.4 L3.5
## 1    1  0.0  0.0    1  0.0  0.0  0.0  0.5  0.5  0.0  0.0  0.0
## 2    0  0.5  0.5    0  0.5  0.5  0.0  0.5  0.0  0.5  0.0  0.0
## 3    0  1.0  0.0    0  0.0  0.5  0.5  0.0  0.0  0.0  0.5  0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

The first three columns represent the alleles of locus 1, the next four represent locus 2, and the last five represent locus 3.

Do you see what I mean when I say individual allele frequencies at each locus? For a diploid individual, you only have three possible allele frequencies at each locus: 1, 0.5, or 0. Now, this is not the entire genind object, but it is the main feature. The object also has various elements associated with it that give you information about the population membership, the names of loci, individuals, and alleles among other things that \poppr{} uses to work \cite{Jombart:2008}. If you wish to know more, see the \adegenet{} ``Getting Started" manual. 

\subsubsection{The other slot}
\label{intro:genind:other}

The other slot is a place in the genind object that can be used to store useful
information about the data. One application would be to store data of 
microsatellite repeat lengths for use with\seclink{index:bruvo}{Bruvo's 
Distance}. Here's a simple example using the dataset nancycats. We will assume
that this data set has dinucleotide repeats at all nine loci. We use the command
\texttt{other()} to access the slot and name a new item in it with the \texttt{\$}:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}  \hlcom{# Load the data}
\hlkwd{other}\hlstd{(nancycats)}\hlopt{$}\hlstd{repeat_lengths} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{9}\hlstd{)}  \hlcom{# assign a }
\hlkwd{other}\hlstd{(nancycats)}  \hlcom{# two items named xy and repeat_lengths}
\end{alltt}
\begin{verbatim}
## $xy
##         x      y
## P01 263.3 171.11
## P02 183.5 122.41
## P03 391.1 254.70
## P04 458.6  41.72
## P05 182.8 219.08
## P06 335.2 344.84
## P07 359.2 375.36
## P08 271.3  67.89
## P09 256.8 150.03
## P10 270.6  17.01
## P11 493.5 237.26
## P12 305.5  85.34
## P13 463.0  86.79
## P14 429.6 291.05
## P15 531.2 115.14
## P16 407.8  99.87
## P17 345.4 251.79
## 
## $repeat_lengths
## [1] 2 2 2 2 2 2 2 2 2
\end{verbatim}
\end{kframe}
\end{knitrout}


%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Send in the clones \{the genclone object\}}
\label{intro:genclone}

In \poppr{} versions 1.0.x, all of the functions revolved around
\texttt{genind} objects. However, there were a few limitations to our use of
this particular data structure.

\begin{enumerate}
  \item Defining multilocus genotypes was inconsistant when analyzing subsetted
        data.
  \item Population hierarchies had to be defined in a data frame contained in 
        the ``other" slot of the \texttt{genind} object. 
\end{enumerate}

Both of these issues led to inefficient data manipulation as well as confusion 
on the user's end. The \texttt{genclone} class was defined in order to make 
working with hierarchies more intuitive. It is built off of the 
\texttt{genind} object and has dedicated slots for the population hierarchy and
defined multilocus genotypes. 

\subsubsection{Function: as.genclone}
\label{intro:genclone:as.genclone}
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
as.genclone(x, hierarchy = NULL)
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
\begin{itemize}
  \item \textbf{x -} a \texttt{genind} object to be converted.
  \item \textbf{hierarchy -} an optional data frame whose columns define the 
  population hierarchy of the data set.
\end{itemize}

Let's show an example of a \texttt{genclone} object. First, we will take an 
existing \texttt{genind} object and convert it using the function 
\texttt{as.genclone} (We can also use the function 
\cmdlink{intro:import:read.genalex}{read.genalex} to import as
\texttt{genclone} or \texttt{genind} objects). We will use the \texttt{Aeut}
data set because it is a clonal data set that has a simple population hierarchy
\cite{Grunwald:2006}. The data set is here: \url{http://dx.doi.org/10.6084/m9.figshare.877104} and it is AFLP data of the root rot
pathogen \textit{Aphanomyces euteiches} collected from two different fields in
NW Oregon and W Washington, USA. These fields were divided up into subplots from
which samples were collected. The fields represent the population and the
subplots represent the subpopulation. 
Let's take a look at what the \texttt{genind} object looks like:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(poppr)}
\hlkwd{data}\hlstd{(Aeut)}
\hlstd{Aeut}
\end{alltt}
\begin{verbatim}
## 
##    #####################
##    ### Genind object ### 
##    #####################
## - genotypes of individuals - 
## 
## S4 class:  genind
## @call: read.genalex(genalex = "rootrot.csv")
## 
## @tab:  187 x 56 matrix of genotypes
## 
## @ind.names: vector of  187 individual names
## @loc.names: vector of  56 locus names
## @loc.nall: NULL
## @loc.fac: NULL
## @all.names: NULL
## @ploidy:  2
## @type:  PA
## 
## Optionnal contents: 
## @pop:  factor giving the population of each individual
## @pop.names:  factor giving the population of each individual
## 
## @other: a list containing: population_hierarchy
\end{verbatim}
\end{kframe}
\end{knitrout}


We can see that it gives us a lot of about the object. This is useful for people
who are more comfortable with programming, but might be information overload for
your average biologist. Unfortunately this output doesn't tell us about the 
number of populations, population hierarchical levels, or multiloucus genotypes. 
When we convert it to a \texttt{genclone} object, the multilocus genotypes will
be defined and the population hierarchy (if a data frame is defined in the 
\texttt{@other} slot called ``population\_hierarchy") will be set.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{agc} \hlkwb{<-} \hlkwd{as.genclone}\hlstd{(Aeut)}
\hlstd{agc}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      3 population hierarchies - Pop_Subpop Pop Subpop
##      2 populations defined - Athena Mt. Vernon
\end{verbatim}
\begin{alltt}
\hlcom{# We can also manually set the hierarchy.}
\hlkwd{as.genclone}\hlstd{(Aeut,} \hlkwc{hierarchy} \hlstd{=} \hlkwd{other}\hlstd{(Aeut)}\hlopt{$}\hlstd{population_hierarchy[}\hlopt{-}\hlnum{1}\hlstd{])}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - Pop Subpop
##      2 populations defined - Athena Mt. Vernon
\end{verbatim}
\end{kframe}
\end{knitrout}


We can see here that it shows less information, but it gives us a very simple
overview of our data. Don't be fooled, however, because it contains all the same
information as a \texttt{genind} object:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{c}\hlstd{(}\hlkwd{is.genind}\hlstd{(Aeut),} \hlkwd{is.genclone}\hlstd{(Aeut),} \hlkwd{is.genind}\hlstd{(agc),} \hlkwd{is.genclone}\hlstd{(agc))}
\end{alltt}
\begin{verbatim}
## [1]  TRUE FALSE  TRUE  TRUE
\end{verbatim}
\begin{alltt}
\hlcom{# Adegenet functions work the same, too}
\hlkwd{c}\hlstd{(}\hlkwd{nInd}\hlstd{(Aeut),} \hlkwd{nInd}\hlstd{(agc))}
\end{alltt}
\begin{verbatim}
## [1] 187 187
\end{verbatim}
\end{kframe}
\end{knitrout}


The advantage of the \texttt{genclone} object is that setting the pouplation
from the hierarchy becomes \textbf{much} easier. Here's an example of how we can
set the population to a combination of the population hierarchy in both a
\texttt{genind} and \texttt{genclone} object. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# We'll look at the population names}
\hlstd{Aeut}\hlopt{$}\hlstd{pop.names}
\end{alltt}
\begin{verbatim}
##           P1           P2 
##     "Athena" "Mt. Vernon"
\end{verbatim}
\begin{alltt}
\hlcom{# genind way: Get the population hierarchy. Luckily, it was already combined}
\hlstd{pophier} \hlkwb{<-} \hlkwd{other}\hlstd{(Aeut)}\hlopt{$}\hlstd{population_hierarchy}\hlopt{$}\hlstd{Pop_Subpop}
\hlkwd{pop}\hlstd{(Aeut)} \hlkwb{<-} \hlstd{pophier}
\hlstd{Aeut}\hlopt{$}\hlstd{pop.names}
\end{alltt}
\begin{verbatim}
##  [1] "Athena_1"     "Athena_2"     "Athena_3"     "Athena_4"     "Athena_5"    
##  [6] "Athena_6"     "Athena_7"     "Athena_8"     "Athena_9"     "Athena_10"   
## [11] "Mt. Vernon_1" "Mt. Vernon_2" "Mt. Vernon_3" "Mt. Vernon_4" "Mt. Vernon_5"
## [16] "Mt. Vernon_6" "Mt. Vernon_7" "Mt. Vernon_8"
\end{verbatim}
\begin{alltt}
\hlcom{# genclone way:}
\hlstd{agc}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      3 population hierarchies - Pop_Subpop Pop Subpop
##      2 populations defined - Athena Mt. Vernon
\end{verbatim}
\begin{alltt}
\hlkwd{setpop}\hlstd{(agc)} \hlkwb{<-} \hlopt{~}\hlstd{Pop}\hlopt{/}\hlstd{Subpop}
\hlstd{agc}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      3 population hierarchies - Pop_Subpop Pop Subpop
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\begin{alltt}
\hlcom{# Notice that you only see the first and last three population names.  Use the print method}
\hlcom{# to display all population names.}

\hlkwd{print}\hlstd{(agc)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      3 population hierarchies - Pop_Subpop Pop Subpop
##     18 populations defined - Athena_1 Athena_2 Athena_3 Athena_4 Athena_5 Athena_6 
## Athena_7 Athena_8 Athena_9 Athena_10 Mt. Vernon_1 Mt. Vernon_2 Mt. Vernon_3 Mt. Vernon_4 
## Mt. Vernon_5 Mt. Vernon_6 Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}


The difference between the two is clear: With the \texttt{genind} object, the
user must find the vector defining the population and set it using that vector.
With the \texttt{genclone} object, the vector is already defined in the object
and the user simply supplies a formula argument giving the hierarchy. This 
formula driven method is also used for clone correction, combining hierarchical
levels and conducting AMOVA. These will all be explained in later chapters. For
examples and details, type \texttt{help("genclone")} in your R console.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Accessing the population hierarchy}
\label{intro:genclone:access}

The hierarchy slot in the genclone object is special because it allows us to
rapidly access and manipulate different levels of a population hierarchy without
the complication of creating new data sets. Previously, in poppr, if you wanted
to access the popualtion hierarchy, you had to provide a vector of the names
of the population hierarchy. This was awkward because defining a vector of
strings in R is awkward:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hier} \hlkwb{=} \hlkwd{c}\hlstd{(}\hlstr{"Population"}\hlstd{,} \hlstr{"Subpopulation"}\hlstd{,} \hlstr{"Year"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

So, to replace the old method, we decided to implement the use of hierarchical
nested formulae:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{hier} \hlkwb{=} \hlopt{~}\hlstd{Population}\hlopt{/}\hlstd{Subpopulation}\hlopt{/}\hlstd{Year}
\end{alltt}
\end{kframe}
\end{knitrout}

\textbf{NOTE:} The $\sim$ symbol is absolutely required for formulas, even if you only 
are specifying one level.

The \texttt{"/"} symbolizes a hierarchical nesting. The above formula represents
years nested within subpopulations, nested within populations. This allows the
user to easily restructure the population hierarchy. Manipulation of the hierarchy
is necessary for\seclink{data.manip:cc}{clone correction}and AMOVA analysis. See the section\seclink{data.manip:hier}{Can you take me hier(archy)}for more details on manipulation of hierarchies. 

%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Data Manipulation}
\label{data.manip}

\tab\tab One tedious aspect of population genetic analysis is the need for repeated data manipulation. \Adegenet{} has some functions for manipulating data that are limited to replacing missing data and dividing data into populations, loci, or by sample size \cite{Jombart:2008}. \Poppr{} includes novel functions for clone-censoring your data sets or sub-setting a genind object by specific populations.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Inside the golden days of missing data \{replace or remove missing data\}}
\label{data.manip:missing}

\tab\tab A data set without missing data is always ideal, but often not achievable. Many functions in \adegenet{} cannot handle missing data and thus the function \texttt{na.replace} exists \cite{Jombart:2008}. It will replace missing data with with either ``0" representing a mysterious extra allele in the data set resulting in more diversity or the mean of allelic frequencies at the locus. There is no set method, however, for simply removing missing data from analyses, which is why the \poppr{} function \texttt{missingno} (see below) exists. If the name makes you uneasy it's because it should. Missing data can mean different things based on your data type. For microsatellites, missing data might represent any source of error that could cause a PCR product to not amplify in gel electrophoresis, which may or may not be biologically relevant. For a DNA alignment, missing data could mean something as simple as an insertion or deletion, which is biologically relevant. The choice to exclude or estimate data has very different implications for the type of data you have.
\subsubsection{Function: missingno}
\label{data.manip:missing:missingno}

\tab\tab \texttt{missingno} is a function that serves partially as a wrapper for \adegenet{}'s \texttt{na.replace} to replace missing data and as a way to exclude specific areas that contain systematic missing data.  
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
missingno(pop, type = "loci", cutoff = 0.05, quiet = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{missingno(pop, type = "loci", cutoff = 0.05, quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{type -} This could be one of four options:
    \begin{description}
      \item[ ``mean"] This replaces missing data with the mean allele frequencies in the entire data set.
      \item[ ``zero" or ``0"] This replaces missing data with zero, signifying a new allele.
      \item[ ``loci"] This is to be used for a data set that has systematic problems with certain loci that contain null alleles or simply failed to amplify. This will remove loci with a defined threshold of missing data from the data set.
      \item[ ``geno"] This is to be used for genotypes (individuals) in your data set where many null alleles are present. Individuals with a defined threshold missing data will be removed.
    \end{description}
    \item \texttt{cutoff -} This is a numeric value from 0 to 1 indicating the percent allowable missing data for either loci or genotypes. If you have, for example, two loci containing missing 5\% and 10\% missing data, respectively and you set \texttt{cutoff = 0.05}, \texttt{missingno} will remove the second locus. Percent missing data for genotypes is considered the percent missing loci over number of total loci. 
    \item \texttt{quiet -} When this is set to \texttt{FALSE}, the number of missing values replaced will be printed to screen if the method is ``zero" or ``mean". It will print the number of loci or individuals removed if the method is ``loci" or ``geno".
\end{itemize}

Of course, seeing is believing. Let's take a look at what this does by focusing in on areas with missing data. Note that I will be using some sub-setting functions here that are described in \adegenet{}'s \textit{Getting Started} vignette. First, let's take a look at what the missing data in R looks like as well as how many loci and individuals the data set nancycats contains. We need to first tell R to look in its library for the package \poppr{}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(poppr)}
\end{alltt}
\end{kframe}
\end{knitrout}

Next, we'll initialize the \adegenet{} data set nancycats and load it into memory.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}
\end{alltt}
\end{kframe}
\end{knitrout}

Now, we'll take a quick look at the nancycats data set using \adegenet{}'s \texttt{summary()} \index{summary} function:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{summary}\hlstd{(nancycats)}
\end{alltt}
\begin{verbatim}
## 
##  # Total number of genotypes:  237 
## 
##  # Population sample sizes:  
##  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 
## 10 22 12 23 15 11 14 10  9 11 20 14 13 17 11 12 13 
## 
##  # Number of alleles per locus:  
## L1 L2 L3 L4 L5 L6 L7 L8 L9 
## 16 11 10  9 12  8 12 12 18 
## 
##  # Number of alleles per population:  
## 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 
## 36 53 50 67 48 56 42 54 43 46 70 52 44 61 42 40 35 
## 
##  # Percentage of missing data:  
## [1] 2.344
## 
##  # Observed heterozygosity:  
##     L1     L2     L3     L4     L5     L6     L7     L8     L9 
## 0.6682 0.6667 0.6793 0.7083 0.6329 0.5654 0.6498 0.6184 0.4515 
## 
##  # Expected heterozygosity:  
##     L1     L2     L3     L4     L5     L6     L7     L8     L9 
## 0.8657 0.7929 0.7953 0.7603 0.8703 0.6885 0.8158 0.7603 0.6063
\end{verbatim}
\end{kframe}
\end{knitrout}


We can see here a lot of summary statistics about nancycats. Here we can see that there are 17 populations, 237 individuals, and 9 loci. Nancycats also has a little over 2.3\% missing data. Let's take a look at the names of the loci and the structure of the data. In order to save space, I will only show you the first five individuals (rows) and a portion of the alleles in the first locus (columns).
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{locNames}\hlstd{(nancycats)}  \hlcom{# Names of the loci}
\end{alltt}
\begin{verbatim}
##      L1      L2      L3      L4      L5      L6      L7      L8      L9 
##  "fca8" "fca23" "fca43" "fca45" "fca77" "fca78" "fca90" "fca96" "fca37"
\end{verbatim}
\begin{alltt}
\hlstd{nancycats}\hlopt{$}\hlstd{tab[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{8}\hlopt{:}\hlnum{13}\hlstd{]}
\end{alltt}
\begin{verbatim}
##     L1.08 L1.09 L1.10 L1.11 L1.12 L1.13
## 001    NA    NA    NA    NA    NA    NA
## 002    NA    NA    NA    NA    NA    NA
## 003   0.0   0.5     0     0     0   0.5
## 004   0.5   0.5     0     0     0   0.0
## 005   0.5   0.5     0     0     0   0.0
\end{verbatim}
\end{kframe}
\end{knitrout}


When looking at this data set, recall how a \texttt{genind} object is formatted. You have a matrix of 0's, 1's and 0.5's. For diploids, if you see 0.5, that means it is heterozygous at that allele, and a 1 means it's homozygous. Here we see three heterozygotes and two individuals with missing data (indicated by NA). Now, there are more places with missing data in the data set, but I'm only showing a little bit at one locus so it's easier to digest. Let's first replace it by zero and mean, respectively.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nanzero} \hlkwb{<-} \hlkwd{missingno}\hlstd{(nancycats,} \hlkwc{type} \hlstd{=} \hlstr{"zero"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
##  Replaced 617 missing values
\end{verbatim}
\begin{alltt}
\hlstd{nanmean} \hlkwb{<-} \hlkwd{missingno}\hlstd{(nancycats,} \hlkwc{type} \hlstd{=} \hlstr{"mean"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
##  Replaced 617 missing values
\end{verbatim}
\begin{alltt}
\hlstd{nanzero}\hlopt{$}\hlstd{tab[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{8}\hlopt{:}\hlnum{13}\hlstd{]}
\end{alltt}
\begin{verbatim}
##     L1.08 L1.09 L1.10 L1.11 L1.12 L1.13
## 001   0.0   0.0     0     0     0   0.0
## 002   0.0   0.0     0     0     0   0.0
## 003   0.0   0.5     0     0     0   0.5
## 004   0.5   0.5     0     0     0   0.0
## 005   0.5   0.5     0     0     0   0.0
\end{verbatim}
\begin{alltt}
\hlstd{nanmean}\hlopt{$}\hlstd{tab[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{8}\hlopt{:}\hlnum{13}\hlstd{]}
\end{alltt}
\begin{verbatim}
##       L1.08  L1.09  L1.10   L1.11   L1.12  L1.13
## 001 0.07604 0.2419 0.1912 0.06221 0.09447 0.1014
## 002 0.07604 0.2419 0.1912 0.06221 0.09447 0.1014
## 003 0.00000 0.5000 0.0000 0.00000 0.00000 0.5000
## 004 0.50000 0.5000 0.0000 0.00000 0.00000 0.0000
## 005 0.50000 0.5000 0.0000 0.00000 0.00000 0.0000
\end{verbatim}
\end{kframe}
\end{knitrout}

You notice how the values of NA changed, yet the basic structure stayed the same. These are the replacement options from \adegenet{}. Let's look at the same example with the exclusion options (set to the default cutoff of 5\%).
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nanloci} \hlkwb{<-} \hlkwd{missingno}\hlstd{(nancycats,} \hlstr{"loci"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
##  Found 617 missing values.
##  2 loci contained missing values greater than 5%.
##  Removing 2 loci : fca8 fca45
\end{verbatim}
\begin{alltt}
\hlstd{nangeno} \hlkwb{<-} \hlkwd{missingno}\hlstd{(nancycats,} \hlstr{"geno"}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
##  Found 617 missing values.
##  38 genotypes contained missing values greater than 5%.
##  Removing 38 genotypes : N215 N216 N188 N189 N190 N191 N192 N298 N299 N300 
## N301 N302 N303 N304 N310 N195 N197 N198 N199 N200 N201 N206 N182 N184 N186 N282 
## N283 N288 N291 N292 N293 N294 N295 N296 N297 N281 N289 N290
\end{verbatim}
\begin{alltt}
\hlstd{nanloci}\hlopt{$}\hlstd{tab[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{8}\hlopt{:}\hlnum{13}\hlstd{]}
\end{alltt}
\begin{verbatim}
##     L1.08 L1.09 L1.10 L1.11 L2.01 L2.02
## 001     0   0.5     0     0     0     0
## 002     0   1.0     0     0     0     0
## 003     0   0.5     0     0     0     0
## 004     0   0.0     0     0     0     0
## 005     0   0.5     0     0     0     0
\end{verbatim}
\end{kframe}
\end{knitrout}


Notice how we now see columns named ``L2.01" and ``L2.02". This is showing us another locus because we have removed the first. Recall from the summary table that the first locus had 16 alleles, and the second had 11. Now that we've removed loci containing missing data, all others have shifted over.\\
Let's look at the loci names and number of individuals.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{nInd}\hlstd{(nanloci)}  \hlcom{# Individuals}
\end{alltt}
\begin{verbatim}
## [1] 237
\end{verbatim}
\begin{alltt}
\hlkwd{locNames}\hlstd{(nanloci)}  \hlcom{# Names of the loci}
\end{alltt}
\begin{verbatim}
##      L1      L2      L3      L4      L5      L6      L7 
## "fca23" "fca43" "fca77" "fca78" "fca90" "fca96" "fca37"
\end{verbatim}
\end{kframe}
\end{knitrout}

You can see that the number of individuals stayed the same but the loci ``fca8", ``fca45", and ``fca96" were removed.\\
Let's look at what happened when we removed individuals.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{nangeno}\hlopt{$}\hlstd{tab[}\hlnum{1}\hlopt{:}\hlnum{5}\hlstd{,} \hlnum{8}\hlopt{:}\hlnum{13}\hlstd{]}
\end{alltt}
\begin{verbatim}
##     L1.08 L1.09 L1.10 L1.11 L1.12 L1.13
## 001   0.0   0.5     0     0     0   0.5
## 002   0.5   0.5     0     0     0   0.0
## 003   0.5   0.5     0     0     0   0.0
## 004   0.0   0.5     0     0     0   0.5
## 005   0.0   1.0     0     0     0   0.0
\end{verbatim}
\begin{alltt}
\hlkwd{nInd}\hlstd{(nangeno)}  \hlcom{# Individuals}
\end{alltt}
\begin{verbatim}
## [1] 199
\end{verbatim}
\begin{alltt}
\hlkwd{locNames}\hlstd{(nangeno)}  \hlcom{# Names of the loci}
\end{alltt}
\begin{verbatim}
##      L1      L2      L3      L4      L5      L6      L7      L8      L9 
##  "fca8" "fca23" "fca43" "fca45" "fca77" "fca78" "fca90" "fca96" "fca37"
\end{verbatim}
\end{kframe}
\end{knitrout}


We can see here that the number of individuals decreased, yet we have the same number of loci. Notice how the frequency matrix changes in both scenarios? In the scenario with ``loci", we removed several columns of the data set, and so with our sub-setting, we see alleles from the second locus. In the scenario with ``geno", we removed several rows of the data set so we see other individuals in our sub-setting.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Can you take me hier(archy)? \{population hierarchy construction\}}
\label{data.manip:hier}

\tab\tab In poppr versions 1.0.x, this section of the manual contained a long
explaination of the function \texttt{splitcombine}.
This was a function whose intended use was to manipulate population hierarchies
within\seclink{intro:genind}{genind}objects, but whose useage ended up becoming 
very clunky and a bit confusing. The function has been superceeded by the hierarchy methods for\seclink{intro:genclone}{genclone}objects. If you want to know more about \texttt{splitcombine}, please see its
help page by typing \texttt{?splitcombine} or refer to earlier versions of this
manual. In this section, we will walk you through the process of defining, 
manipulating, and adding to population hierarchies within genclone objects. 

\subsubsection{General hierarchy method use}
\label{data.manip:hier:method}

\tab\tab There are currently 5 methods that manipulate population hierarchies in
genclone objects:

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sat Mar 22 20:24:23 2014
\begin{table}[ht]
\centering
\begin{tabular}{rllll}
  \hline
 & Method & Function & Input & Result\\ 
  \hline
  1 & set & \texttt{sethierarchy} & data frame & new hierarchy\\ 
  2 & get & \texttt{gethierarchy} & formula & data frame\\ 
  3 & name & \texttt{namehierarchy} & formula & new hierarchy names\\ 
  4 & split & \texttt{splithierarchy} & formula & defined hierarchical levels\\ 
  5 & add & \texttt{addhierarchy} & vector or data frame & new hierarchical level\\
   \hline
\end{tabular}
\end{table}
\noindent
NOTE: Refer to\seclink{intro:genclone:access}{Accessing hierarchies}for more
details on how to access hierarchies.\\

These functions all have a syntax that looks like this:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
newobject <- \hlkwd{function}(object, input)
\end{alltt}
\end{kframe}
\end{knitrout}

Let's take a data set of \textit{Phytophthora infestans} collected from North
America and South America and use that as an example. It has two population 
hierarchies defined, Continent and Country:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Pinf)}
\hlstd{Pinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     2 populations defined - South America North America
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Let's say I wanted to change the hierarchy names to Spanish. I can do that using
\texttt{namehierarchy}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{elPinf} \hlkwb{<-} \hlkwd{namehierarchy}\hlstd{(Pinf,} \hlopt{~}\hlstd{continente}\hlopt{/}\hlstd{pais)}  \hlcom{# Don't forget the formula syntax!}
\hlstd{elPinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - continente pais
##     2 populations defined - South America North America
\end{verbatim}
\begin{alltt}
\hlstd{Pinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     2 populations defined - South America North America
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
The original data set has stayed the same and we now have a new data set with the
names we want.

Of course, it would be silly to create a new data set every time we wanted to
do something like change names. This is why all of the above functions (with the
exception of \texttt{gethierarchy}) all have the replacement syntax of:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{function}(object) <- input
\end{alltt}
\end{kframe}
\end{knitrout}

\noindent
\textbf{NOTE: This is the preferred syntax}.\\ 
\noindent
This allows the object to be edited \textit{in place} and makes things generally
easier. Let's revisit our previous example:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{Pinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     2 populations defined - South America North America
\end{verbatim}
\begin{alltt}
\hlkwd{namehierarchy}\hlstd{(Pinf)} \hlkwb{<-} \hlopt{~}\hlstd{continente}\hlopt{/}\hlstd{pais}
\hlstd{Pinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - continente pais
##     2 populations defined - South America North America
\end{verbatim}
\end{kframe}
\end{knitrout}

While we will mainly be using the replacement syntax in this vignette, the 
advantage to having both systems is that with the 
\texttt{function(object, input)} syntax, you can test manipulation without 
affecting your object.

\subsubsection{Defining populations with hierarchies}
\label{data.manip:hier:setpop}

Of course, these hierarchies would mean nothing if it was difficult or not
possible to define the populations in the data set We notice that above, we have
two hierarchies for Continent and Country, but the populations only show Continent
level populations. If we wanted to investigate each country separately, we would
need to reset the population to be represented by Country. This can be done with
the function \texttt{setpop}.

This function utilizes the defined population hierarchies to set the population.
We'll use our data set above to illustrate this:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{namehierarchy}\hlstd{(Pinf)} \hlkwb{<-} \hlopt{~}\hlstd{Continent}\hlopt{/}\hlstd{Country}
\hlstd{Pinf}  \hlcom{# Still by continent}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     2 populations defined - South America North America
\end{verbatim}
\begin{alltt}
\hlkwd{setpop}\hlstd{(Pinf)} \hlkwb{<-} \hlopt{~}\hlstd{Country}
\hlstd{Pinf}  \hlcom{# Now set by country}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     4 populations defined - Colombia Ecuador Mexico Peru
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
The beauty about it is the fact that it will also combine all the hierarchical
levels you want to use. Let's see when we ask it to set the population of
Country with respect to Continent.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(Pinf)} \hlkwb{<-} \hlopt{~}\hlstd{Continent}\hlopt{/}\hlstd{Country}
\hlstd{Pinf}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    72 multilocus genotypes
##    86 tetraploid individuals
##    11 codominant loci
## 
## Population information:
## 
##     2 population hierarchies - Continent Country
##     4 populations defined - South America_Colombia South America_Ecuador 
## North America_Mexico South America_Peru
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Nice!

Let's see what happens when we want to try to set our population year collected
with respect to country.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(Pinf)} \hlkwb{<-} \hlopt{~}\hlstd{Country}\hlopt{/}\hlstd{Year}
\end{alltt}


{\ttfamily\noindent\bfseries\color{errorcolor}{\#\# Error: One or more levels in the given hierarchy is not present in the data frame. \\\#\# Hierarchy:	 Country, Year \\\#\# Data:		 Continent, Country}}\end{kframe}
\end{knitrout}

\noindent
This didn't work because we don't have Year defined within our hierarchy. In this
case, we would likely have an outside vector defining the year. To define the 
population to just year, we could use the \adegenet{} function \texttt{pop}
to set the population with respect to year, but this would not update the
hierarchy. A better way to do this would be to add year to the hierarchy with the
function \cmdlink{data.manip:hier:manip}{addhierarchy} and define it as above.

\subsubsection{Defining hierarchies}
\label{data.manip:hier:define}

\tab\tab In order to utilize hierarchies, they must be defined. As genind objects
don't inherently define population hierarchies. The user must do so. One way is
to define your hierarchies in a spreadsheet and import that as a data frame using
the function \texttt{read.table}. Another way of automatically
doing so is to concatenate your hierarchies using a common delimiter such as `\_'
and defining that as the population factor in your input file. See the section 
\seclink{intro:import:genalex.short}{Genalex Formatting Shortcuts}for more
details. An example of a formatted GenAlEx file can be found here: 
\url{http://dx.doi.org/10.6084/m9.figshare.877104}. It is an AFLP data set of the
root rot pathogen \texttt{Aphanomyces euteiches}. We will use this data set as 
an example of importing hierarchical data automatically. We will first copy the 
download link from figshare and use it with the function 
\cmdlink{intro:import:read.genalex}{read.genalex}. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{aphan} \hlkwb{<-} \hlkwd{read.genalex}\hlstd{(}\hlstr{"http://files.figshare.com/1314228/rootrot.csv"}\hlstd{)}
\hlstd{aphan}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      1 population hierarchy - Pop
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
We can see that there is 1 hierarchy defined, but the data is defined by field
and soil sample. Since we had imported the hierarchy in a concatenated manner,
we must now use the function \texttt{splithierarchy} to remove the concatenation
and define the names of the hierarchical levels:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{splithierarchy}\hlstd{(aphan)} \hlkwb{<-} \hlopt{~}\hlstd{field}\hlopt{/}\hlstd{sample}
\hlstd{aphan}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Now we have sucessfully defined our hierarchies.

If you have imported your data with a single population and have a separate data
frame that you read in with \texttt{read.table}, this is how you would define
your hierarchy. For demonstrative purposes, we will use the H3N2 viral data set.
This contains a data frame called `x' in the\seclink{intro:genind:other}{other slot}that contains many variables including country, year, and month of collection. \label{data:virus}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(H3N2)}
\hlstd{virus} \hlkwb{<-} \hlkwd{as.genclone}\hlstd{(H3N2)}  \hlcom{# Converting it to a genclone object.}
\hlstd{virus_info} \hlkwb{<-} \hlkwd{as.data.frame}\hlstd{(}\hlkwd{other}\hlstd{(H3N2)}\hlopt{$}\hlstd{x)}  \hlcom{# extracting the data frame}

\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       0 population hierarchies. 
##       0 populations defined.
\end{verbatim}
\begin{alltt}
\hlkwd{names}\hlstd{(virus_info)}
\end{alltt}
\begin{verbatim}
##  [1] "accession"     "length"        "host"          "segment"       "subtype"      
##  [6] "country"       "year"          "Virus name"    "Misc info"     "Age"          
## [11] "Gender"        "date"          "usePreciseLoc" "localisation"  "lon"          
## [16] "lat"           "month"
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Right now, there is no population set, nor are there any hierarchies set. We will
use the function \texttt{sethierarchy} to define the hierarchy of the data set.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sethierarchy}\hlstd{(virus)} \hlkwb{<-} \hlstd{virus_info}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##      17 population hierarchies - accession length host ... localisation lon lat month
##       0 populations defined.
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Now we have hierarchies... a lot of them. Let's say we only wanted year and
country. All we have to do is simply just subset the data frame by those columns
and use \texttt{sethierarchy} again.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sethierarchy}\hlstd{(virus)} \hlkwb{<-} \hlstd{virus_info[}\hlkwd{c}\hlstd{(}\hlstr{"country"}\hlstd{,} \hlstr{"year"}\hlstd{)]}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       2 population hierarchies - country year
##       0 populations defined.
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
We can use the function \texttt{setpop} to set the population to year with
respect to country:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{year}\hlopt{/}\hlstd{country}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       2 population hierarchies - country year
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Viewing hierarchies}
\label{data.manip:hier:view}

If you wanted to view your hierarchies to make sure that you made no spelling
errors in your population definitions, you can extract the data frame from your
genclone object by using the function \texttt{gethierarchy}:

\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
gethierarchy(x, formula = NULL, combine = TRUE)
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
\noindent
Where \textbf{x} is the genclone object, \textbf{formula} defines the hierarchical
levels, and \textbf{combine} indicates whether or not you want the lower levels 
of the hierarchy combined with the higher levels. For example, in the root rot
data above, the hierarchical levels are explicitly hierarchical and should be
combined. Note, if you don't supply a formula argument, the data frame as it
exists will be returned.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{gethierarchy}\hlstd{(aphan))}
\end{alltt}
\begin{verbatim}
##    field sample
## 1 Athena      1
## 2 Athena      1
## 3 Athena      1
## 4 Athena      1
## 5 Athena      1
## 6 Athena      1
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{gethierarchy}\hlstd{(aphan,} \hlopt{~}\hlstd{field}\hlopt{/}\hlstd{sample))}
\end{alltt}
\begin{verbatim}
##    field   sample
## 1 Athena Athena_1
## 2 Athena Athena_1
## 3 Athena Athena_1
## 4 Athena Athena_1
## 5 Athena Athena_1
## 6 Athena Athena_1
\end{verbatim}
\end{kframe}
\end{knitrout}


If the hierarchical levels are not nested, or you simply want to use this
hierarchy for another data set, you might want to set the \textbf{combine} flag
to \texttt{FALSE}. Let's use the virus data as an example:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{gethierarchy}\hlstd{(virus,} \hlopt{~}\hlstd{year}\hlopt{/}\hlstd{country))}
\end{alltt}
\begin{verbatim}
##          year    country
## AB434107 2002 2002_Japan
## AB434108 2002 2002_Japan
## AB438242 2002 2002_Japan
## AB438243 2002 2002_Japan
## AB438244 2002 2002_Japan
## AB438245 2002 2002_Japan
\end{verbatim}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{gethierarchy}\hlstd{(virus,} \hlopt{~}\hlstd{year}\hlopt{/}\hlstd{country,} \hlkwc{combine} \hlstd{=} \hlnum{FALSE}\hlstd{))}
\end{alltt}
\begin{verbatim}
##          year country
## AB434107 2002   Japan
## AB434108 2002   Japan
## AB438242 2002   Japan
## AB438243 2002   Japan
## AB438244 2002   Japan
## AB438245 2002   Japan
\end{verbatim}
\end{kframe}
\end{knitrout}


It will return only the levels you ask it to return:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(}\hlkwd{gethierarchy}\hlstd{(virus,} \hlopt{~}\hlstd{country))}
\end{alltt}
\begin{verbatim}
##          country
## AB434107   Japan
## AB434108   Japan
## AB438242   Japan
## AB438243   Japan
## AB438244   Japan
## AB438245   Japan
\end{verbatim}
\end{kframe}
\end{knitrout}


\subsubsection{Manipulating hierarchies}
\label{data.manip:hier:manip}

Once we have our hierarchies set in place, we want to be able to rename and add
to them. For this example, we will revisit the virus example from above. We have
set the population hierarchy to be based on year and country, but we've noticed
that we left out month. And let's say that we did something stupid like this:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{virus_info} \hlkwb{<-} \hlstd{virus_info[[}\hlstr{"month"}\hlstd{]]}
\hlkwd{names}\hlstd{(virus_info)}
\end{alltt}
\begin{verbatim}
## NULL
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
If we were saving our script the whole time, we could just go back and retrieve
the data frame, but that defeats the purpose of this section where we imagine
that we've recieved new information and wanted to add it to our hierarchy. If we
want to add this to our hierarchy, all we have to do is just use the function
\texttt{addhierarchy}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{addhierarchy}\hlstd{(virus)} \hlkwb{<-} \hlstd{virus_info}
\hlstd{virus}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       3 population hierarchies - country year NEW
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}


Uh oh, we see that the new hierarchical level is called `NEW' when we want it to
be called `month'. When this happens, we can simply just rename the hierarchy
using the function \texttt{namehierarchy}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{namehierarchy}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{year}\hlopt{/}\hlstd{country}\hlopt{/}\hlstd{month}
\hlstd{virus}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       3 population hierarchies - country year month
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}


Of course, we could also use the $f(x, y)$ syntax instead of the assignment 
defined as thus:
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
addhierarchy(x, value, name = "NEW")
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
We notice that there is an argument called \textbf{name}. This will set the name
of our new level. Let's rewind and imagine that we didn't set the hierarchy back
there.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       2 population hierarchies - country year
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
We will use the above syntax to assign the virus information with the name of
the vector.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{virus} \hlkwb{<-} \hlkwd{addhierarchy}\hlstd{(virus, virus_info,} \hlstr{"month"}\hlstd{)}
\hlstd{virus}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       3 population hierarchies - country year month
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
But here's an even easier way:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{addhierarchy}\hlstd{(virus)} \hlkwb{<-} \hlkwd{data.frame}\hlstd{(}\hlkwc{month} \hlstd{= virus_info)}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       3 population hierarchies - country year month
##     102 populations defined - 2002_Japan 2002_USA 2002_Finland ... 2006_Bangladesh 
## 2006_Algeria 2006_Sweden 2006_Greece
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
If we use a data frame to add a population hierarchy, it will be added and all
of the column names will be preserved. This allows you to add multiple hierarchies
at once.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Divide (populations) and conquer (your analysis) \{extract populations\}}
\label{data.manip:divide}

\tab\tab As I've mentioned before, \adegenet{} has many ways of sub-setting the data, but you cannot easily subset a \texttt{genind} object by population in an efficient way. \Poppr{} allows sub-setting a population from a \texttt{genind} object with one command.
\subsubsection{Function: popsub}
\label{data.manip:divide:popsub}

\tab\tab The command \texttt{popsub} is powerful in that it allows you to choose exactly what populations you choose to include or exclude from your analyses. As with many R functions, you can easily use this within a function to avoid creating a new variable to keep track of.  
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
popsub(gid, sublist = "ALL", blacklist = NULL, mat = NULL, drop = TRUE)
\end{verbatim}
\end{kframe}
\end{knitrout}


\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sublist -} The vector of populations or integers representing the populations in your data set you wish to retain. For example: \texttt{sublist = c("pop\_z", "pop\_y")} or \texttt{sublist = 1:2}.
  \item \texttt{blacklist -} The vector of populations or integers representing the populations in your data set you wish to exclude. This can take the same type of arguments as sublist, and can be used in conjunction with sublist for when you want a range of populations, but know that there is one in there that you do not want to analyze. For example: \texttt{sublist = 1:15, blacklist = "pop\_x"}.
  One very useful thing about the blacklist is that it allows the user to be extremely paranoid about the data. You can set the blacklist to contain populations that are not even in your data set and it will still work!
  \item \texttt{mat -} (see section\seclink{mlg}{Multilocus Genotype Analysis}for more information) This is where you would put a matrix that's produced by \texttt{mlg.table} to be subsetted instead of the genind object. If you do this, the matrix will return with only the rows equal to your populations and only the multilocus genotypes (columns) pertaining to those populations. 
\end{itemize}

To demonstrate this tool, let's revisit the \seclink{data:virus}{virus data} set that we saw in\seclink{data.manip:hier:define}{Defining hierarchies.}Let's say we wanted to analyze only the data in North America. To make sure we are all on the same page, we will reset the population factor to ``country".
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{country}
\hlstd{virus}\hlopt{$}\hlstd{pop.names}  \hlcom{# Only two countries from North America.}
\end{alltt}
\begin{verbatim}
##  [1] "Japan"          "USA"            "Finland"        "China"          "South Korea"   
##  [6] "Norway"         "Taiwan"         "France"         "Latvia"         "Netherlands"   
## [11] "Bulgaria"       "Turkey"         "United Kingdom" "Denmark"        "Austria"       
## [16] "Canada"         "Italy"          "Russia"         "Bangladesh"     "Egypt"         
## [21] "Germany"        "Romania"        "Ukraine"        "Czech Republic" "Greece"        
## [26] "Iceland"        "Ireland"        "Sweden"         "Nepal"          "Saudi Arabia"  
## [31] "Switzerland"    "Iran"           "Mongolia"       "Spain"          "Slovenia"      
## [36] "Croatia"        "Algeria"
\end{verbatim}
\begin{alltt}
\hlstd{vna} \hlkwb{<-} \hlkwd{popsub}\hlstd{(virus,} \hlkwc{sublist} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"USA"}\hlstd{,} \hlstr{"Canada"}\hlstd{))}
\hlstd{vna}\hlopt{$}\hlstd{pop.names}
\end{alltt}
\begin{verbatim}
##       P1       P2 
##    "USA" "Canada"
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Since this is a larger data set, running the \texttt{summary} function might take a few seconds longer than we want it to. If we want to see the population size, we can use the \adegenet{} function \texttt{nInd()}:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{nInd}\hlstd{(vna)}
\end{alltt}
\begin{verbatim}
## [1] 665
\end{verbatim}
\begin{alltt}
\hlkwd{nInd}\hlstd{(virus)}
\end{alltt}
\begin{verbatim}
## [1] 1903
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
You can see that the population factors are correct and that the size of the data set is considerably smaller. Let's see the data set without the North American countries.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vnaminus} \hlkwb{<-} \hlkwd{popsub}\hlstd{(virus,} \hlkwc{blacklist} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"USA"}\hlstd{,} \hlstr{"Canada"}\hlstd{))}
\hlstd{vnaminus}\hlopt{$}\hlstd{pop.names}
\end{alltt}
\begin{verbatim}
##              P01              P02              P03              P04              P05 
##          "Japan"        "Finland"          "China"    "South Korea"         "Norway" 
##              P06              P07              P08              P09              P10 
##         "Taiwan"         "France"         "Latvia"    "Netherlands"       "Bulgaria" 
##              P11              P12              P13              P14              P15 
##         "Turkey" "United Kingdom"        "Denmark"        "Austria"          "Italy" 
##              P16              P17              P18              P19              P20 
##         "Russia"     "Bangladesh"          "Egypt"        "Germany"        "Romania" 
##              P21              P22              P23              P24              P25 
##        "Ukraine" "Czech Republic"         "Greece"        "Iceland"        "Ireland" 
##              P26              P27              P28              P29              P30 
##         "Sweden"          "Nepal"   "Saudi Arabia"    "Switzerland"           "Iran" 
##              P31              P32              P33              P34              P35 
##       "Mongolia"          "Spain"       "Slovenia"        "Croatia"        "Algeria"
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
Let's make sure that the number of individuals in both data sets added up equals the number of individuals in our original data set:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{(}\hlkwd{nInd}\hlstd{(vnaminus)} \hlopt{+} \hlkwd{nInd}\hlstd{(vna))} \hlopt{==} \hlkwd{nInd}\hlstd{(virus)}
\end{alltt}
\begin{verbatim}
## [1] TRUE
\end{verbatim}
\end{kframe}
\end{knitrout}


Now we have data sets with and without North America. Let's try something a bit more challenging. Let's say that we want The first 10 populations in alphabetical order, but we know that we still don't want any countries in North America. We can easily do this by using the \textit{base} function \texttt{sort}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{vsort} \hlkwb{<-} \hlkwd{sort}\hlstd{(virus}\hlopt{$}\hlstd{pop.names)[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}
\hlstd{vsort}
\end{alltt}
\begin{verbatim}
##  [1] "Algeria"        "Austria"        "Bangladesh"     "Bulgaria"       "Canada"        
##  [6] "China"          "Croatia"        "Czech Republic" "Denmark"        "Egypt"
\end{verbatim}
\begin{alltt}
\hlstd{valph} \hlkwb{<-} \hlkwd{popsub}\hlstd{(virus,} \hlkwc{sublist} \hlstd{= vsort,} \hlkwc{blacklist} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"USA"}\hlstd{,} \hlstr{"Canada"}\hlstd{))}
\hlstd{valph}\hlopt{$}\hlstd{pop.names}
\end{alltt}
\begin{verbatim}
##               P1               P2               P3               P4               P5 
##          "China"       "Bulgaria"        "Denmark"        "Austria"     "Bangladesh" 
##               P6               P7               P8               P9 
##          "Egypt" "Czech Republic"        "Croatia"        "Algeria"
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
And that, is how you subset your data with poppr!
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Attack of the clone correction \{clone-censor data sets\}}
\label{data.manip:cc}

\tab\tab Clone correction refers to the ability of keeping one observation per
clone in a given population (or sub-population). Clone correcting can be
hazardous if its done by hand (even on small data sets) and it requires a
defined population hierarchy to get relevant results. \Poppr{} has a clone
correcting function that is able to correct at the lowest level of any defined
population hierarchy. Note that clone correction in \poppr{} is sensitive
to missing data, as it treats all missing data as a single extra allele.
\subsubsection{Function: clonecorrect}
\label{data.manip:cc:clonecorrect}

\tab\tab This function will return a clone corrected data set corrected for the
lowest population level. Population levels are specified with the \texttt{hier}
flag. You can choose to combine the population hierarchy to analyze at the
lowest population level by choosing \texttt{combine = TRUE}.

\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
clonecorrect(pop, hier = 1, dfname = "population_hierarchy", 
    combine = FALSE, keep = 1)
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genclone} object with a defined hierarchy or a
   \texttt{genind} object that has a population hierarchy data frame in the 
   \texttt{@other} slot. Note, the \texttt{genind} object does not necessarily 
   require a population factor to begin with. 
  \item \texttt{hier -} A formula where the levels representing the hierarchical
   levels in your data. 
  \item \texttt{dfname -} \textbf{Only for use in genind objects, otherwise, deprecated}
   The name of a data frame you have in the \texttt{@other} slot with the population factors. 
  \item \texttt{combine -} Do you want to combine the population hierarchy? 
   If it's set to \texttt{FALSE} (default), you will be returned an object with 
   the top most hierarchical level as a population factor unless the \textbf{keep}
   argument is defined. If set to \texttt{TRUE}, the hierarchy will be returned
   combined. 
  \item \texttt{keep -} This flag is to be used if you set \texttt{combine = FALSE}. 
   This will tell clone correct to return a specific combination of your hierarchy
   defined as integers.
   For example, imagine a hierarchy that needs to be clone corrected at three levels: 
   \textit{Population} by \textit{Year} by \textit{Month}. If you wanted to only 
   run an analysis on the \textit{Population} level, you would set \texttt{keep = 1} 
   since \textit{Population} is the first level of the hierarchy. On the other hand, 
   if you wanted to run analysis on \textit{Year} by \textit{Month}, you would set 
   \texttt{keep = 2:3} since those are the second and third levels of the hierarchy. 
\end{itemize}

Let's look at ways to clone-correct our data. We'll look at our \textit{A. euteichies} 
data that we loaded earlier in the section\seclink{data.manip:hier}{Can you take
me hier(archy)} since that data set is known to include clonal populations 
\cite{Grunwald:2006}. Normally, we will assign the clone corrected data to a new
variable, but we will not do so for this demonstration. As the data sets pass by,
notice how many individuals and multilocus genotypes we have in the genclone
object.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{aphan}  \hlcom{# Original object}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    187 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}

Correcting by sample with respect to field and keeping field as the population.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{clonecorrect}\hlstd{(aphan,} \hlkwc{hier} \hlstd{=} \hlopt{~}\hlstd{field}\hlopt{/}\hlstd{sample)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    141 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##      2 populations defined - Athena Mt. Vernon
\end{verbatim}
\end{kframe}
\end{knitrout}

Keeping both field and sample
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{clonecorrect}\hlstd{(aphan,} \hlkwc{hier} \hlstd{=} \hlopt{~}\hlstd{field}\hlopt{/}\hlstd{sample,} \hlkwc{combine} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    141 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}

Keeping only the sample
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{clonecorrect}\hlstd{(aphan,} \hlkwc{hier} \hlstd{=} \hlopt{~}\hlstd{field}\hlopt{/}\hlstd{sample,} \hlkwc{keep} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    141 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##     10 populations defined - 1 2 3 ... 7 8 9 10
\end{verbatim}
\end{kframe}
\end{knitrout}

Correcting by field
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{clonecorrect}\hlstd{(aphan,} \hlkwc{hier} \hlstd{=} \hlopt{~}\hlstd{field)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    120 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##      2 populations defined - Athena Mt. Vernon
\end{verbatim}
\end{kframe}
\end{knitrout}

Correcting over whole data set
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{clonecorrect}\hlstd{(aphan,} \hlkwc{hier} \hlstd{=} \hlnum{NA}\hlstd{)}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##    119 multilocus genotypes
##    119 diploid individuals
##     56 dominant loci
## 
## Population information:
## 
##      2 population hierarchies - field sample
##     18 populations defined - Athena_1 Athena_2 Athena_3 ... Mt. Vernon_5 Mt. Vernon_6 
## Mt. Vernon_7 Mt. Vernon_8
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
That, in a nutshell is clone correction. Note that you can use this to create 
new data sets, but also that the function\cmdlink{summary:poppr}{poppr}also
utilizes this function internally. 

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Every day I'm shuffling (data sets)  \{permutations and bootstrap resampling\}}
\label{data.manip:shuffle}

\tab\tab A common null hypothesis for populations with mixed reproductive modes is panmixia, or to put it simply: lots of sex. A handy way to test for that is permutation analysis to assess random linkage among loci whereupon you randomly shuffle your data. \Poppr{} uses randomly shuffled data sets in order to calculate P-values for the index of association ($I_A$ and $\bar r_d$) \cite{Agapow:2001}. Since there might be other tests where a permutation analysis would be pertinent, a shuffler for \texttt{genind} objects was created with four shuffling schemes: two schemes shuffling without replacement and two shuffling with replacement. Details below.
\subsubsection{Function: shufflepop}
\label{data.manip:shuffle:shufflepop}
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
shufflepop(pop, method = 1)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{shufflepop(pop, method = 1)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{method -} a number indicating the method of sampling you wish to use. 
  The following methods are available for use:
  \begin{enumerate}
    \item \textbf{Permute Alleles (default)} This is a sampling scheme that will permute alleles within the locus. For example, a single diploid locus with four alleles (1, 2, 3, 4) with the frequencies of 0.1, 0.2, 0.3, and 0.4, respectively:
% <<shuffle_mat, echo=FALSE>>=
% exmat <- matrix(c(4,4,
%          4,1,
%          4,3,
%          2,2,
%          3,3), 5, byrow=TRUE)
% exmat
% @
% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:52:35 2014
\begin{table}[h!]
\centering
\begin{tabular}{lc}
          \hline
            & A1/A2 \\ 
          \hline
          1 & 4/4 \\ 
          2 & 4/1 \\ 
          3 & 4/3 \\ 
          4 & 2/2 \\ 
          5 & 3/3 \\ 
           \hline
        \end{tabular}
        \caption{Original}
        \label{tab:original}
\end{table}
\newpage
Might become
\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
            & A1/A2 \\ 
          \hline
          1 & 3/4 \\ 
          2 & 2/3 \\ 
          3 & 4/4 \\ 
          4 & 2/1 \\ 
          5 & 3/4 \\ 
           \hline
        \end{tabular}
        \caption{Permute 1}
        \label{tab:singlebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 2/4 \\ 
          3 & 3/4 \\ 
          4 & 4/3 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Permute 2}
        \label{tab:twobest}
    \end{minipage}
}}
\end{table}

As you can see, The heterozygosity has changed, yet the allelic frequencies remain the same. Overall this would show you, for example, what would happen if the sample you had underwent panmixis within this sample itself. 
    \item \textbf{Parametric Bootstrap} The previous scheme reshuffled the observed sample, but the parametric bootstrap draws samples from a multinomial distribution using the observed allele frequencies as weights. Here are two samples to show you what I mean.
% <<param_boot, echo=FALSE>>=
% set.seed(1001)
% cat("First Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% cat("Second Sample")
% matrix(sample(1:4, 10, prob=c(0.1,0.2,0.3,0.4), replace=TRUE), 5, byrow=T)
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/3 \\ 
          3 & 3/2 \\ 
          4 & 4/4 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Parametric 1}
        \label{tab:param1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 3/4 \\ 
          2 & 2/3 \\ 
          3 & 4/2 \\ 
          4 & 4/4 \\ 
          5 & 4/2 \\ 
           \hline
        \end{tabular}
        \caption{Parametric 2}
        \label{tab:param2}
    \end{minipage}
}}
\end{table}

Notice how the heterozygosity has changed along with the allelic frequencies. The frequencies for alleles 3 and 4 have switched in the first data set, and we've lost allele 1 in the second data set purely by chance! This type of sampling scheme attempts to show you what the true population would look like if it were panmictic and your original sample gave you a basis for estimating expected allele frequencies. Since estimates are made from the observed allele frequencies, small samples will produce skewed results.
    \item \textbf{Non-Parametric Bootstrap} The third method is sampling with replacement, again drawing from a multinomial distribution, but with no assumption about the allele frequencies. 
% <<boot, echo=FALSE>>=
% set.seed(1001)
% matrix(sample(1:4, 10, prob=rep(1, 4), replace=TRUE), 5, byrow=T)
% @

% latex table generated in R 3.0.3 by xtable 1.7-3 package
% Sun Mar 23 11:57:06 2014

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/3 \\ 
          3 & 3/1 \\ 
          4 & 2/2 \\ 
          5 & 3/1 \\ 
           \hline
        \end{tabular}
        \caption{Non-parametric 1}
        \label{tab:nonparam1}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 1/3 \\ 
          2 & 3/1 \\ 
          3 & 2/3 \\ 
          4 & 2/1 \\ 
          5 & 4/3 \\ 
           \hline
        \end{tabular}
        \caption{Non-parametric 2}
        \label{tab:nonparam2}
    \end{minipage}
}}
\end{table}

Again, heterozygosity and allele frequencies are not maintained, but now all of the alleles have a 1 in 4 chance of being chosen.
    \item \textbf{Multilocus permutation} This is called Multilocus permutation because it does the same thing as the permutation analysis in the program \textit{multilocus} by Paul Agapow and Austin Burt \cite{Agapow:2001}. This will shuffle the genotypes at each locus. Using our example above, here it is shuffled with method 4:
% <<multilocus_shuffle,echo=FALSE>>=
% set.seed(1001)
% exmat[sample(1:5), ]
% @

\begin{table}[h!]
\centering
\makebox[0pt][c]{\parbox{\textwidth}{%
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 3/3 \\ 
          2 & 4/1 \\ 
          3 & 2/2 \\ 
          4 & 4/4 \\ 
          5 & 4/3 \\ 
           \hline
        \end{tabular}
        \caption{ML 1}
        \label{tab:singlebest}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{0.45\hsize}\centering
        \begin{tabular}{lc}
          \hline
         & A1/A2 \\ 
          \hline
        1 & 4/4 \\ 
          2 & 2/2 \\ 
          3 & 3/3 \\ 
          4 & 4/3 \\ 
          5 & 4/1 \\ 
           \hline
        \end{tabular}
        \caption{ML 2}
        \label{tab:twobest}
    \end{minipage}
}}
\end{table}

Note that you have the same genotypes after shuffling, so at each locus, you will maintain the same allelic frequencies and heterozygosity. So, in this sample, you will only see a homozygote with allele 2. This also ensures that the P-values associated with $I_A$ and $\bar r_d$ are exactly the same (for an explanation, see the end of\seclink{index:iard:ia}{Function: ia}in this manual). Unfortunately, if you are trying to simulate a sexual population, this does not make much biological sense as it assumes that alleles are not independently assorting within individuals.
  \end{enumerate}
\end{itemize}
These shuffling schemes have been implemented for the index of association, but there may be other summary statistics you can use \texttt{shufflepop} for. All you have to do is use the function \texttt{replicate}. Let's use average\seclink{index:bruvo}{Bruvo's distance}with the first population of the data set \texttt{nancycats} as an example:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}
\hlstd{nan1} \hlkwb{<-} \hlkwd{popsub}\hlstd{(nancycats,} \hlnum{1}\hlstd{)}
\hlstd{reps} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{2}\hlstd{,} \hlnum{9}\hlstd{)}  \hlcom{# Assuming dinucleotide repeats.}
\hlstd{observed} \hlkwb{<-} \hlkwd{mean}\hlstd{(}\hlkwd{bruvo.dist}\hlstd{(nan1,} \hlkwc{replen} \hlstd{= reps))}
\hlstd{observed}
\end{alltt}
\begin{verbatim}
## [1] 0.4181
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{9999}\hlstd{)}
\hlstd{bd.test} \hlkwb{<-} \hlkwd{replicate}\hlstd{(}\hlnum{999}\hlstd{,} \hlkwd{mean}\hlstd{(}\hlkwd{bruvo.dist}\hlstd{(}\hlkwd{shufflepop}\hlstd{(nan1,} \hlkwc{method} \hlstd{=} \hlnum{2}\hlstd{),} \hlkwc{replen} \hlstd{= reps)))}
\end{alltt}
\end{kframe}
\end{knitrout}



You could use this method to replicate the resampling 999 times and then create a histogram to visualize a distribution of what would happen under different assumptions of panmixia.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{hist}\hlstd{(bd.test,} \hlkwc{xlab} \hlstd{=} \hlstr{"Bruvo's Distance"}\hlstd{,} \hlkwc{main} \hlstd{=} \hlstr{"Average Bruvo's distance over 999 randomizations"}\hlstd{)}
\hlkwd{abline}\hlstd{(}\hlkwc{v} \hlstd{= observed,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{)}
\hlkwd{legend}\hlstd{(}\hlstr{"topleft"}\hlstd{,} \hlkwc{legend} \hlstd{=} \hlstr{"observed"}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"red"}\hlstd{,} \hlkwc{lty} \hlstd{=} \hlnum{1}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.5\linewidth]{figure/bd_histogram} 

}



\end{knitrout}


%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Cut It Out!  \{removing uninformative loci\}}
\label{data.manip:informloci}
 \tab\tab Phylogenetically uninformative loci are those that have only one sample differentiating from the rest. This can lead to biased results when using multilocus analyses such as the index of association (See\seclink{index:iard}{The missing linkage disequilibrium}and\seclink{summary}{I know what you did last summary table}). These nuisance loci can be removed with the following function.
\subsubsection{Function: informloci}
\label{data.manip:informloci:informloci}
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
informloci(pop, cutoff = 2/nInd(pop), quiet = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{informloci(pop, cutoff = 2/nInd(pop), quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{cutoff -} this represents the minimum fraction of individuals needed for a locus to be considered informative. The default is set to $2/n$ with $n$ being the number of individuals in the data set (represented by the \adegenet{} function \texttt{nInd}). Essentially, this means that any locus with fewer than 2 observations differing will be removed. The user can also specify a fraction of observations for the cutoff (eg. 0.05).
    \item \texttt{quiet -} if \texttt{TRUE}, nothing will be printed to the screen, if \texttt{FALSE} (default), the cutoff value in percentage and number of individuals will be printed as well as the names of the uninfomrative loci found. 
  \end{itemize}

Here's a quick example using the H3N2 virus SNP data set. We will only retain loci that have a minor allele frequency of $\geq 5\%$
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(H3N2)}
\hlstd{H.five} \hlkwb{<-} \hlkwd{informloci}\hlstd{(H3N2,} \hlkwc{cutoff} \hlstd{=} \hlnum{0.05}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## cutoff value: 5 percent ( 95 individuals ).
##  47 uninfomative loci found: 157 
## 177 233 243 262 267 280 303 313 327 357 382 384 399 412 418 424 425 429 433 451 
## 470 529 546 555 557 564 576 592 595 597 602 612 627 642 647 648 654 658 663 667 
## 681 717 806 824 837 882
\end{verbatim}
\end{kframe}
\end{knitrout}

Now what happens when you have all informative loci. We'll use the nancycats
data set, which has microsatellite loci. It is important to note that this is
searching for loci with a specified genotype frequency as fixed heterozygous sites are also uninformative:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}
\hlstd{naninform} \hlkwb{<-} \hlkwd{informloci}\hlstd{(nancycats,} \hlkwc{cutoff} \hlstd{=} \hlnum{0.05}\hlstd{)}
\end{alltt}
\begin{verbatim}
## cutoff value: 5 percent ( 12 individuals ).
## No sites found with fewer than 12 different individuals.
\end{verbatim}
\end{kframe}
\end{knitrout}


%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Multilocus Genotype Analysis}
\label{mlg}

\tab\tab In populations with mixed sexual and clonal reproduction, it is not uncommon to have multiple samples from the same population have the same genotype across multiple loci (multilocus genotype, MLG). Here, we introduce tools for tracking MLGs within and across populations in\seclink{genind}{intro:genind}objects from the \adegenet{} package. We will be using the\seclink{data:virus}{virus}data set which SNP data from isolates of the H3N2 virus from 2002 to 2006. Note that genclone objects are optimal for these analyses.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Just a peek \{How many multilocus genotypes are in our data set?\}}
\label{mlg:mlg}
\tab\tab Counting the number of multilocus genotypes in a population is the first step for these analyses as they allow one to quickly see how many clones
exist. With the\seclink{intro:genclone}{genclone}object, This information is
already displayed when we view the object.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{virus}
\end{alltt}
\begin{verbatim}
## 
## This is a genclone object
## -------------------------
## Genotype information:
## 
##     752 multilocus genotypes
##    1903 haploid individuals
##     125 codominant loci
## 
## Population information:
## 
##       3 population hierarchies - country year month
##      37 populations defined - Japan USA Finland ... Spain Slovenia Croatia Algeria
\end{verbatim}
\end{kframe}
\end{knitrout}

\noindent
If we need to store the number of MLGs as a variable, we can simply run the \texttt{mlg} command.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{virus_mlg} \hlkwb{<-} \hlkwd{mlg}\hlstd{(virus)}
\end{alltt}
\begin{verbatim}
## #############################
## # Number of Individuals:  1903 
## # Number of MLG:  752 
## #############################
\end{verbatim}
\begin{alltt}
\hlstd{virus_mlg}
\end{alltt}
\begin{verbatim}
## [1] 752
\end{verbatim}
\end{kframe}
\end{knitrout}

\label{mlg:mlg:mlg}

We can see that since the number of individuals exceeds the number of multilocus genotypes, this data set contains clones. Let's take a look at where those clones are with respect to populations.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Clone-ing around \{MLGs across populations\}}
\label{mlg:cross}

\tab\tab Since you have the ability to change the population structure of your data set freely, it is quite possible to see some of the same MLGs across different populations. Tracking them by hand can be a nightmare with large data sets. Luckily, \texttt{mlg.crosspop} has you covered in that regard.
\subsubsection{Function: mlg.crosspop}
\label{mlg:cross:mlg.crosspop}

\tab\tab Analyze the MLGs that cross populations within your data set. This has three output modes. The default one gives a list of MLGs, and for each MLG, it gives a named numeric vector indicating the abundance of that MLG in each population. Alternate outputs are described with \texttt{indexreturn} and \texttt{df}.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
mlg.crosspop(pop, sublist = "ALL", blacklist = NULL, mlgsub = NULL, 
    indexreturn = FALSE, df = FALSE, quiet = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{sublist -} see\cmdlink{mlg:table:mlg.table}{mlg.table.}Analyze specified populations.
    \item \texttt{blacklist -} see\cmdlink{mlg:table:mlg.table}{mlg.table.}Do not include specified populations.
    \item \texttt{mlgsub -} see\cmdlink{mlg:table:mlg.table}{mlg.table.}Only analyze specified MLGs. The vector for this flag can be produced by this function as you will see later in this vignette.
    \item \texttt{indexreturn -} return a vector of indices of MLGs. (You can use these in the \texttt{mlgsub} flag, or you can use them to subset the columns of an MLG table). 
    \item \texttt{df -} return a data frame containing the MLGs, the populations they cross, and the number of copies you find in each population. This is useful for making graphs in \textit{ggplot2}.
    \item \texttt{quiet -} \texttt{TRUE} or \texttt{FALSE}. Should the populations be printed to screen as they are processed? (will print nothing if \texttt{indexreturn} is \texttt{TRUE})
  \end{itemize}
  
We can see what Multilocus Genotypes cross different populations and then give a vector that shows how many populations each multi-population MLG crosses.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{country}
\hlstd{v.dup} \hlkwb{<-} \hlkwd{mlg.crosspop}\hlstd{(virus,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Here is a snippet of what the output looks like when \texttt{quiet} is \texttt{FALSE}. It will print out the MLG name, the total number of individuals that make up that MLG, and the populations where that MLG can be found.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## MLG.3: (12 inds) USA Denmark 
## MLG.9: (16 inds) Japan USA Finland Denmark 
## MLG.31: (9 inds) Japan Canada 
## MLG.75: (23 inds) Japan USA Finland Norway Denmark Austria Russia Ireland 
## MLG.80: (2 inds) USA Denmark 
## MLG.86: (7 inds) Denmark Austria 
## MLG.95: (2 inds) USA Bangladesh 
## MLG.97: (8 inds) USA Austria Bangladesh Romania 
## MLG.104: (3 inds) USA France 
## MLG.110: (16 inds) Japan USA China
\end{verbatim}
\end{kframe}
\end{knitrout}

The output of this function is a list of MLGs, each containing a vector indicating the number of copies in each population. We'll count the number of populations each MLG crosses using the function \texttt{sapply} with \texttt{length}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{head}\hlstd{(v.dup)}
\end{alltt}
\begin{verbatim}
## $MLG.3
##     USA Denmark 
##       4       8 
## 
## $MLG.9
##   Japan     USA Finland Denmark 
##       1      13       1       1 
## 
## $MLG.31
##  Japan Canada 
##      2      7 
## 
## $MLG.75
##   Japan     USA Finland  Norway Denmark Austria  Russia Ireland 
##       2       8       2       1       6       2       1       1 
## 
## $MLG.80
##     USA Denmark 
##       1       1 
## 
## $MLG.86
## Denmark Austria 
##       3       4
\end{verbatim}
\begin{alltt}
\hlstd{v.num} \hlkwb{<-} \hlkwd{sapply}\hlstd{(v.dup, length)}  \hlcom{# count the number of populations each MLG crosses.}
\hlstd{v.num}
\end{alltt}
\begin{verbatim}
##   MLG.3   MLG.9  MLG.31  MLG.75  MLG.80  MLG.86  MLG.95  MLG.97 MLG.104 MLG.110 MLG.119 
##       2       4       2       8       2       2       2       4       2       3       2 
## MLG.149 MLG.158 MLG.163 MLG.205 MLG.206 MLG.207 MLG.210 MLG.213 MLG.221 MLG.224 MLG.227 
##       2       6       2       2       3       2       2       4       2       3       3 
## MLG.234 MLG.241 MLG.244 MLG.246 MLG.252 MLG.253 MLG.258 MLG.274 MLG.277 MLG.283 MLG.285 
##       6       3       2      10       2       9       2       5       3       3       2 
## MLG.290 MLG.291 MLG.314 MLG.315 MLG.317 MLG.321 MLG.325 MLG.326 MLG.334 MLG.344 MLG.350 
##       3       2       2       3       3       2       2       2       2       2       2 
## MLG.368 MLG.370 MLG.381 MLG.401 MLG.405 MLG.417 MLG.439 MLG.453 MLG.461 MLG.471 MLG.508 
##       3       2       3       3       3       5       2       2       3       2       3 
## MLG.529 MLG.530 MLG.540 MLG.548 MLG.552 MLG.556 MLG.570 MLG.578 MLG.580 MLG.582 MLG.589 
##       5       3       3       2       2       2       2       2       2       2       2 
## MLG.597 MLG.605 MLG.611 MLG.615 MLG.619 MLG.620 MLG.621 
##       2       3       2       2       2       4       2
\end{verbatim}
\end{kframe}
\end{knitrout}

%\newpage
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Bringing something to the table \{producing MLG tables and graphs\}}
\label{mlg:table}

We can also create a table of multilocus genotypes per population as well as bar graphs to give us a visual representation of the data. This is achieved through the function \texttt{mlg.table}
\subsubsection{Function: mlg.table}
\label{mlg:table:mlg.table}

\tab\tab Produce a matrix containing counts of MLGs (columns) per population (rows). If there is no population structure to your data set, a vector will be produced instead.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
mlg.table(pop, sublist = "ALL", blacklist = NULL, mlgsub = NULL, 
    bar = TRUE, total = FALSE, quiet = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{mlg.table(pop, sublist = "ALL", blacklist = NULL, mlgsub = NULL, bar = TRUE, total = FALSE, quiet = FALSE)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
    \item \texttt{sublist -} a vector indicating which specific populations you want to produce a table for. This can be a numeric or character vector. See\cmdlink{data.manip:divide:popsub}{popsub}for details.
    \item \texttt{blacklist -} a vector indicating which specific populations you do not want to include in your table. This can be a numeric or character vector, and does not necessarily have to be the same type as \texttt{sublist}. eg. \texttt{sublist=1:10, blacklist="USA"}. See\cmdlink{data.manip:divide:popsub}{popsub}for details.
    \item \texttt{mlgsub -} a vector containing the indices of MLGs you wish to subset your table with. 
    \item \texttt{bar -} \texttt{TRUE} or \texttt{FALSE}. If  \texttt{TRUE}, a bar plot will be printed for each population with more than one individual. 
    \item \texttt{total -} \texttt{TRUE} or \texttt{FALSE}. Should the entire data set be included in the table? This is equivalent to evoking \texttt{colSums} on the table.
    \item \texttt{quiet -} \texttt{TRUE} or \texttt{FALSE}. When \texttt{bar} is \texttt{TRUE}, should the populations be printed to screen as they are processed?
  \end{itemize}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{v.tab} \hlkwb{<-} \hlkwd{mlg.table}\hlstd{(virus,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{bar} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlstd{v.tab[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{]}  \hlcom{# Showing the first 10 columns and rows of the table.}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##             MLG.1 MLG.2 MLG.3 MLG.4 MLG.5 MLG.6 MLG.7 MLG.8 MLG.9 MLG.10
## Japan           0     0     0     0     0     0     1     2     1      0
## USA             0     2     4     1     1     0     0     0    13      0
## Finland         0     0     0     0     0     0     0     0     1      0
## China           0     0     0     0     0     0     0     0     0      0
## South Korea     0     0     0     0     0     1     0     0     0      0
## Norway          1     0     0     0     0     0     0     0     0      0
## Taiwan          0     0     0     0     0     0     0     0     0      0
## France          0     0     0     0     0     0     0     0     0      0
## Latvia          0     0     0     0     0     0     0     0     0      0
## Netherlands     0     0     0     0     0     0     0     0     0      0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a bar-chart produced by \texttt{mlg.table}. Note that this data set would produce several such charts.}
  \label{nortable}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/mlgbarplot} 

}



\end{knitrout}

\end{figure}
\newpage

The MLG table is not restricted for use with just \Poppr{}. One of the main advantages of the function \texttt{mlg.table} is that it allows easy access to diversity functions present in the package \textit{vegan} \cite{vegan}. One very simple example is to create a rarefaction curve for each population in your data set giving the number of expected MLGs for a given sample size. For more information, type \texttt{help("diversity", package="vegan")} in your R console.

For the sake of a simple example, instead of drawing a curve for each of the 37 countries represented in this sample, let's change the population structure to be the different years of the epidemics. 
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{year}
\hlkwd{summary}\hlstd{(virus)}  \hlcom{# Check the data to make sure it's correct.}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
##  # Total number of genotypes:  1903
## 
##  # Population sample sizes:  
## 2002 2003 2004 2005 2006 
##  158  415  399  469  462 
## 
##  # Number of alleles per locus:  
## L001 L002 L003 L004 L005 L006 L007 L008 L009 L010 L011 L012 L013 L014 L015 L016 L017 L018 
##    3    3    4    2    4    2    3    2    4    3    4    2    4    3    2    2    3    3 
## L019 L020 L021 L022 L023 L024 L025 L026 L027 L028 L029 L030 L031 L032 L033 L034 L035 L036 
##    2    2    3    3    3    2    2    2    2    2    2    2    2    2    2    4    4    3 
## L037 L038 L039 L040 L041 L042 L043 L044 L045 L046 L047 L048 L049 L050 L051 L052 L053 L054 
##    3    3    4    2    2    2    4    3    2    3    4    2    3    2    3    2    2    2 
## L055 L056 L057 L058 L059 L060 L061 L062 L063 L064 L065 L066 L067 L068 L069 L070 L071 L072 
##    4    2    2    2    2    2    2    2    4    4    4    3    3    2    3    4    3    2 
## L073 L074 L075 L076 L077 L078 L079 L080 L081 L082 L083 L084 L085 L086 L087 L088 L089 L090 
##    3    3    3    3    2    3    2    4    2    3    2    2    3    3    3    3    2    2 
## L091 L092 L093 L094 L095 L096 L097 L098 L099 L100 L101 L102 L103 L104 L105 L106 L107 L108 
##    2    2    3    2    3    2    3    2    3    2    3    3    2    2    2    3    2    2 
## L109 L110 L111 L112 L113 L114 L115 L116 L117 L118 L119 L120 L121 L122 L123 L124 L125 
##    2    3    3    3    2    2    3    3    3    3    4    2    3    3    4    3    2 
## 
##  # Number of alleles per population:  
##   1   2   3   4   5 
## 203 255 232 262 240 
## 
##  # Percentage of missing data:  
## [1] 2.363
## 
##  # Observed heterozygosity:  
## [1] 0
## 
##  # Expected heterozygosity:  
## [1] 0
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(vegan)}
\hlstd{H.year} \hlkwb{<-} \hlkwd{mlg.table}\hlstd{(virus,} \hlkwc{bar} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\hlkwd{rarecurve}\hlstd{(H.year,} \hlkwc{ylab} \hlstd{=} \hlstr{"Multilocus genotypes expected"}\hlstd{,} \hlkwc{sample} \hlstd{=} \hlkwd{min}\hlstd{(}\hlkwd{rowSums}\hlstd{(H.year)),} \hlkwc{border} \hlstd{=} \hlnum{NA}\hlstd{,}
    \hlkwc{fill} \hlstd{=} \hlnum{NA}\hlstd{,} \hlkwc{font} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{1}\hlstd{,} \hlkwc{col} \hlstd{=} \hlstr{"blue"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of a rarefaction curve produced using a MLG table.}
  \label{rarecurve}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/mlgrareplot} 

}



\end{knitrout}

\end{figure}
\newpage

The minimum value from the \textit{base} function \texttt{rowSums()} of the table represents the minimum common sample size of all populations. Setting the ``sample" flag draws the horizontal and vertical lines you see on the graph. The intersections of these lines correspond to the numbers you would find if you ran the function \cmdlink{summary:poppr}{poppr}on this data set (under the column ``\texttt{eMLG}").
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Getting into the mix \{combining MLG functions\}}
\label{mlg:mix}

\tab\tab Alone, the different functionalities are neat. Combined, we can create interesting data sets. Let's say we wanted to know which MLGs were duplicated across the regions of the United Kingdom, Germany, Netherlands, and Norway. All we have to do is use the \texttt{sublist} flag in the function:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{setpop}\hlstd{(virus)} \hlkwb{<-} \hlopt{~}\hlstd{country}
\hlstd{UGNN.list} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlstr{"United Kingdom"}\hlstd{,} \hlstr{"Germany"}\hlstd{,} \hlstr{"Netherlands"}\hlstd{,} \hlstr{"Norway"}\hlstd{)}
\hlstd{UGNN} \hlkwb{<-} \hlkwd{mlg.crosspop}\hlstd{(virus,} \hlkwc{sublist} \hlstd{= UGNN.list,} \hlkwc{indexreturn} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

OK, the output tells us that there are three MLGs that are crossing between these
populations, but we do not know how many are in each. We can easily find that out if we subset our original table, \texttt{v.tab}. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{UGNN}  \hlcom{# Note that we have three numbers here. This will index the columns for us.}
\end{alltt}
\begin{verbatim}
## MLG.315 MLG.317 MLG.620 
##     315     317     620
\end{verbatim}
\begin{alltt}
\hlstd{UGNN.list}  \hlcom{# And let's not forget that we have the population names.}
\end{alltt}
\begin{verbatim}
## [1] "United Kingdom" "Germany"        "Netherlands"    "Norway"
\end{verbatim}
\begin{alltt}
\hlstd{v.tab[UGNN.list, UGNN]}
\end{alltt}
\begin{verbatim}
##                MLG.315 MLG.317 MLG.620
## United Kingdom       1       0       0
## Germany              0       1       1
## Netherlands          0       0       0
## Norway               2       3       1
\end{verbatim}
\end{kframe}
\end{knitrout}


Now we can see that Norway has a higher incidence of nearly all of these MLGs. 
We can investigate the incidence of these MLGs throughout our data set. 


\begin{quote}
To Be Continued
\end{quote}

We can go even further and subset the original data set to only give us those MLGs by utilizing the function \texttt{mlg.vector}:
\subsubsection{Function: mlg.vector}
\label{mlg:mix:mlg.vector}

\tab\tab This function is the backbone for \texttt{mlg.table} and \texttt{mlg.crosspop}, and is The function that determines what your MLGs are. This is quite useful for sub-setting the data set to only contain the MLGs of interest. The numbers in the vector correspond to the number of columns in a matrix produced by \texttt{mlg.table}. It is important to remember that this is also sensitive to missing data and will treat it as a single extra allele. 
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
mlg.vector(pop)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{mlg.vector(pop)}
\end{quote}
  \begin{itemize}
    \item \texttt{pop -} a \texttt{genind} object.
  \end{itemize}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{v.vec} \hlkwb{<-} \hlkwd{mlg.vector}\hlstd{(virus)}
\hlstd{v.sub} \hlkwb{<-} \hlstd{virus[v.vec} \hlopt{%in%} \hlstd{UGNN, ]}
\hlkwd{mlg.table}\hlstd{(v.sub,} \hlkwc{bar} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\begin{verbatim}
##                MLG.315 MLG.317 MLG.620
## Austria              0       0       7
## Germany              0       1       1
## Greece               0       0       1
## Norway               2       3       1
## Japan                4       1       0
## United Kingdom       1       0       0
\end{verbatim}
\end{kframe}
\end{knitrout}

You can also do the same thing using the mlgsub flag.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{mlg.table}\hlstd{(virus,} \hlkwc{mlgsub} \hlstd{= UGNN,} \hlkwc{bar} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##                MLG.315 MLG.317 MLG.620
## Japan                4       1       0
## Norway               2       3       1
## United Kingdom       1       0       0
## Austria              0       0       7
## Germany              0       1       1
## Greece               0       0       1
\end{verbatim}
\end{kframe}
\end{knitrout}

And we can see where exactly these three MLGs fall within our data set.
\begin{figure}[h!]
  \centering
  \caption{\footnotesize An example of the same bar-chart as \textit{Figure 1}, but focusing on three MLGs.}
  \label{nortable2}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/subnor} 

}



\end{knitrout}

\end{figure}
\\
\newpage
Now, you might notice that the MLG vector no longer matches up with our data after we subset it.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{v.vec[}\hlnum{1}\hlopt{:}\hlnum{22}\hlstd{]}
\end{alltt}
\begin{verbatim}
##  [1] 605 605 672 675 674 673 670 671 670 678 678 678 678 582 615 580 581 570 615 582 582
## [22] 592
\end{verbatim}
\begin{alltt}
\hlkwd{mlg.vector}\hlstd{(v.sub)}
\end{alltt}
\begin{verbatim}
##  [1] 3 3 3 3 3 3 3 3 3 3 2 1 1 2 2 1 2 1 1 1 1 2
\end{verbatim}
\end{kframe}
\end{knitrout}

% Well, this is unfortunate because it means that we can't compare any subsetted data with non-subsetted data. Luckily, there's a little trick we can do using our old friend, the \texttt{@other} slot.
% If we place the MLG vector in the \texttt{@other} slot of our original data set, it will be subsetted along with the data.
% <<>>=
% virus@other$MLG.vector <- H.vec
% H.sub <- virus[H.vec %in% UGNN, ]
% H.sub@other$MLG.vector
% @
% Magic!\\
%\newpage

So, we've gotten this far, yet we haven't actually seen what the genotypes look like! For analyses where the genotypic signature is important, this is a crucial identification step. Lucky for us, the \texttt{genind} object retains all of the genotypic information and can be accessed using the \texttt{genind2df} function. Let's take a look at the three genotypes we specified above utilizing the vector of MLGs we created above, \texttt{H.vec}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{v.df} \hlkwb{<-} \hlkwd{genind2df}\hlstd{(virus)}
\hlstd{v.df[v.vec} \hlopt{%in%} \hlstd{UGNN,} \hlnum{1}\hlopt{:}\hlnum{15}\hlstd{]}  \hlcom{# Showing only 15 columns becaus it is a large dataset.}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##                     pop 6 17 39 42 45 51 60 72 73 90 108 123 129 134
## CY026119        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026120        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026121        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026122        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026131        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026132        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## CY026135        Austria a  a  g  c  g  c  g  g  c  g   a   g   t   g
## EU502462        Germany a  a  g  c  g  c  g  g  c  g   a   g   t   g
## EU502463         Greece a  a  g  c  g  c  g  g  c  g   a   g   t   g
## EU502464         Norway a  a  g  c  g  c  g  g  c  g   a   g   t   g
## EU501513          Japan a  a  g  c  t  c  a  g  a  g   t   g   t   g
## AB243868          Japan a  a  g  c  t  c  a  g  a  g   t   g   t   g
## DQ883618         Norway a  a  g  c  t  c  a  g  a  g   t   g   t   g
## DQ883619         Norway a  a  g  c  t  c  a  g  a  g   t   g   t   g
## DQ883620         Norway a  a  g  c  t  c  a  g  a  g   t   g   t   g
## DQ883628         Norway a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU501609        Germany a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU501642          Japan a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU501643          Japan a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU501735 United Kingdom a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU501742          Japan a  a  g  c  t  c  a  g  a  g   t   g   t   g
## EU502513         Norway a  a  g  c  t  c  a  g  a  g   t   g   t   g
\end{verbatim}
\end{kframe}
\end{knitrout}

Notice that there seems to be a clear separation between the SNPs of the first 10 isolates and the rest? This is no coincidence. Take a look at the output of our sub-setting.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{UGNN}
\end{alltt}
\begin{verbatim}
## MLG.315 MLG.317 MLG.620 
##     315     317     620
\end{verbatim}
\begin{alltt}
\hlstd{v.vec[v.vec} \hlopt{%in%} \hlstd{UGNN]}
\end{alltt}
\begin{verbatim}
##  [1] 620 620 620 620 620 620 620 620 620 620 317 315 315 317 317 315 317 315 315 315 315
## [22] 317
\end{verbatim}
\end{kframe}
\end{knitrout}


We have the MLGs 315, 317, and 620, and the result of the sub-setting shows us that 620 occurs earlier in our data set, and that MLGs 315 and 317 are mixed in together. The reason why we do not see a mixture of three different sets of SNP calls in our little window is because \texttt{mlg.vector} creates the MLGs by first concatenating and then sorting the genotypes. This way, the closer two MLG indexes are to each other, the fewer differences they will have between one another. 

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Do you see what I see? \{alternative data visualization\}}
\label{mlg:alt.vis}

\tab\tab The graphs that are output by \poppr{} are simply aids for the user to make data analysis easier. We want to better visualize how these MLGs cross populations by MLG or population. We also want to see exactly what MLGs are in which populations, and how prevalent they are. As the package \textit{ggplot2} is based on data frames, we have to give ourselves a data frame to work with. We can do this using the \texttt{df = TRUE} flag.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df} \hlkwb{<-} \hlkwd{mlg.crosspop}\hlstd{(virus,} \hlkwc{df} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\hlkwd{names}\hlstd{(df)}
\end{alltt}
\begin{verbatim}
## [1] "MLG"        "Population" "Count"
\end{verbatim}
\end{kframe}
\end{knitrout}

Now that we have our data frame, we can do a couple of things. We can first see where the most omnipresent MLG occurs. After that, we will plot the top ten MLGs using ggplot2.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{v.max} \hlkwb{<-} \hlkwd{names}\hlstd{(}\hlkwd{sort}\hlstd{(v.num,} \hlkwc{decreasing} \hlstd{=} \hlnum{TRUE}\hlstd{)[}\hlnum{1}\hlopt{:}\hlnum{10}\hlstd{])}
\hlcom{# Showing the data frame by the largest MLG complex.}
\hlstd{df[df}\hlopt{$}\hlstd{MLG} \hlopt{%in%} \hlstd{v.max[}\hlnum{1}\hlstd{], ]}
\end{alltt}
\begin{verbatim}
##        MLG  Population Count
## 76 MLG.246       Japan     3
## 77 MLG.246         USA     8
## 78 MLG.246       China     4
## 79 MLG.246      Norway     1
## 80 MLG.246     Austria     6
## 81 MLG.246      Russia     1
## 82 MLG.246       Egypt     1
## 83 MLG.246     Iceland     1
## 84 MLG.246       Nepal    15
## 85 MLG.246 Switzerland     1
\end{verbatim}
\end{kframe}
\end{knitrout}

And now we can visualize the largest ten MLG complexes using \textit{ggplot2}'s \texttt{qplot} function.
\begin{figure}[h]
  \centering
  \caption{\footnotesize An example of the versatility of the MLG information.}
  \label{mlgtable2}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{df2} \hlkwb{<-} \hlstd{df[df}\hlopt{$}\hlstd{MLG} \hlopt{%in%} \hlstd{v.max, ]}
\hlkwd{library}\hlstd{(ggplot2)}
\hlkwd{qplot}\hlstd{(}\hlkwc{y} \hlstd{= MLG,} \hlkwc{x} \hlstd{= Population,} \hlkwc{data} \hlstd{= df2,} \hlkwc{color} \hlstd{= Count,} \hlkwc{size} \hlstd{= Count)} \hlopt{+} \hlkwd{theme}\hlstd{(}\hlkwc{axis.text.x} \hlstd{=} \hlkwd{element_text}\hlstd{(}\hlkwc{size} \hlstd{=} \hlnum{10}\hlstd{,}
    \hlkwc{angle} \hlstd{=} \hlopt{-}\hlnum{45}\hlstd{,} \hlkwc{hjust} \hlstd{=} \hlnum{0}\hlstd{))}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=0.5\linewidth]{figure/ggplotchart} 

}



\end{knitrout}

\end{figure}
%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Index and Distance Calculations}
\label{index}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{The missing linkage disequilibrium \{calculating the index of association, $I_A$ and $\bar r_d$\}}
\label{index:iard}

\tab\tab The index of association was originally developed as a measure of multilocus linkage disequilibrium \cite{Brown:1980} and was found to be able to detect signatures of sexual reproduction and population structure \cite{Brown:1980, Smith:1993}. Unfotunately, $I_A$ was found to increase with the number of loci, and was not suitable to comparisons across studies \cite{Agapow:2001}. To remedy this, $\bar{r}_d$ was developed that corrects for this scaling and forces the index to lie between 0 (linkage equilibrium) and 1 (full disequilibrium). $I_A$ has previously been implemented in a couple of programs including \textit{multilocus} \cite{Agapow:2001} and \textit{LIAN} \cite{Haubold:2000}. While both of these programs are still available for download, \textit{multilocus} is no longer actively supported, and \textit{LIAN}, despite its speed, is only appropriate for haplotypic data. Both of these programs each require one specific file format, and, until recently\footnote{LIAN 3.6 allows the user to run multiple contiguous data sets within a single file or across multiple files. It is impossible to run MULTILOCUS in batch.}, neither of these programs had an internal ability to run in batch across multiple populations within a file or multiple files within a directory in the same way that poppr can (see footnote).

It is important to note that for this algorithm, all missing values are treated in the same way as \textit{multilocus} in that all missing alleles are imputed to be the same as the alleles they are being compared to. Depending on the percent missing data in your data set, this might influence the statistic. If you have a lot of missing data, consider using the \texttt{missing} flag in this function.
\subsubsection{Function: ia}
\label{index:iard:ia}

\tab\tab This function is a quick look at a single data set. It can do almost everything that \texttt{poppr} can do except for sorting through populations.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
ia(pop, sample = 0, method = 1, quiet = FALSE, missing = "ignore", 
    hist = TRUE, valuereturn = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{ia(pop, sample = 0, method = 1, quiet = FALSE, missing = "ignore", 
%     hist = TRUE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{sample -} You should use this flag whenever you want to reshuffle your data set. Indicate how many times you want to reshuffle your data set to obtain a P-value. 
  \item \texttt{method -} a number from 1 to 4 indicating the sampling method:
  \begin{enumerate}
    \item permutation over alleles.
    \item parametric bootstrap.
    \item non-parametric bootstrap.
    \item \textit{multilocus} style permutation \cite{Agapow:2001}.
  \end{enumerate}
  The methods are detailed in\cmdlink{data.manip:shuffle:shufflepop}{shufflepop.}
  \item \texttt{quiet -} If set to \texttt{TRUE}, nothing will be printed to the screen as the sampling progresses. If \texttt{FALSE} will produce a progress bar.
  \item \texttt{missing -} This will preprocess your missing values. It is set to ignore missing data, so that they do not contribute to the distance measure. It can also be set to \texttt{"loci", "geno", "zero", or "mean"}. For details, see\seclink{data.manip:missing:missingno}{missingno.}
  \item \texttt{hist -} This will produce a pair of histograms for each population showing the distribution of $I_A$ and $\bar r_d$ across the sampled data sets, and plot the observed value as a single vertical line.
  \item \texttt{valuereturn -} If set to \texttt{TRUE} and the number of samples
  is greater than zero, it will return all values generated from the permuted
  data. 
\end{itemize}
Running the analysis is as simple as this:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{ia}\hlstd{(nancycats)}
\end{alltt}
\begin{verbatim}
##      Ia   rbarD 
## 0.17207 0.02179
\end{verbatim}
\end{kframe}
\end{knitrout}

We can use \texttt{popsub} to subset for specific populations. Here, we'll also demonstrate the sampling flag and show you what the histogram looks like.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{1009}\hlstd{)}
\hlkwd{ia}\hlstd{(}\hlkwd{popsub}\hlstd{(nancycats,} \hlnum{5}\hlstd{),} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## |================================================================================| 100%
##        Ia      p.Ia     rbarD      p.rD 
## -0.047540  0.572000 -0.006004  0.572000
\end{verbatim}
\end{kframe}
\end{knitrout}


This analysis produced the histograms you see below. What these histograms represent are 999 resamplings of the data under the null hypothesis ($H_0$) of sexual reproduction. The way that $H_0$ is created is determined by the sampling method chosen. In this case, the method was to shuffle genotypes at each locus to simulate unlinked loci. Since the P = 0.572, we would fail to reject $H_0$ and we therefore might conclude that this population is sexually reproducing \cite{Brown:1980} \cite{Smith:1993} \cite{Agapow:2001}.
\begin{figure}[h!]
  \centering
  \caption{\footnotesize Histograms of 999 values of $I_A$ and $\bar{r}_d$ calculated from 999 resamplings of population 5 from the data set ``nancycats". The observed values of $I_A$ and $\bar r_d$ are represented as vertical blue lines overlaid on the distributions. The ticks at the bottom of each histogram represent individual observations.}
  \label{ia_demo_fig}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/unnamed-chunk-6} 

}



\end{knitrout}

\end{figure}
%\newpage

If we wanted to, we could also have set the flag \texttt{valuereturn = TRUE} to 
get back our permuted data if we wanted to make our own histograms (we'll set 
the number of samples to 9 for demonstrative purposes):

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{1009}\hlstd{)}
\hlkwd{ia}\hlstd{(}\hlkwd{popsub}\hlstd{(nancycats,} \hlnum{5}\hlstd{),} \hlkwc{sample} \hlstd{=} \hlnum{9}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{valuereturn} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## |================================================================================| 100%
## $index
##        Ia      p.Ia     rbarD      p.rD 
## -0.047540  0.500000 -0.006004  0.500000 
## 
## $samples
##         Ia     rbarD
## 1 -0.17418 -0.022057
## 2  0.11100  0.014208
## 3 -0.05166 -0.006611
## 4 -0.22706 -0.028948
## 5 -0.29079 -0.036685
## 6  0.17143  0.021764
## 7  0.12743  0.016054
## 8 -0.04898 -0.006224
## 9 -0.01005 -0.001270
\end{verbatim}
\end{kframe}
\end{knitrout}



There, are, of course a couple of caveats that need to be mentioned regarding our P-values. First, while we have equivalent P-values for $I_A$ and $\bar{r}_d$, they might not always be equal due to the difference in calculation. Details about that can be found in the Appendix section\seclink{appendix:algorithm:iard}{$I_A$ and $\bar{r}_d$.}Second, the P-values are calculated by comparing how many permuted values are greater than or equal to the observed value. This includes the observed value (which is why setting the randomizations to 999 will give you a round P-value) which means that the lowest P-value you will ever have is $1/(n+1)$ where $n$ is the number of permutations you select. Take for example this population of a clonal root rot pathogen, \textit{Aphanomyces euteiches}:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Aeut)}
\hlkwd{set.seed}\hlstd{(}\hlnum{1001}\hlstd{)}
\hlkwd{ia}\hlstd{(}\hlkwd{popsub}\hlstd{(Aeut,} \hlnum{1}\hlstd{),} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{method} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##      Ia    p.Ia   rbarD    p.rD 
## 2.90603 0.00100 0.07237 0.00100
\end{verbatim}
\end{kframe}
\end{knitrout}

If you want to be able to report $P < 0.001$ in this situation, then you can simply increase the number in sample: \texttt{sample = 1999}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Going the distance \{dissimilarity distance\}}
\label{index:dist}
\tab\tab Since \poppr{} is still in its infancy, the number of distance measures it can offer are few. Bruvo's distance is well supported and allows you to quickly visualize your data, but it only allows for microsatellites. The index of association, above, utilizes a discreet dissimilarity distance matrix. It is with this matrix that we have constructed a relative dissimilarity distance where the distance is the ratio of the number of dissimilarities to the number of dissimilarities possible. The number of dissimilarities possible is the number of loci multiplied by the ploidy, so if you have 10 loci from a diploid population, then there are 20 dissimilarities possible. For details, see equations (\ref{eq:ia_d}) and (\ref{eq:ia_D}) in\seclink{appendix:algorithm:iard}{$I_A$ and $\bar{r}_d$.} 

\subsubsection{Function: diss.dist}
\label{index:dist:diss.dist}

\tab\tab Use this function to calculate relative dissimilarity between individuals and return a distance matrix for use in creating cladograms or minimum spanning networks. A note: missing alleles will be imputed to be the same as the challenging allele, decreasing the distance between some individuals. If you want to consider all missing data as special alleles, treat your data with \texttt{missingno(pop, type = "zero")} beforehand. 

\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
diss.dist(x, diff = TRUE, frac = TRUE, mat = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{diss.dist(pop)}
\end{quote}

\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object. 
\end{itemize}
Since we have a data set that we know is very clonal, let's analyze the \textit{A. euteiches} data set \cite{Grunwald:2006} and create a heatmap to visualize the degree of difference between populations.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Aeut)}
\hlstd{A.dist} \hlkwb{<-} \hlkwd{diss.dist}\hlstd{(Aeut)}
\hlkwd{heatmap}\hlstd{(}\hlkwd{as.matrix}\hlstd{(A.dist),} \hlkwc{symm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize Heatmap representation of a dissimilarity distance for the data set ``Aeut"}
  \label{diss_heat_map}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/unnamed-chunk-7} 

}



\end{knitrout}

\end{figure}
\newpage
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Step by stepwise mutation \{Bruvo's distance\}}
\label{index:bruvo}

\tab\tab Bruvo's distance is a genetic distance measure for microsatellite markers utilizing a stepwise mutation model that allows for differing ploidy levels \cite{Bruvo:2004}. As \textit{adegenet's} \texttt{genind} object has an all or none approach to missing data, any genotypes not exhibiting full ploidy will be treated as missing. This means that only non-special cases will be considered for the calculation and missing data will be ignored \cite{Bruvo:2004}.

This is true only if missing data is treated as missing when importing to \adegenet{}. If missing data in the initial data frame has missing microsatellite alleles coded as 0, then the genind object will not treat them as missing (unless the genotype has no alleles in it). An example adapted from the \adegenet{} "Getting Started" vignette shows how this can be done:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{5001}\hlstd{)}
\hlstd{temp} \hlkwb{<-} \hlkwd{lapply}\hlstd{(}\hlnum{1}\hlopt{:}\hlnum{30}\hlstd{,} \hlkwa{function}\hlstd{(}\hlkwc{i}\hlstd{)} \hlkwd{sample}\hlstd{(}\hlnum{0}\hlopt{:}\hlnum{9}\hlstd{,} \hlnum{4}\hlstd{,} \hlkwc{replace} \hlstd{=} \hlnum{TRUE}\hlstd{))}
\hlstd{temp} \hlkwb{<-} \hlkwd{sapply}\hlstd{(temp, paste,} \hlkwc{collapse} \hlstd{=} \hlstr{"/"}\hlstd{)}
\hlstd{temp} \hlkwb{<-} \hlkwd{matrix}\hlstd{(temp,} \hlkwc{nrow} \hlstd{=} \hlnum{10}\hlstd{,} \hlkwc{dimnames} \hlstd{=} \hlkwd{list}\hlstd{(}\hlkwd{paste}\hlstd{(}\hlstr{"ind"}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{),} \hlkwd{paste}\hlstd{(}\hlstr{"loc"}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{)))}
\hlstd{temp}
\end{alltt}
\begin{verbatim}
##        loc 1     loc 2     loc 3    
## ind 1  "9/7/7/1" "5/6/8/7" "1/3/9/6"
## ind 2  "5/6/7/0" "1/8/1/8" "2/7/6/1"
## ind 3  "0/7/7/9" "2/4/4/0" "8/8/9/2"
## ind 4  "4/8/6/4" "8/1/0/2" "6/2/5/4"
## ind 5  "2/0/3/1" "6/9/1/8" "1/0/0/1"
## ind 6  "5/3/0/5" "5/5/0/0" "8/2/6/2"
## ind 7  "0/7/4/7" "8/5/8/5" "1/3/8/0"
## ind 8  "7/0/7/5" "2/1/5/4" "9/5/2/8"
## ind 9  "4/8/0/1" "8/8/8/4" "9/0/3/4"
## ind 10 "4/4/3/3" "2/0/5/6" "8/7/1/5"
\end{verbatim}
\begin{alltt}
\hlstd{obj} \hlkwb{<-} \hlkwd{df2genind}\hlstd{(temp,} \hlkwc{ploidy} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{sep} \hlstd{=} \hlstr{"/"}\hlstd{)}
\hlkwd{pop}\hlstd{(obj)} \hlkwb{<-} \hlkwd{paste}\hlstd{(}\hlstr{"ind"}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{10}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


We will save this object for a later demonstration of the addition and loss models of Bruvo's distance. It is important to note that this is a distance between individuals, not populations, unlike Nei's 1978 distance \cite{Nei:1978}. For distances between populations, see the \adegenet{} function \texttt{dist.genpop}

\subsubsection{Function: bruvo.dist}
\label{index:bruvo:bruvo.dist}

\tab\tab Bruvo's distance requires knowledge of the repeat lengths of each locus, so take care to read the description below.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
bruvo.dist(pop, replen = 1, add = TRUE, loss = TRUE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{bruvo.dist(pop, replen = 1, add = TRUE, loss = TRUE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{replen -} This is a vector of numbers indicating the repeat length for each locus in your sample. If you have two dinucleotide repeats and five tetranucleotide repeats, you would put \texttt{c(2,2,4,4,4,4,4)} in this field. If you have imported data where that represents the raw number of steps, all you would have to type is \texttt{rep(1, n)}, replacing $n$ with the number of loci in your sample. It is important that you place something in this field because this function will attempt to estimate the repeat length based on the minimum difference of the alleles represented; with variability of position calls, relying on this estimation is NOT recommended. 
  \item \texttt{add -} For missing data: use the genome addition model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
  \item \texttt{loss -} For missing data: use the genome loss model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
\end{itemize}

To illustrate why it is important to specify the repeat lengths, let's imagine a locus that contains 5 alleles and the true repeat length is 4. Note that Bruvo's distance between alleles is calculated as $1 - 2^{-[x]}$, where $x$ is the difference in repeat lengths:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{locus1} \hlkwb{<-} \hlkwd{c}\hlstd{(}\hlnum{244}\hlstd{,} \hlnum{248}\hlstd{,} \hlnum{256}\hlstd{,} \hlnum{240}\hlstd{,} \hlnum{236}\hlstd{)}
\hlstd{locus1}\hlopt{/}\hlnum{4}
\end{alltt}
\begin{verbatim}
## [1] 61 62 64 60 59
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{2}\hlopt{^-}\hlkwd{dist}\hlstd{(locus1}\hlopt{/}\hlnum{4}\hlstd{)}
\end{alltt}
\begin{verbatim}
##        1      2      3      4
## 2 0.5000                     
## 3 0.8750 0.7500              
## 4 0.5000 0.7500 0.9375       
## 5 0.7500 0.8750 0.9688 0.5000
\end{verbatim}
\end{kframe}
\end{knitrout}

We can see that the distance between them ranges from 1 to 5. Let's say, that we accidentally wrote 2 or 8 instead of 4:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{locus1}\hlopt{/}\hlnum{2}
\end{alltt}
\begin{verbatim}
## [1] 122 124 128 120 118
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{2}\hlopt{^-}\hlkwd{dist}\hlstd{(locus1}\hlopt{/}\hlnum{2}\hlstd{)}  \hlcom{# Distance increase}
\end{alltt}
\begin{verbatim}
##        1      2      3      4
## 2 0.7500                     
## 3 0.9844 0.9375              
## 4 0.7500 0.9375 0.9961       
## 5 0.9375 0.9844 0.9990 0.7500
\end{verbatim}
\begin{alltt}
\hlstd{locus1}\hlopt{/}\hlnum{8}
\end{alltt}
\begin{verbatim}
## [1] 30.5 31.0 32.0 30.0 29.5
\end{verbatim}
\begin{alltt}
\hlnum{1} \hlopt{-} \hlnum{2}\hlopt{^-}\hlkwd{dist}\hlstd{(locus1}\hlopt{/}\hlnum{8}\hlstd{)}  \hlcom{# Distance decrease}
\end{alltt}
\begin{verbatim}
##        1      2      3      4
## 2 0.2929                     
## 3 0.6464 0.5000              
## 4 0.2929 0.5000 0.7500       
## 5 0.5000 0.6464 0.8232 0.2929
\end{verbatim}
\end{kframe}
\end{knitrout}

While we will still get results from this analysis with the incorrect repeat length, they will be inherently wrong as they do not represent the true distance. That being said, it's important to note that the repeat lengths we represent for the rest of the manual are not known by the authors, but are used as a simple example. 

This function will return a distance matrix (displaying the smallest population in the data set ``nancycats"):
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dist9} \hlkwb{<-} \hlkwd{bruvo.dist}\hlstd{(}\hlkwd{popsub}\hlstd{(nancycats,} \hlnum{9}\hlstd{),} \hlkwc{replen} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{9}\hlstd{))}
\hlstd{dist9}
\end{alltt}
\begin{verbatim}
##        N104   N105   N106   N107   N108   N109   N111   N112
## N105 0.5779                                                 
## N106 0.4008 0.4563                                          
## N107 0.2203 0.5093 0.1806                                   
## N108 0.3270 0.5534 0.2352 0.2179                            
## N109 0.4016 0.2760 0.3192 0.3331 0.4295                     
## N111 0.6150 0.8708 0.5533 0.6167 0.5219 0.7331              
## N112 0.5492 0.4086 0.4392 0.3289 0.3886 0.4529 0.8037       
## N113 0.5926 0.6228 0.6203 0.6586 0.6186 0.6100 0.5060 0.7026
\end{verbatim}
\end{kframe}
\end{knitrout}


You can visualize this better with a simple heatmap:
%\newpage

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{heatmap}\hlstd{(}\hlkwd{as.matrix}\hlstd{(dist9),} \hlkwc{symm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize Heatmap representation of Bruvo's distance for population 9 of the data set ``nancycats"}
  \label{bruvo_heat_map}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/unnamed-chunk-8} 

}



\end{knitrout}

\end{figure}
%\newpage

Let's take a closer look at the two individuals, N113 and N111. They seem to have large distances between everyone else and themselves. The names and columns of the matrix contain the names of individuals, but not the population information. We can make a comparison of Bruvo's distance across populations easier by editing the ``Labels" attribute of the distance object. Let's take a look at the labels attribute using the \texttt{attr()} command. 
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{attr}\hlstd{(dist9,} \hlstr{"Labels"}\hlstd{)}
\end{alltt}
\begin{verbatim}
##      1      2      3      4      5      6      7      8      9 
## "N104" "N105" "N106" "N107" "N108" "N109" "N111" "N112" "N113"
\end{verbatim}
\end{kframe}
\end{knitrout}

Remember that they all came from population 9, so let's append that to each label using the \texttt{paste()} command. 
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dist9.attr} \hlkwb{<-} \hlkwd{attr}\hlstd{(dist9,} \hlstr{"Labels"}\hlstd{)}
\hlkwd{attr}\hlstd{(dist9,} \hlstr{"Labels"}\hlstd{)} \hlkwb{<-} \hlkwd{paste}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlstr{"P09"}\hlstd{,} \hlnum{9}\hlstd{), dist9.attr)}
\hlstd{dist9}
\end{alltt}
\begin{verbatim}
##          P09 N104 P09 N105 P09 N106 P09 N107 P09 N108 P09 N109 P09 N111 P09 N112
## P09 N105   0.5779                                                               
## P09 N106   0.4008   0.4563                                                      
## P09 N107   0.2203   0.5093   0.1806                                             
## P09 N108   0.3270   0.5534   0.2352   0.2179                                    
## P09 N109   0.4016   0.2760   0.3192   0.3331   0.4295                           
## P09 N111   0.6150   0.8708   0.5533   0.6167   0.5219   0.7331                  
## P09 N112   0.5492   0.4086   0.4392   0.3289   0.3886   0.4529   0.8037         
## P09 N113   0.5926   0.6228   0.6203   0.6586   0.6186   0.6100   0.5060   0.7026
\end{verbatim}
\end{kframe}
\end{knitrout}

Now we can see that all of the labels are corresponding to population 9. Let's calculate Bruvo's distance between populations 8 and 9.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{dist9to8} \hlkwb{<-} \hlkwd{bruvo.dist}\hlstd{(}\hlkwd{popsub}\hlstd{(nancycats,} \hlnum{8}\hlopt{:}\hlnum{9}\hlstd{),} \hlkwc{replen} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{9}\hlstd{))}
\hlstd{dist9to8.attr} \hlkwb{<-} \hlkwd{attr}\hlstd{(dist9to8,} \hlstr{"Labels"}\hlstd{)}
\hlstd{nan9to8pop} \hlkwb{<-} \hlstd{nancycats}\hlopt{@}\hlkwc{pop}\hlstd{[nancycats}\hlopt{@}\hlkwc{pop} \hlopt{%in%} \hlkwd{c}\hlstd{(}\hlstr{"P08"}\hlstd{,} \hlstr{"P09"}\hlstd{)]}
\hlkwd{attr}\hlstd{(dist9to8,} \hlstr{"Labels"}\hlstd{)} \hlkwb{<-} \hlkwd{paste}\hlstd{(nan9to8pop, dist9to8.attr)}
\hlkwd{heatmap}\hlstd{(}\hlkwd{as.matrix}\hlstd{(dist9to8),} \hlkwc{symm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize Heatmap representation of Bruvo's distance for populations 8 and 9 of the data set ``nancycats"}
  \label{bruvo_heat_map_8to9}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/popcompare_bruvo2} 

}



\end{knitrout}

\end{figure}

Remember N113 and N111? Take a look at where they fall on the heatmap. They don't cluster together with population 9 anymore, but somewhere in population 8.
% \newpage

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{See the forest for the trees \{visualizing distances with dendrograms and networks\}}
\label{index:trees}

\tab\tab Staring at a raw distance matrix might be able to tell you something about your data, but it also might be able to ruin your eyesight. In this section, we present functions to display this data in trees and networks. 

\subsubsection{Function: bruvo.boot}
\label{index:trees:bruvo.boot}

\tab\tab This function provides the ability to draw a dendrogram based on Bruvo's distance including bootstrap support. 
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
bruvo.boot(pop, replen = 1, add = TRUE, loss = TRUE, sample = 100, 
    tree = "upgma", showtree = TRUE, cutoff = NULL, quiet = FALSE, 
    ...)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{bruvo.boot(pop, replen = 1, add = TRUE, loss = TRUE, sample = 100, tree = "upgma", showtree = TRUE, cutoff = NULL, quiet = FALSE)}
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{replen -} see \texttt{bruvo.dist}, above.
  \item \texttt{add -} For missing data: use the genome addition model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
  \item \texttt{loss -} For missing data: use the genome loss model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
  \item \texttt{sample -} How many bootstraps do you want to perform? 
  \item \texttt{tree -} Two trees are available, Neighbor-Joining \texttt{"nj"} or UPGMA \texttt{"upgma"}.
  \item \texttt{showtree -} if \texttt{TRUE}, a tree will be plotted automatically.
  \item \texttt{cutoff -} This is a number between 0 and 100 indicating the cutoff value for the bootstrap nodelables. If you only wanted to see the the boostrap values for nodes that were present more than 75\% of the time, you would use \texttt{cutoff = 75}. If you don't put anything for this parameter, all values will be shown.
  \item \texttt{quiet -} if \texttt{quiet = TRUE}, no standard messages will be printed to screen. If \texttt{quiet = FALSE} (default), then a progress bar and standard message will be printed to the screen.
\end{itemize}

For this example, let's set the cutoff to 50\%.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{410}\hlstd{)}
\hlstd{nan9tree} \hlkwb{<-} \hlkwd{bruvo.boot}\hlstd{(}\hlkwd{popsub}\hlstd{(nancycats,} \hlnum{8}\hlopt{:}\hlnum{9}\hlstd{),} \hlkwc{replen} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{9}\hlstd{),} \hlkwc{sample} \hlstd{=} \hlnum{1000}\hlstd{,} \hlkwc{cutoff} \hlstd{=} \hlnum{50}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## 
## Bootstrapping...
## (note: calculation of node labels can take a while even after the progress bar is full)
## |================================================================================| 100%
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize UPGMA Tree of Bruvo's distance for population 9 of the data set ``nancycats" with 1000 Bootstrap Replicates. Node labels represent percentage of bootstrap replicates that contained that node.}
  \label{bruvo_upgma}
%  \includegraphics{bruvo_upgma.png}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.5\linewidth]{figure/bruvo_tree} 

}



\end{knitrout}


\end{figure}
\newpage
\subsubsection{Function: greycurve}
\label{index:trees:greycurve}
\tab\tab Use this function to display a gradient of grey values based on user-defined parameters. The following functions will display a minimum spanning network that utilize a grey scale to display the weight of the lines (referred to as ``edges") that connect two or more individuals. The darker the line the closer the distance. Since this is based off of a linear grey scale, what happens when you have a distance matrix comprised of values all below 0.2 or all above 0.8? 

With linear grey scaling, it becomes very difficult to detect the differences in these ranges. The following function allows you to visualize and manipulate a gradient from black to white so that you can use it in \poppr{}'s msn functions below to maximize the visual differences in your data.

\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
greycurve(data = seq(0, 1, length = 1000), glim = c(0, 0.8), 
    gadj = 3, gweight = 1, scalebar = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{greycurve(glim = c(0, 0.8), gadj = 3, gweight = 1)}
\end{quote}


This function does not return any values. It will print a visual gradient from black to white horizontally. On this gradient, it will plot the adjustment curve (in opposing grey values), yellow horizontal lines bounding the maximum and minimum values, and the equation used to calculate the correction in red. By default it will use a sequence from 1 to 0 to plot the curve, but you can use
any sequence. Let's take 1000 random normal draws:

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{9999}\hlstd{)}
\hlstd{xnorm} \hlkwb{<-} \hlkwd{rnorm}\hlstd{(}\hlnum{1000}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}



%\newpage
First, we'll see what happens when we change the weight parameter.
\begin{figure}[h!]
\begin{minipage}[b]{0.45\linewidth}
\centering
\caption{\footnotesize Default for \texttt{greycurve()}, weighted for small values.}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{greycurve}\hlstd{(xnorm)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\linewidth]{figure/greycurve_normal} 

}



\end{knitrout}

\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\caption{\footnotesize weighting for large values.}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{greycurve}\hlstd{(xnorm,} \hlkwc{gweight} \hlstd{=} \hlnum{2}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\linewidth]{figure/greywidth_inverse} 

}



\end{knitrout}

\end{minipage}
\end{figure}

If you change the adjustment parameter, \texttt{gadj}, the shape of the curve
will change, and if you change the limit parameter, \texttt{glim}, the bounds of
the curve will change.

This function also will plot scalebars for use with minimum spanning networks produced in previous versions of poppr. Just use the scalebar argument and you
will get a scalebar using the quantiles from the data and a scalebar with the 
data smoothed from the minimum to the maximum.

\begin{figure}[h!]
\begin{minipage}[b]{0.45\linewidth}
\centering
\caption{\footnotesize We can see that more data lies around zero (as expected with a random normal distribution)}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{greycurve}\hlstd{(xnorm,} \hlkwc{scalebar} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\linewidth]{figure/greycurve_small_heavy} 

}



\end{knitrout}

\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.45\linewidth}
\centering
\caption{\footnotesize Same as the figure on the left, but weighting heavily toward larger values.}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{greycurve}\hlstd{(xnorm,} \hlkwc{gweight} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{scalebar} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}

{\centering \includegraphics[width=\linewidth]{figure/greywidth_large_heavy} 

}



\end{knitrout}

\end{minipage}
\end{figure}
\newpage

\subsubsection{Function: bruvo.msn}
\label{index:trees:bruvo.msn}
\tab\tab This function will automatically draw a minimum spanning network of MLGs based on Bruvo's distance. It's important to note that this will recalculate Bruvo's distance each time it is run, but the amount of time it takes to run is on the order of seconds. It will return a list containing the network, the populations and the related colors in the network so you can export or redraw it with the legend if you wanted to using the package \textit{igraph} (type \texttt{help("plot.igraph")} for details).
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
bruvo.msn(pop, replen = 1, add = TRUE, loss = TRUE, palette = topo.colors, 
    sublist = "All", blacklist = NULL, vertex.label = "MLG", 
    gscale = TRUE, glim = c(0, 0.8), gadj = 3, gweight = 1, wscale = TRUE, 
    showplot = TRUE, ...)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{bruvo.msn(pop, replen = 1, add = TRUE, loss = TRUE, palette = topo.colors,\\ 
%   \tab sublist = "All", blacklist = NULL, vertex.label = "MLG", gscale = TRUE, \\
%   \tab glim = c(0, 0.8), gadj = 3, gweight = 1, wscale = TRUE, ...)
% }
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{replen -} see \texttt{bruvo.dist}, above.
  \item \texttt{add -} For missing data: use the genome addition model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
  \item \texttt{loss -} For missing data: use the genome loss model (see\seclink{appendix:algorithm:bruvospecial}{Special cases of Bruvo's distance.})
  \item \texttt{palette -} this is a \textbf{function} definining a color palette to use. The default is \texttt{topo.colors}. There are different palettes, which you can search by typing \texttt{?rainbow}. If you want a custom color palette, an easy way is to use the function \texttt{colorRampPalette}.
  \item \texttt{sublist -} The populations you wish to analyze. This defaults to ``All". See section \ref{data.manip:divide:popsub} for details.
  \item \texttt{blacklist -} Populations you do not want to include in the graph. See section \ref{data.manip:divide:popsub} for details.
  \item \texttt{vertex.label -} This is an option that is passed on to \textit{igraph}'s \texttt{plot} function. \Poppr{} has added two arguments specific to \poppr{}. If you want to label the graph with the multilocus genotypes from the whole data set, use the argument \texttt{vertex.label = "mlg"}. If you want to display the representative individual names, you can use the argument \texttt{vertex.label = "inds"}. I say representative individual names because, only one representative from each MLG will be present in the clone corrected data set used to calculate the distance. For no labels, you can choose \texttt{vertex.label = NA}. 
  \item \texttt{gscale -} If this is set to \texttt{TRUE}, the edge color will be converted to greyscale based on Bruvo's distance. If two nodes are closely related, the edge will appear darker. The limits of the scale can be set by the argument \texttt{glim}. If this is set to \texttt{FALSE}, all edge colors will be black. 
  \item \texttt{glim -} This is a vector of numbers between 0 and 1. This lets you set the limits of the grey scaling based on R's internal \texttt{grey} function. For example, if you wanted a maximum of 50\% white saturation (for use if you have distantly related nodes) and a minimum of 1\%, you would use \texttt{glim = c(0.01, 0.5)}. 
  \item \texttt{gadj -} This is an integer greater than zero used to adjust the scaling factor for the grey curve. Since very small changes in the grey scale are not easily precieved, it's useful to be able to adjust the grey scale to be able to show you the weights of each edge. For example, a population with most weights less than 0.3, you might want to set \texttt{gadj = 10} to exaggerate the grey scale. 
  \item \texttt{gweight -} If \texttt{gweight = 1}, the grey scale adjustment will be weighted towards separating out smaller values of Bruvo's distance. If \texttt{gweight = 2}, the grey scale ajustment will be weighted towards separating out larger values of Bruvo's distance.
  \item \texttt{wscale -} If this is set to \texttt{TRUE}, edge widths will be displayed corresponding to Bruvo's distance in that thicker edges will represent a smaller distance between nodes. If this is set to \texttt{FALSE}, all edges will be set to a width of 2. 
  \item \texttt{... -} This is a placeholder for any other arguments that you want to supply to \textit{igraph}. Useful arguments are \texttt{vertex.label.cex} to adjust the size of the labels, \texttt{vertex.label.dist} to adjust the position of the labels, and \texttt{vertex.label.color} to adjust the color of the labels.
\end{itemize}

Often, minimum spanning networks are the preferred way to visualize Bruvo's distance. \Poppr{} offers an easy way to plot these. For a demonstration, let's analyze a simulated data set of 50 individuals from populations that reproduce at a 99.9\% rate of clonal reproduction.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(partial_clone)}
\hlkwd{set.seed}\hlstd{(}\hlnum{9005}\hlstd{)}
\hlstd{pc.msn} \hlkwb{<-} \hlkwd{bruvo.msn}\hlstd{(partial_clone,} \hlkwc{replen} \hlstd{=} \hlkwd{rep}\hlstd{(}\hlnum{1}\hlstd{,} \hlnum{10}\hlstd{),} \hlkwc{vertex.label.cex} \hlstd{=} \hlnum{0.7}\hlstd{,} \hlkwc{vertex.label.dist} \hlstd{=} \hlopt{-}\hlnum{0.5}\hlstd{,}
    \hlkwc{palette} \hlstd{=} \hlkwd{colorRampPalette}\hlstd{(}\hlkwd{c}\hlstd{(}\hlstr{"blue"}\hlstd{,} \hlstr{"yellow"}\hlstd{)))}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{figure}[ht!]
  \centering
  \caption{\footnotesize Minimum Spanning Network representing 4 simulated populations. Each node represents a different multi locus genotype (MLG). Node sizes and colors correspond to the number of individuals and population membership, respectively. Edge thickness and color are proportional to Bruvo's distance. Edge lengths are arbitrary.}
  \label{mst_bruvo}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.8\linewidth]{figure/bruvo_msn} 

}



\end{knitrout}

\end{figure}
\setkeys{Gin}{width=0.5\textwidth}

The output, as mentioned earlier, is a list containing the graph constructed via the \textit{igraph} package, a vector of the population names and a vector of colors representing the populations.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{library}\hlstd{(igraph)}
\hlstd{pc.msn}
\end{alltt}
\begin{verbatim}
## $graph
## IGRAPH UNW- 26 25 -- 
## + attr: name (v/c), size (v/n), shape (v/c), pie (v/x), pie.color (v/x), label
##   (v/c), weight (e/n), color (e/c), width (e/n)
## 
## $populations
## [1] "1" "2" "3" "4"
## 
## $colors
## [1] "#0000FF" "#5555AA" "#AAAA55" "#FFFF00"
\end{verbatim}
\end{kframe}
\end{knitrout}


Note that the thickness of the edges (the lines that are connecting the dots) is representative of relatedness between individuals, but the lengths do not necessarily mean anything due to the fact that with a larger data sets, displaying lengths proportional to relatedness would be impossible to draw on a 2D surface. Interpreting these data would show that MLG 9 has 5 individuals from all four populations and that it is most closely related to MLG 7, whereas the most distantly related connection exists between MLG 25 and MLG 26.
%\newpage
Since a graph can be represented in many ways, you might want to play around with different layouts using the \texttt{layout()} function in \textit{igraph}. Type \texttt{help("layout", package = igraph)} for details. Below is the code for reconstructing the previous graph using the output:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{9005}\hlstd{)}
\hlkwd{library}\hlstd{(igraph)}
\hlkwd{plot}\hlstd{(pc.msn}\hlopt{$}\hlstd{graph,} \hlkwc{vertex.size} \hlstd{=} \hlkwd{V}\hlstd{(pc.msn}\hlopt{$}\hlstd{graph)}\hlopt{$}\hlstd{size} \hlopt{*} \hlnum{3}\hlstd{,} \hlkwc{vertex.label.cex} \hlstd{=} \hlnum{0.7}\hlstd{,} \hlkwc{vertex.label.dist} \hlstd{=} \hlopt{-}\hlnum{0.5}\hlstd{,}
    \hlstd{)}
\hlkwd{legend}\hlstd{(}\hlopt{-}\hlnum{1.55}\hlstd{,} \hlnum{1}\hlstd{,} \hlkwc{bty} \hlstd{=} \hlstr{"n"}\hlstd{,} \hlkwc{cex} \hlstd{=} \hlnum{0.75}\hlstd{,} \hlkwc{legend} \hlstd{= pc.msn}\hlopt{$}\hlstd{populations,} \hlkwc{title} \hlstd{=} \hlstr{"Populations"}\hlstd{,}
    \hlkwc{fill} \hlstd{= pc.msn}\hlopt{$}\hlstd{colors,} \hlkwc{border} \hlstd{=} \hlkwa{NULL}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\subsubsection{Function: poppr.msn}
\label{index:trees:poppr.msn}

\tab\tab Use this function to draw a minimum spanning network from your data set and a distance matrix derived from your data set. Since there are hundreds of distances that can be calculated for genetic data, and since I want to be able to graduate at some point in this decade, functions to automatically calculate distances and draw the minimum spanning networks will be few and far between. This function is an attempt to meet the user halfway and draw a minimum spanning network provided that the user has supplied two things:
\begin{enumerate}
  \item A distance matrix over all individuals.
  \item The original data set containing demographic information.
\end{enumerate}

That's it. For the most part, this function is functionally the same as \texttt{bruvo.msn}, except that instead of being exclusive to microsatellite markers, you can now visualize distances in any marker type provided that you have the two items listed above.

\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
poppr.msn(pop, distmat, palette = topo.colors, sublist = "All", 
    blacklist = NULL, vertex.label = "MLG", gscale = TRUE, glim = c(0, 
        0.8), gadj = 3, gweight = 1, wscale = TRUE, showplot = TRUE, 
    ...)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{poppr.msn(pop, distmat, palette = topo.colors, sublist = "All",\\ 
%   \tab blacklist = NULL, vertex.label = "MLG", gscale = TRUE, glim = c(0, 0.8),\\ 
%   \tab gadj = 3, gweight = 1, wscale = TRUE, ...)
% }
\end{quote}
\begin{itemize}
  \item \texttt{pop -} a \texttt{genind} object.
  \item \texttt{distmat -} a dissimilarity distance matrix derived from your data with distances between zero and one.
  \item \texttt{palette -} this is a \textbf{function} definining a color palette to use. The default is \texttt{topo.colors}. There are different palettes, which you can search by typing \texttt{?rainbow}. If you want a custom color palette, an easy way is to use the function \texttt{colorRampPalette}.
  \item \texttt{sublist -} The populations you wish to analyze. This defaults to ``All".
  \item \texttt{blacklist -} Populations you do not want to include in the graph.
  \item \texttt{vertex.label -} This is an option that is passed on to \textit{igraph}'s \texttt{plot} function. \Poppr{} has added two arguments specific to \poppr{}. If you want to label the graph with the multilocus genotypes from the whole data set, use the argument \texttt{vertex.label = "mlg"}. If you want to display the representative individual names, you can use the argument \texttt{vertex.label = "inds"}. I say representative individual names because, only one representative from each MLG will be present in the clone corrected data set used to calculate the distance. For no labels, you can choose \texttt{vertex.label = NA}. 
  \item \texttt{gscale -} If this is set to \texttt{TRUE}, the edge color will be converted to greyscale based on the distance. If two nodes are closely related, the edge will appear darker. The limits of the scale can be set by the argument \texttt{glim}. If this is set to \texttt{FALSE}, all edge colors will be black. 
  \item \texttt{glim -} This is a vector of numbers between 0 and 1. This lets you set the limits of the grey scaling based on R's internal \texttt{grey} function. For example, if you wanted a maximum of 50\% white saturation (for use if you have distantly related nodes) and a minimum of 1\%, you would use \texttt{glim = c(0.01, 0.5)}. 
  \item \texttt{gadj -} This is an integer greater than zero used to adjust the scaling factor for the grey curve. Since very small changes in the grey scale are not easily precieved, it's useful to be able to adjust the grey scale to be able to show you the weights of each edge. For example, a population with most weights less than 0.3, you might want to set \texttt{gadj = 10} to exaggerate the grey scale. 
  \item \texttt{gweight -} If \texttt{gweight = 1}, the grey scale adjustment will be weighted towards separating out smaller values of the distance. If \texttt{gweight = 2}, the grey scale ajustment will be weighted towards separating out larger values of Bruvo's distance.
  \item \texttt{wscale -} If this is set to \texttt{TRUE}, edge widths will be displayed corresponding to Bruvo's distance in that thicker edges will represent a smaller distance between nodes. If this is set to \texttt{FALSE}, all edges will be set to a width of 2. 
  \item \texttt{... -} This is a placeholder for any other arguments that you want to supply to \textit{igraph}. Useful arguments are \texttt{vertex.label.cex} to adjust the size of the labels, \texttt{vertex.label.dist} to adjust the position of the labels, and \texttt{vertex.label.color} to adjust the color of the labels.
\end{itemize}

Since we have the ability, let's visualize the \textit{A. euteiches} data set \cite{Grunwald:2006}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Aeut)}
\hlstd{A.dist} \hlkwb{<-} \hlkwd{diss.dist}\hlstd{(Aeut)}
\hlkwd{set.seed}\hlstd{(}\hlnum{9005}\hlstd{)}
\hlstd{A.msn} \hlkwb{<-} \hlkwd{poppr.msn}\hlstd{(Aeut, A.dist,} \hlkwc{vertex.label} \hlstd{=} \hlnum{NA}\hlstd{,} \hlkwc{palette} \hlstd{= rainbow,} \hlkwc{gadj} \hlstd{=} \hlnum{15}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{figure}[ht!]
  \centering
  \caption{\footnotesize Minimum Spanning Network representing 4 simulated populations. Each node represents a different multi locus genotype (MLG). Node sizes and colors correspond to the number of individuals and population membership, respectively. Edge thickness and color are proportional to Bruvo's distance. Edge lengths are arbitrary.}
  \label{mst_poppr}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}

{\centering \includegraphics[width=0.8\linewidth]{figure/poppr_msn_fig} 

}



\end{knitrout}

\end{figure}
\newpage
%\subsubsection{Gory details} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{I know what you did last summary table \{diversity table\}}
\label{summary}

\tab\tab Remember the summary function that you used to get all the diversity statistics in section \ref{intro:qstart}? In this section, we will flesh out all that you can do with this function. This was the very first function that was written for \poppr{} to make it easy for the user to manipulate and summarize the data in one function.
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Function: poppr}
\label{summary:poppr}

\tab\tab This function is quite daunting with all its possibilities. You have the option to subset your data for specific populations, correct for missing data, and clone correct. With each of these possibilities, comes the need to provide all the arguments for their various functions.
\begin{quote}
Default Command:
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
poppr(dat, total = TRUE, sublist = "ALL", blacklist = NULL, sample = 0, 
    method = 1, missing = "ignore", cutoff = 0.05, quiet = FALSE, 
    clonecorrect = FALSE, hier = 1, dfname = "population_hierarchy", 
    keep = 1, hist = TRUE, minsamp = 10, legend = FALSE)
\end{verbatim}
\end{kframe}
\end{knitrout}

% \texttt{poppr(pop, total = TRUE, sublist = c("ALL"), blacklist = c(NULL), sample = 0,\\ 
%         \tab method = 1, missing = "ignore", cutoff = 0.05, quiet = FALSE, \\
%         \tab clonecorrect = FALSE, hier = c(1), dfname = "population\_hierarchy", \\
%         \tab hist = TRUE, minsamp = 10)}
\end{quote}
\begin{itemize}
  \item \texttt{dat -} A \texttt{genind} object, \texttt{genclone} object, or a 
  path to a file on your machine that contains genetix, structure, fstat, genpop,
  or genalex formatted data.
  \item \texttt{total -} This is also a synonym for ``pooled". This will calculate all diversity statistics on the entire data set if set to \texttt{TRUE} or if there is no population structure.
  \item \emph{popsub functions:} See section \ref{data.manip:divide}
  \begin{description}
    \item[sublist -] A list of populations you want to include in your analysis.
    \item[blacklist -] A list of populations you want to exclude from your analysis.
  \end{description}
  \item \emph{shufflepop functions:} See section \ref{data.manip:shuffle} \\ Note that this only affects the calculation for $I_A$ and $\bar r_d$.
  \begin{description}
    \item[sample -] The number of samples you desire (eg. 999)
    \item[method -] Which sampling method? 1: permute, 2: parametric bootstrap, 3: non-parametric bootstrap, 4: multilocus.
  \end{description}
  \item \emph{missingno functions:} See Section \ref{data.manip:missing} \\ Note that all analyses in this function ignore/impute missing data by default.
    \begin{description}
      \item[missing -] How to deal with missing data. This feeds into the \texttt{type} flag of \texttt{missingno}.
      \item[cutoff -] Allowable percentage of missing data per genotype or locus.
    \end{description}
  \item \texttt{quiet -} If set to \texttt{TRUE}, nothing will be printed to the screen as the sampling progresses. If \texttt{FALSE} (default) a progress bar will be produced.
  \item \emph{clonecorrect functions:} See section \ref{data.manip:cc}
  \begin{description}
    \item[clonecorrect -] if this is set to \texttt{TRUE}, then you will need to set the next two parameters.
    \item[hier -] A list of the population hierarchy, or names of columns in the data frame noted below.
    \item[dfname -] A data frame in the \texttt{@other} slot of the \texttt{genind} object containing all of the population factors in different columns. For an example, see sections \ref{data.manip:hier} and \ref{data.manip:cc}.
    \item[keep -] A vector of integers as indexes for the \texttt{hier} flag indicating which levels of the hierarchy you want to analyze. See section \ref{data.manip:cc} for details. 
  \end{description}
  \item \texttt{hist -} if \texttt{TRUE}, a histogram of distributions of $I_A$ and $\bar r_d$ will be displayed with each population if there is sampling.
  \item \texttt{minsamp -} The minimum number of individuals you want to use to calculate the expected number of MLGs. The default is set to 10.
\end{itemize}

This function produces a table that contains the population name, number of individuals observed, number of MLGs observed, number of MLGs expected at the lowest common sampling size within the data set \cite{Hurlbert:1971} \cite{Heck:1975}, the Shannon-Wiener index \cite{Shannon:1948}, Stoddart and Taylor's index for expected MLGs \cite{Stoddart:1988}, Nei's 1987 genotypic diversity \cite{Nei:1978}, evenness \cite{Pielou:1975}\cite{Ludwig:1988}\cite{Grunwald:2003}, the index of association \cite{Brown:1980}\cite{Smith:1993}, the standardized index of association \cite{Agapow:2001}, and the file name. Most of these indices are calculated by converting the population into an MLG table with \texttt{mlg.table} (see section \ref{mlg:table}) and using the \textit{vegan} package's \texttt{diversity} function (To see details, type \texttt{?vegan::diversity} into the R console).

To begin, let's revisit our example data set of \textit{Aphanomyces euteiches} \cite{Grunwald:2006}.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(Aeut)}
\hlkwd{poppr}\hlstd{(Aeut)}
\end{alltt}
\begin{verbatim}
## | Athena 
## | Mt. Vernon 
## | Total
##          Pop   N MLG eMLG   SE    H    G  Hexp   E.5    Ia  rbarD File
## 1     Athena  97  70 66.0 1.25 4.06 42.2 0.986 0.721  2.91 0.0724 Aeut
## 2 Mt. Vernon  90  50 50.0 0.00 3.67 28.7 0.976 0.726 13.30 0.2816 Aeut
## 3      Total 187 119 68.5 2.99 4.56 69.0 0.991 0.720 14.37 0.2706 Aeut
\end{verbatim}
\end{kframe}
\end{knitrout}

OK, so we were able to get a table out of this. Now let's see what happens when we do some sampling to see if this is reproducing clonally or not. We will turn quiet on and the histogram off to save space.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{poppr}\hlstd{(Aeut,} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##          Pop   N MLG  eMLG    SE     H     G   Hexp    E.5     Ia  p.Ia   rbarD  p.rD
## 1     Athena  97  70 65.98 1.246 4.063 42.19 0.9865 0.7210  2.906 0.001 0.07237 0.001
## 2 Mt. Vernon  90  50 50.00 0.000 3.668 28.72 0.9760 0.7259 13.302 0.001 0.28164 0.001
## 3      Total 187 119 68.45 2.989 4.558 68.97 0.9908 0.7201 14.371 0.001 0.27062 0.001
##   File
## 1 Aeut
## 2 Aeut
## 3 Aeut
\end{verbatim}
\end{kframe}
\end{knitrout}

From now on, we'll set \texttt{quiet = TRUE} to save space on our vignette. Let's clone correct at different levels to see if that affects the index of association. First, we'll clone correct at the sub population level.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{poppr}\hlstd{(Aeut,} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{clonecorrect} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hier} \hlstd{=} \hlkwd{c}\hlstd{(}\hlstr{"Pop"}\hlstd{,} \hlstr{"Subpop"}\hlstd{),} \hlkwc{dfname} \hlstd{=} \hlstr{"population_hierarchy"}\hlstd{,}
    \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##          Pop   N MLG  eMLG    SE     H     G   Hexp    E.5     Ia  p.Ia   rbarD  p.rD
## 1     Athena  76  70 60.62 1.017 4.221 65.64 0.9979 0.9630  2.535 0.001 0.06222 0.001
## 2 Mt. Vernon  65  50 50.00 0.000 3.796 36.74 0.9880 0.8214 14.310 0.001 0.29775 0.001
## 3      Total 141 119 59.63 1.854 4.705 96.98 0.9968 0.8762 13.802 0.001 0.26003 0.001
##   File
## 1 Aeut
## 2 Aeut
## 3 Aeut
\end{verbatim}
\end{kframe}
\end{knitrout}

And at the population level.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{poppr}\hlstd{(Aeut,} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{clonecorrect} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hier} \hlstd{=} \hlstr{"Pop"}\hlstd{,} \hlkwc{dfname} \hlstd{=} \hlstr{"population_hierarchy"}\hlstd{,}
    \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##          Pop   N MLG  eMLG        SE     H   G   Hexp   E.5     Ia  p.Ia   rbarD  p.rD
## 1     Athena  70  70 50.00 3.147e-06 4.248  70 1.0000 1.000  2.438 0.001 0.05955 0.001
## 2 Mt. Vernon  50  50 50.00 0.000e+00 3.912  50 1.0000 1.000 13.856 0.001 0.28508 0.001
## 3      Total 120 119 49.83 3.770e-01 4.776 118 0.9999 0.995 12.497 0.001 0.23426 0.001
##   File
## 1 Aeut
## 2 Aeut
## 3 Aeut
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see, clone correction doesn't always have to involve creation of new data sets!

You might notice that the P-values for both $I_A$ and $\bar r_d$ are often equal to each other. This will always be the case with the sampling method utilized in method 4 \cite{Agapow:2001}. Here, we show examples where they are not equal and why it's okay.
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{2002}\hlstd{)}
\hlkwd{poppr}\hlstd{(nancycats,} \hlkwc{sublist} \hlstd{=} \hlnum{5}\hlopt{:}\hlnum{6}\hlstd{,} \hlkwc{total} \hlstd{=} \hlnum{FALSE}\hlstd{,} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{method} \hlstd{=} \hlnum{2}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{hist} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##   Pop  N MLG eMLG        SE     H  G Hexp E.5       Ia  p.Ia     rbarD  p.rD      File
## 1   5 15  15   11 1.192e-07 2.708 15    1   1 -0.04754 0.576 -0.006004 0.576 nancycats
## 2   6 11  11   11 0.000e+00 2.398 11    1   1  0.33370 0.070  0.042616 0.071 nancycats
\end{verbatim}
\end{kframe}
\end{knitrout}

The reason why the P-values would be different is described at the end of section \ref{index:iard:ia}. The differences in P-values are normally not very far off. It's important to note this because of what can happen in extremely clonal populations. You can end up with a large enough sample size consisting of very few MLGs. Upon shuffling using method 4, you find that there are very few values of $I_A$ and $\bar r_d$ that can be obtained. Observe with this simulated data set:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{set.seed}\hlstd{(}\hlnum{2004}\hlstd{)}
\hlkwd{poppr}\hlstd{(}\hlkwd{system.file}\hlstd{(}\hlstr{"files/simulated.dat"}\hlstd{,} \hlkwc{package} \hlstd{=} \hlstr{"poppr"}\hlstd{),} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{,} \hlkwc{method} \hlstd{=} \hlnum{4}\hlstd{,} \hlkwc{quiet} \hlstd{=} \hlnum{TRUE}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##     Pop   N MLG eMLG SE     H    G   Hexp    E.5     Ia p.Ia   rbarD p.rD          File
## 1 Total 100   6    6  0 1.235 2.79 0.6481 0.7346 0.0504 0.09 0.06068 0.09 simulated.dat
\end{verbatim}
\end{kframe}
\end{knitrout}

\begin{figure}[h!]
  \centering
  \caption{\footnotesize Output of multilocus-style sampling. Note the multi-modal distribution.}
  \label{simulated_dist_fig}
  \includegraphics{simulated_dist_fig.png}
% <<fig=TRUE, echo=FALSE, resolution=300, figs.only=TRUE, width=8, height=8>>=
% set.seed(2004)
% der <- poppr(system.file("files/simulated.dat", package="poppr"), sample=999, method=1, quiet=TRUE, hist=TRUE)
% @
\end{figure}
\newpage

Take a look a these two histograms. The number of ways you can recombine the data with the default sampling method is very small. Other sampling methods could give a more theoretical distribution. Let's try the parametric bootstrap (For details, see section \ref{data.manip:shuffle}).
\begin{figure}[h!]
  \centering
  \caption{\footnotesize Output for parametric bootstrap sampling.}
  \label{simulated_param_fig}
  \includegraphics{simulated_param_fig.png}
% <<fig=TRUE, echo=FALSE, resolution=300, figs.only=TRUE, width=8, height=8>>=
% set.seed(2004)
% der <- poppr(system.file("files/simulated.dat", package="poppr"), sample=999, method=3, quiet=TRUE)
% @
\end{figure}

As you can see, the distribution is much closer to a distribution we would expect if this were a small sample of a larger population. 


%=============================================================================%
%=============================================================================%
%
%
%
%=============================================================================%
%=============================================================================%
\section{Appendix}
\label{appendix}
%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Algorithmic Details}
\label{appendix:algorithm}
\subsubsection{$I_A$ and $\bar r_d$}
\label{appendix:algorithm:iard}

\tab \tab The index of association was originally developed by A.H.D. Brown analyzing population structure of wheat \cite{Brown:1980}. It has been widely used as a tool to detect clonal reproduction within populations \cite{Smith:1993}. Populations whose members are undergoing sexual reproduction, whether it be selfing or out-crossing, will produce gametes via meiosis, and thus have a chance to shuffle alleles in the next generation. Populations whose members are undergoing clonal reproduction, however, generally do so via mitosis. This means that the most likely mechanism for a change in genotype is via mutation. The rate of mutation varies from species to species, but it is rarely sufficiently high to approximate a random shuffling of alleles. The index of association is a calculation based on the ratio of the variance of the raw number of differences between individuals and the sum of those variances over each locus \cite{Smith:1993}. You can also think of it as the observed variance over the expected variance. If they  are the same, then the index is zero after subtracting one (from Maynard-Smith, 1993 \cite{Smith:1993}):
\begin{equation}
\label{eq:I_A}
I_A = \frac{V_O}{V_E}-1
\end{equation}
Since the distance is more or less a binary distance, any sort of marker can be used for this analysis. In the calculation, phase is not considered, and any difference increases the distance between two individuals. Consider the genotypes of the dummy data frame we created earlier:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##    locus1  locus2  locus3
## 1 101/101 201/201 301/302
## 2 102/103 202/203 301/303
## 3 102/102 203/204 304/305
\end{verbatim}
\end{kframe}
\end{knitrout}

Now, consider the first locus represented in the genind object:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{verbatim}
##   L1.1 L1.2 L1.3
## 1    1  0.0  0.0
## 2    0  0.5  0.5
## 3    0  1.0  0.0
\end{verbatim}
\end{kframe}
\end{knitrout}

Remember that each column represents a different allele and that each entry in the table represents the fraction of the genotype made up by that allele at that locus. Notice also that the sum of the rows all equal one. \Poppr{} uses this to calculate distances by simply taking the sum of the absolute values of the differences between rows.

The calculation for the distance between two individuals at a single locus with $a$ allelic states and a ploidy of $k$ is as follows\footnote{Individuals with Presence / Absence data will have the $k/2$ term dropped.}:
\begin{equation}
\label{eq:ia_d}
d = \displaystyle \frac{k}{2}\sum_{i=1}^{a} \mid ind_{Ai} - ind_{Bi}\mid
\end{equation}
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{abs}\hlstd{(dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{1}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{]} \hlopt{-} \hlstd{dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{2}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{])}
\end{alltt}
\begin{verbatim}
## L1.1 L1.2 L1.3 
##  1.0  0.5  0.5
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{1}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{]} \hlopt{-} \hlstd{dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{3}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{])}
\end{alltt}
\begin{verbatim}
## L1.1 L1.2 L1.3 
##    1    1    0
\end{verbatim}
\begin{alltt}
\hlkwd{abs}\hlstd{(dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{2}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{]} \hlopt{-} \hlstd{dfg}\hlopt{@}\hlkwc{tab}\hlstd{[}\hlnum{3}\hlstd{,} \hlnum{1}\hlopt{:}\hlnum{3}\hlstd{])}
\end{alltt}
\begin{verbatim}
## L1.1 L1.2 L1.3 
##  0.0  0.5  0.5
\end{verbatim}
\end{kframe}
\end{knitrout}

As you can see, these values of $d$ at locus one add up to 2, 2, and 1, respectively.

To find the total number of differences between two individuals over all loci, you just take $d$ over $m$ loci, a value we'll call $D$:

\begin{equation}
\label{eq:ia_D}
D = \displaystyle \sum_{i=1}^{m} d_i
\end{equation}

These values are calculated over all possible combinations of individuals in the data set, ${n \choose 2}$ after which you end up with ${n \choose 2}\cdot{}m$ values of $d$ and ${n \choose 2}$ values of $D$.
Calculating the observed variances is fairly straightforward (modified from Agapow and Burt, 2001) \cite{Agapow:2001}:

\begin{equation}
\label{eq:V_O}
V_O = \frac{\displaystyle \sum_{i=1}^{n \choose 2} D_{i}^2 - \frac{(\displaystyle\sum_{i=1}^{n \choose 2} D_{i})^2}{{n \choose 2}}}{{n \choose 2}}
\end{equation}

Calculating the expected variance is the sum of each of the variances of the individual loci. The calculation at a single locus, $j$ is the same as the previous equation, substituting values of $D$ for $d$ \cite{Agapow:2001}:

\begin{equation}
\label{eq:var_j}
var_j = \frac{\displaystyle \sum_{i=1}^{n \choose 2} d_{i}^2 - \frac{(\displaystyle\sum_{i=1}^{n \choose 2} d_i)^2}{{n \choose 2}}}{{n \choose 2}}
\end{equation}

The expected variance is then the sum of all the variances over all $m$ loci \cite{Agapow:2001}:

\begin{equation}
\label{eq:V_E}
V_E = \displaystyle \sum_{j=1}^{m} var_j
\end{equation}

Now you can plug the sums of equations (\ref{eq:V_O}) and (\ref{eq:V_E}) into equation (\ref{eq:I_A}) to get the index of association.
Of course, Agapow and Burt showed that this index increases steadily with the number of loci, so they came up with an approximation that is widely used, $\bar r_d$ \cite{Agapow:2001}. For the derivation, see the manual for \textit{multilocus}. The equation is as follows, utilizing equations (\ref{eq:V_O}), (\ref{eq:var_j}), and (\ref{eq:V_E}) \cite{Agapow:2001}:

\begin{equation}
\label{eq:r_d}
\bar{r_d} = \frac{V_O - V_E}
{2\displaystyle \sum_{j=1}^{m}\displaystyle \sum_{k \neq j}^{m}\sqrt{var_j\cdot{}var_k}}
\end{equation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Bruvo's distance}
\label{appendix:algorithm:bruvo}

\tab \tab Bruvo's distance between two individuals calculates the minimum distance across all combinations of possible pairs of alleles at a single locus and then averaging that distance across all loci \cite{Bruvo:2004}. The distance between each pair of alleles is calculated as \cite{Bruvo:2004}:

\begin{equation}
\label{eq:m_x}
m_x = 2^{-\mid x \mid}
\end{equation}

\begin{equation}
\label{eq:d_a}
d_a = 1 - m_x
\end{equation}

Where $x$ is the number of steps between each allele. So, let's say we were comparing two haploid $(k = 1)$ individuals with alleles 228 and 244 at a locus that had a tetranucleotide repeat pattern (CATG$)^n$. The number of steps for each of these alleles would be $228/4 = 57$ and $244/4 =61$, respectively. The number of steps between them is then $\mid 57 - 61 \mid = 4$. Bruvo's distance at this locus between these two individuals is then $1-2^{-4} = 0.9375$. For samples with higher ploidy ($k$), there would be $k$ such distances of which we would need to take the sum \cite{Bruvo:2004}.

\begin{equation}
\label{eq:s_i}
s_i = \displaystyle \sum_{a=1}^{k} d_a
\end{equation}

Unfortunately, it's not as simple as that since we do not assume to know phase. Because of this, we need to take all possible combinations of alleles into account. This means that we will have $k^2$ values of $d_a$, when we only want $k$. How do we know which $k$ distances we want? We will have to invoke parsimony for this and attempt to take the minimum sum of the alleles, of which there are $k!$ possibilities \cite{Bruvo:2004}:

\begin{equation}
\label{eq:d_l}
d_l = \frac{\left(\displaystyle \min_{i \dotsc k!} s_i\right)}{k}
\end{equation}

Finally, after all of this, we can get the average distance over all loci \cite{Bruvo:2004}. 

\begin{equation}
\label{eq:D}
D = \frac{\displaystyle \sum_{i=1}^l d_i}{l}
\end{equation}

This is calculated over all possible combinations of individuals and results in a lower triangle distance matrix over all individuals. 

\subsubsection{Special Cases of Bruvo's distance}
\label{appendix:algorithm:bruvospecial}
\tab\tab As shown in the above section, ploidy is irrelevant with respect to calculation of Bruvo's distance. However, since it makes a comparison between all alleles at a locus, it only makes sense that the two loci need to have the same ploidy level. Unfortunately for polyploids, it's often difficult to fully separate distinct alleles at each locus, so you end up with genotypes that appear to have a lower ploidy level than the organism \cite{Bruvo:2004}. 

To help deal with these situatons, Bruvo has suggested three methods for dealing with these differences in ploidy levels \cite{Bruvo:2004}:
\begin{itemize}
  \item{Infinite Model -} The simplest way to deal with it is to count all missing alleles as infinitely large so that the distance between it and anything else is 1. Aside from this being computationally simple, it will tend to inflate distances between individuals. 
  \item{Genome Addition Model -} If it is suspected that the organism has gone through a recent genome expansion, the missing alleles will be replace with all possible combinations of the observed alleles in the shorter genotype. For example, if there is a genotype of [69, 70, 0, 0] where 0 is a missing allele, the possible combinations are: [69, 70, 69, 69], [69, 70, 69, 70], and [69, 70, 70, 70]. The resulting distances are then averaged over the number of comparisons. 
  \item{Genome Loss Model -} This is similar to the genome addition model, except that it assumes that there was a recent genome reduction event and uses the observed values in the full genotype to fill the missing values in the short genotype. As with the Genome Addition Model, the resulting distances are averaged over the number of comparisons.
  \item{Combination Model -} Combine and average the genome addition and loss models.
\end{itemize}

As mentioned above, the infinite model is biased, but it is not nearly as computationally intensive as either of the other models. The reason for this is that both of the addition and loss models requires replacement of alleles and recalculation of Bruvo's distance. The number of replacements required is equal to the multiset coefficient: $\left({n \choose k}\right) == {(n-k+1) \choose k}$ where $n$ is the number of potential replacements and $k$ is the number of alleles to be replaced. So, for the example given above, The genome addition model would require $\left({2 \choose 2}\right) = 3$ calculations of Bruvo's distance, whereas the genome loss model would require $\left({4 \choose 2}\right) = 10$ calculations. 

To reduce the number of calcuations and assumptions otherwise, Bruvo's distance will be calculated using the largest observed ploidy. This means that when comparing [69,70,71,0] and [59,60,0,0], they will be treated as triploids.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Exporting Graphics}
\label{appendix:graphics}
\tab\tab R has the ability to produce nice graphics from most any type of data, but to get these graphics into a report, presentation, or manuscript can be a bit challenging. It's no secret that the R Documentation pages are a little difficult to interpret, so I will give the reader here a short example on how to export graphics from R. Note that any code here that will produce images will also be present in other places in this vignette. The default installation of the R GUI is quite minimal, and for an easy way to manage your plots and code, I strongly encourage the user to use Rstudio \url{http://www.rstudio.com/}.

\subsubsection{Basics}
\label{appendix:graphics:basics}
\tab\tab Before you export graphics, you have to ask yourself what they will be used for. If you want to use the graphic for a website, you might want to opt for a low-resolution image so that it can load quickly. With printing, you'll want to make sure that you have a scalable or at least a very high resolution image. Here, I will give some general guidelines for graphics (note that these are merely suggestions, not defined rules).
\begin{itemize}
  \item \textbf{What you see is not always what you get} I have often seen presentations where the colors were too light or posters with painfully pixellated graphs. Think about what you are going to be using a graphic for and how it will appear to the intended audience given the media type.
  \item \textbf{$\geq$ 300 dpi unless its for a web page} For any sort of printed material that requires a raster based image, 300dpi (dots per inch) is the absolute minimum resolution you should use. For simple black and white line images, 1200dpi is better. This will leave you with crisp, professional looking images.
  \item \textbf{If possible, save to SVG, then rasterize} Raster images (bmp, png, jpg, etc...) are based off of the number of pixels or dots per inch it takes to render the image. This means that the raster image is more or less a very fine mosaic. Vector images (SVG) are built upon several interconnected polygons, arcs, and lines that scale relative to one another to create your graphic. With vector graphics, you can produce a plot and scale it to the size of a building if you wanted to. When you save to an SVG file first, you can also manipulate it in programs such as Adobe Illustrator or Inkscape. 
  \item \textbf{Before saving, make sure the units and dimensions are correct} Unless you really wanted to save a graph that's over 6 feet wide.
\end{itemize}

\subsubsection{Image Editors}
\label{appendix:graphics:editors}
\tab\tab Often times, fine details such as labels on networks need to be tweaked by hand. Luckily, there are a wide variety of programs that can help you do that. Here is a short list of image editors (both free and for a price) that you can use to edit your graphics.
\begin{itemize}
  \item Bitmap based editors (for jpeg, bmp, png, etc...)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape The GIMP ] Free, cross-platform. \url{http://www.gimp.org}
    \item[ \scshape Paint.net ] Free, Windows only. \url{http://www.getpaint.net}
    \item[ \scshape Adobe Photoshop ] Pricey, Windows and Mac. \url{http://www.adobe.com/products/photoshop.html}
  \end{itemize}
  \end{quote}
  \item Scalable Vector Graphics based editors (for svg, pdf)
  \begin{quote}
  \begin{itemize}
    \item[ \scshape Inkscape ] Free, cross-platform \url{http://inkscape.org}
    \item[ \scshape Adobe Illustrator ] Pricey, Windows and Mac. \url{http://www.adobe.com/products/illustrator.html}
  \end{itemize}
  \end{quote}
\end{itemize}

\subsubsection{Exporting ggplot2 graphics}
\label{appendix:graphics:ggplot2}
\tab\tab \textit{ggplot2} is a fantastic package that \poppr{} uses to produce graphs for the \texttt{mlg.table}, \texttt{poppr}, and \texttt{ia} functions. Saving a plot with \textit{ggplot2} is performed with one command after your plot has rendered:
\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(nancycats)}  \hlcom{# Load the data set.}
\hlkwd{poppr}\hlstd{(nancycats,} \hlkwc{sublist} \hlstd{=} \hlnum{5}\hlstd{,} \hlkwc{sample} \hlstd{=} \hlnum{999}\hlstd{)}  \hlcom{# Produce a single plot.}
\hlkwd{ggsave}\hlstd{(}\hlstr{"nancy5.pdf"}\hlstd{)}
\end{alltt}
\end{kframe}
\end{knitrout}

Note that you can name the file anything, and \texttt{ggsave} will save it in that format for you. The details are in the documentation and you can access it by typing \texttt{help("ggsave")} in your R console. The important things to note are that you can set a \texttt{width}, \texttt{height}, and \texttt{unit}. The only downside to this function is that you can only save one plot at a time. If you want to be able to save multiple plots, read on to the next section.

\subsubsection{Exporting any graphics}
\label{appendix:graphics:export}
\tab\tab Some of the functions that \poppr{} offers will give you multiple plots, and if you want to save them all, using \texttt{ggsave} will require a lot of tedious typing and clicking. Luckily, R has Functions that will save any plot you generate in nearly any image format you want. You can save in raster images such as png, bpm, and jpeg. You can also save in vector based images such as svg, pdf, and postscript. The important thing to remember is that when you are saving in a raster format, the default units of measurement are ``pixels", but you can change that by specifying your unit of choice and a resolution.

For raster images and svg files, you can only save your plots in multiple files, but pdf and postscript plots can be saved in one file as multiple pages. All of these functions have the same basic form. You call the function to specify the file type you want (eg. \texttt{pdf("myfile.pdf")}), create any graphs that you want to create, and then make sure to close the session with the function \texttt{dev.off()}. Let's give an example saving to pdf and png files. 

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{data}\hlstd{(H3N2)}
\hlkwd{pop}\hlstd{(H3N2)} \hlkwb{<-} \hlstd{H3N2}\hlopt{$}\hlstd{other}\hlopt{$}\hlstd{x}\hlopt{$}\hlstd{country}
\hlcom{#### }
\hlkwd{png}\hlstd{(}\hlstr{"H3N2_barchart%02d.png"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{14}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{14}\hlstd{,} \hlkwc{units} \hlstd{=} \hlstr{"in"}\hlstd{,} \hlkwc{res} \hlstd{=} \hlnum{300}\hlstd{)}
\hlstd{H.tab} \hlkwb{<-} \hlkwd{mlg.table}\hlstd{(H3N2)}
\hlkwd{dev.off}\hlstd{()}
\hlcom{#### }
\end{alltt}
\end{kframe}
\end{knitrout}


Since this data set is made up of 30 populations with more than 1 individual, this will save 30 files to your working directory named ``H3N2\_barchart01.png...H3N2\_barchart30.png". The way R knows how to number these files is because of the \texttt{\%02d} part of the command. That's telling R to use a number that is two digits long in place of that expression. All of these files will be 14x14" and will have a resolution of 300 dots per inch. If you wanted to do the same thing, but place them all in one file, you should use the pdf option.

\begin{knitrout}\footnotesize
\definecolor{shadecolor}{rgb}{0.933, 0.933, 0.933}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{pdf}\hlstd{(}\hlstr{"H3N2_barcharts.png"}\hlstd{,} \hlkwc{width} \hlstd{=} \hlnum{14}\hlstd{,} \hlkwc{height} \hlstd{=} \hlnum{14}\hlstd{,} \hlkwc{compress} \hlstd{=} \hlnum{FALSE}\hlstd{)}
\hlstd{H.tab} \hlkwb{<-} \hlkwd{mlg.table}\hlstd{(H3N2)}
\hlkwd{dev.off}\hlstd{()}
\end{alltt}
\end{kframe}
\end{knitrout}


Remember, it is important not to forget to type \texttt{dev.off()} when you are done making graphs. Note that I did not have to specify a resolution for this image since it is based off of vector graphics.

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Todo}

\begin{itemize}
  \item locus\_table
  \item missing\_table
  \item amova
  \item private\_alleles
  \item anyboot
  \item *.dist
\end{itemize}

%-----------------------------------------------------------------------------%
%
%-----------------------------------------------------------------------------%
\subsection{Table of Functions}
\label{appendix:funk}

\tab\tab Below is a table of functions found in \poppr{}. These functions are
linked within the document. Simply click on a funciton name to go to its definition 
and description. 

\begin{table}[h!]
\centering
\begin{tabular}{ll}
\textbf{\large Function} & \textbf{\large Description} \\ 
\hline
\textbf{Import/Export} & \\
\cmdlink{intro:import:getfile}{getfile} & Provides a quick GUI to grab files for import \\
\cmdlink{intro:import:read.genalex}{read.genalex} & Read \textit{GenAlEx} formatted csv files to a genind object \\
\cmdlink{intro:import:genind2genalex}{genind2genalex} & Converts genind objects to \textit{GenAlEx} formatted csv files \\
\cmdlink{intro:genclone:as.genclone}{as.genclone} & Converts genind objects to genclone objects \\
\hline
\textbf{Manipulation} & \\
\cmdlink{data.manip:hier:setpop}{setpop} & Set the population using defined hierarchies\\
\cmdlink{data.manip:hier:define}{splithierarchy} & Split a concatenated hierarchy imported as a population\\
\cmdlink{data.manip:hier:define}{sethierarchy} & Define a population hierarchy of a genclone object\\
\cmdlink{data.manip:hier:view}{gethierarchy} & Extract the hierarchy data frame\\
\cmdlink{data.manip:hier:manip}{addhierarchy} & Add a vector or data frame to an existing hierarchy \\
\cmdlink{data.manip:hier:manip}{namehierarchy} & Rename a population hierarchy\\
\cmdlink{data.manip:missing:missingno}{missingno} & Handles missing data \\
\cmdlink{data.manip:cc:clonecorrect}{clonecorrect} & Clone censors at a specified population hierarchy \\
\cmdlink{data.manip:informloci}{informloci} & Detects and removes phylogenetically uninformative loci \\
\cmdlink{data.manip:divide:popsub}{popsub} & Subsets genind objects by population \\
\cmdlink{data.manip:shuffle:shufflepop}{shufflepop} & Shuffles genotypes at each locus using four different shuffling algorithms \\
\texttt{splitcombine*} & Manipulates population hierarchy *Deprecated\\ 
\hline
\textbf{Analysis} & \\
\cmdlink{index:trees:bruvo.boot}{bruvo.boot} & Produces dendrograms with bootstrap support based on Bruvo's distance \\
\cmdlink{index:bruvo:bruvo.dist}{bruvo.dist} & Calculates Bruvo's distance \\
\cmdlink{index:dist:diss.dist}{diss.dist} & Calculates the percent allelic dissimilarity \\
\cmdlink{index:iard:ia}{ia} & Calculates the index of association \\
\cmdlink{mlg:mlg:mlg}{mlg} & Calculates the number of multilocus genotypes \\
\cmdlink{mlg:cross:mlg.crosspop}{mlg.crosspop} & Finds all multilocus genotypes that cross populations \\
\cmdlink{mlg:table:mlg.table}{mlg.table} & Returns a table of populations by multilocus genotypes \\
\cmdlink{mlg:mix:mlg.vector}{mlg.vector} & Returns a vector of a numeric multilocus genotype assignment for \\ 
 & each individual \\
\cmdlink{summary:poppr}{poppr} & Returns a diversity table by population \\
\cmdlink{summary:poppr}{poppr.all} & Returns a diversity table by population for all compatible files specified \\
\hline
\textbf{Visualization} & \\
\cmdlink{index:trees:greycurve}{greycurve} & Helper to determine the appropriate parameters for adjusting the\\
 & grey level for msn functions \\
\cmdlink{index:trees:bruvo.msn}{bruvo.msn} & Produces minimum spanning networks based off Bruvo's distance\\
 & colored by population \\
\cmdlink{index:trees:poppr.msn}{poppr.msn} & Produces a minimum spanning network for any pairwise distance\\  
 & matrix related to the data \\
\hline
\end{tabular}
\end{table}

\newpage

\bibliographystyle{plain}
\bibliography{poppr_man}
\end{document}
